{"version":3,"file":"pdf.min.js","sources":["../../../src/pdfjs/build/pdf.js"],"sourcesContent":["/**\r\n * @licstart The following is the entire license notice for the\r\n * Javascript code in this page\r\n *\r\n * Copyright 2020 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n * @licend The above is the entire license notice for the\r\n * Javascript code in this page\r\n */\r\n\r\n(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(typeof exports === 'object' && typeof module === 'object')\r\n\t\tmodule.exports = factory();\r\n\telse if(typeof define === 'function' && define.amd)\r\n\t\tdefine(\"pdfjs-dist/build/pdf\", [], factory);\r\n\telse if(typeof exports === 'object')\r\n\t\texports[\"pdfjs-dist/build/pdf\"] = factory();\r\n\telse\r\n\t\troot[\"pdfjs-dist/build/pdf\"] = root.pdfjsLib = factory();\r\n})(this, function() {\r\nreturn /******/ (() => { // webpackBootstrap\r\n/******/ \t\"use strict\";\r\n/******/ \tvar __webpack_modules__ = ([\r\n/* 0 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nObject.defineProperty(exports, \"addLinkAttributes\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _display_utils.addLinkAttributes;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"getFilenameFromUrl\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _display_utils.getFilenameFromUrl;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"LinkTarget\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _display_utils.LinkTarget;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"loadScript\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _display_utils.loadScript;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"PDFDateString\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _display_utils.PDFDateString;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"RenderingCancelledException\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _display_utils.RenderingCancelledException;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"build\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _api.build;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"getDocument\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _api.getDocument;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"LoopbackPort\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _api.LoopbackPort;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"PDFDataRangeTransport\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _api.PDFDataRangeTransport;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"PDFWorker\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _api.PDFWorker;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"version\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _api.version;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"CMapCompressionType\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.CMapCompressionType;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"createObjectURL\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.createObjectURL;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"createPromiseCapability\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.createPromiseCapability;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"createValidAbsoluteUrl\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.createValidAbsoluteUrl;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"InvalidPDFException\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.InvalidPDFException;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"MissingPDFException\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.MissingPDFException;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"OPS\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.OPS;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"PasswordResponses\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.PasswordResponses;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"PermissionFlag\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.PermissionFlag;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"removeNullCharacters\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.removeNullCharacters;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"shadow\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.shadow;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"UnexpectedResponseException\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.UnexpectedResponseException;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"UNSUPPORTED_FEATURES\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.UNSUPPORTED_FEATURES;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"Util\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.Util;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"VerbosityLevel\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _util.VerbosityLevel;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"AnnotationLayer\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _annotation_layer.AnnotationLayer;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"apiCompatibilityParams\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _api_compatibility.apiCompatibilityParams;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"GlobalWorkerOptions\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _worker_options.GlobalWorkerOptions;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"renderTextLayer\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _text_layer.renderTextLayer;\r\n  }\r\n}));\r\nObject.defineProperty(exports, \"SVGGraphics\", ({\r\n  enumerable: true,\r\n  get: function () {\r\n    return _svg.SVGGraphics;\r\n  }\r\n}));\r\n\r\nvar _display_utils = __w_pdfjs_require__(1);\r\n\r\nvar _api = __w_pdfjs_require__(5);\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nvar _annotation_layer = __w_pdfjs_require__(19);\r\n\r\nvar _api_compatibility = __w_pdfjs_require__(9);\r\n\r\nvar _worker_options = __w_pdfjs_require__(12);\r\n\r\nvar _text_layer = __w_pdfjs_require__(21);\r\n\r\nvar _svg = __w_pdfjs_require__(22);\r\n\r\nconst pdfjsVersion = '2.7.570';\r\nconst pdfjsBuild = 'f2c7338b0';\r\n{\r\n  const {\r\n    isNodeJS\r\n  } = __w_pdfjs_require__(4);\r\n\r\n  if (isNodeJS) {\r\n    const PDFNodeStream = __w_pdfjs_require__(23).PDFNodeStream;\r\n\r\n    (0, _api.setPDFNetworkStreamFactory)(params => {\r\n      return new PDFNodeStream(params);\r\n    });\r\n  } else {\r\n    const PDFNetworkStream = __w_pdfjs_require__(26).PDFNetworkStream;\r\n\r\n    let PDFFetchStream;\r\n\r\n    if ((0, _display_utils.isFetchSupported)()) {\r\n      PDFFetchStream = __w_pdfjs_require__(27).PDFFetchStream;\r\n    }\r\n\r\n    (0, _api.setPDFNetworkStreamFactory)(params => {\r\n      if (PDFFetchStream && (0, _display_utils.isValidFetchUrl)(params.url)) {\r\n        return new PDFFetchStream(params);\r\n      }\r\n\r\n      return new PDFNetworkStream(params);\r\n    });\r\n  }\r\n}\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.addLinkAttributes = addLinkAttributes;\r\nexports.deprecated = deprecated;\r\nexports.getFilenameFromUrl = getFilenameFromUrl;\r\nexports.isFetchSupported = isFetchSupported;\r\nexports.isValidFetchUrl = isValidFetchUrl;\r\nexports.loadScript = loadScript;\r\nexports.StatTimer = exports.RenderingCancelledException = exports.PDFDateString = exports.PageViewport = exports.LinkTarget = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.BaseCMapReaderFactory = exports.BaseCanvasFactory = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nconst DEFAULT_LINK_REL = \"noopener noreferrer nofollow\";\r\nexports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;\r\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\r\n\r\nclass BaseCanvasFactory {\r\n  constructor() {\r\n    if (this.constructor === BaseCanvasFactory) {\r\n      (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\r\n    }\r\n  }\r\n\r\n  create(width, height) {\r\n    (0, _util.unreachable)(\"Abstract method `create` called.\");\r\n  }\r\n\r\n  reset(canvasAndContext, width, height) {\r\n    if (!canvasAndContext.canvas) {\r\n      throw new Error(\"Canvas is not specified\");\r\n    }\r\n\r\n    if (width <= 0 || height <= 0) {\r\n      throw new Error(\"Invalid canvas size\");\r\n    }\r\n\r\n    canvasAndContext.canvas.width = width;\r\n    canvasAndContext.canvas.height = height;\r\n  }\r\n\r\n  destroy(canvasAndContext) {\r\n    if (!canvasAndContext.canvas) {\r\n      throw new Error(\"Canvas is not specified\");\r\n    }\r\n\r\n    canvasAndContext.canvas.width = 0;\r\n    canvasAndContext.canvas.height = 0;\r\n    canvasAndContext.canvas = null;\r\n    canvasAndContext.context = null;\r\n  }\r\n\r\n}\r\n\r\nexports.BaseCanvasFactory = BaseCanvasFactory;\r\n\r\nclass DOMCanvasFactory extends BaseCanvasFactory {\r\n  constructor({\r\n    ownerDocument = globalThis.document\r\n  } = {}) {\r\n    super();\r\n    this._document = ownerDocument;\r\n  }\r\n\r\n  create(width, height) {\r\n    if (width <= 0 || height <= 0) {\r\n      throw new Error(\"Invalid canvas size\");\r\n    }\r\n\r\n    const canvas = this._document.createElement(\"canvas\");\r\n\r\n    const context = canvas.getContext(\"2d\");\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    return {\r\n      canvas,\r\n      context\r\n    };\r\n  }\r\n\r\n}\r\n\r\nexports.DOMCanvasFactory = DOMCanvasFactory;\r\n\r\nclass BaseCMapReaderFactory {\r\n  constructor({\r\n    baseUrl = null,\r\n    isCompressed = false\r\n  }) {\r\n    if (this.constructor === BaseCMapReaderFactory) {\r\n      (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\r\n    }\r\n\r\n    this.baseUrl = baseUrl;\r\n    this.isCompressed = isCompressed;\r\n  }\r\n\r\n  async fetch({\r\n    name\r\n  }) {\r\n    if (!this.baseUrl) {\r\n      throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\r\n    }\r\n\r\n    if (!name) {\r\n      throw new Error(\"CMap name must be specified.\");\r\n    }\r\n\r\n    const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\r\n    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\r\n    return this._fetchData(url, compressionType).catch(reason => {\r\n      throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\r\n    });\r\n  }\r\n\r\n  _fetchData(url, compressionType) {\r\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\r\n  }\r\n\r\n}\r\n\r\nexports.BaseCMapReaderFactory = BaseCMapReaderFactory;\r\n\r\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\r\n  _fetchData(url, compressionType) {\r\n    if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {\r\n      return fetch(url).then(async response => {\r\n        if (!response.ok) {\r\n          throw new Error(response.statusText);\r\n        }\r\n\r\n        let cMapData;\r\n\r\n        if (this.isCompressed) {\r\n          cMapData = new Uint8Array(await response.arrayBuffer());\r\n        } else {\r\n          cMapData = (0, _util.stringToBytes)(await response.text());\r\n        }\r\n\r\n        return {\r\n          cMapData,\r\n          compressionType\r\n        };\r\n      });\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = new XMLHttpRequest();\r\n      request.open(\"GET\", url, true);\r\n\r\n      if (this.isCompressed) {\r\n        request.responseType = \"arraybuffer\";\r\n      }\r\n\r\n      request.onreadystatechange = () => {\r\n        if (request.readyState !== XMLHttpRequest.DONE) {\r\n          return;\r\n        }\r\n\r\n        if (request.status === 200 || request.status === 0) {\r\n          let cMapData;\r\n\r\n          if (this.isCompressed && request.response) {\r\n            cMapData = new Uint8Array(request.response);\r\n          } else if (!this.isCompressed && request.responseText) {\r\n            cMapData = (0, _util.stringToBytes)(request.responseText);\r\n          }\r\n\r\n          if (cMapData) {\r\n            resolve({\r\n              cMapData,\r\n              compressionType\r\n            });\r\n            return;\r\n          }\r\n        }\r\n\r\n        reject(new Error(request.statusText));\r\n      };\r\n\r\n      request.send(null);\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexports.DOMCMapReaderFactory = DOMCMapReaderFactory;\r\n\r\nclass DOMSVGFactory {\r\n  create(width, height) {\r\n    (0, _util.assert)(width > 0 && height > 0, \"Invalid SVG dimensions\");\r\n    const svg = document.createElementNS(SVG_NS, \"svg:svg\");\r\n    svg.setAttribute(\"version\", \"1.1\");\r\n    svg.setAttribute(\"width\", width + \"px\");\r\n    svg.setAttribute(\"height\", height + \"px\");\r\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\r\n    svg.setAttribute(\"viewBox\", \"0 0 \" + width + \" \" + height);\r\n    return svg;\r\n  }\r\n\r\n  createElement(type) {\r\n    (0, _util.assert)(typeof type === \"string\", \"Invalid SVG element type\");\r\n    return document.createElementNS(SVG_NS, type);\r\n  }\r\n\r\n}\r\n\r\nexports.DOMSVGFactory = DOMSVGFactory;\r\n\r\nclass PageViewport {\r\n  constructor({\r\n    viewBox,\r\n    scale,\r\n    rotation,\r\n    offsetX = 0,\r\n    offsetY = 0,\r\n    dontFlip = false\r\n  }) {\r\n    this.viewBox = viewBox;\r\n    this.scale = scale;\r\n    this.rotation = rotation;\r\n    this.offsetX = offsetX;\r\n    this.offsetY = offsetY;\r\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\r\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\r\n    let rotateA, rotateB, rotateC, rotateD;\r\n    rotation = rotation % 360;\r\n    rotation = rotation < 0 ? rotation + 360 : rotation;\r\n\r\n    switch (rotation) {\r\n      case 180:\r\n        rotateA = -1;\r\n        rotateB = 0;\r\n        rotateC = 0;\r\n        rotateD = 1;\r\n        break;\r\n\r\n      case 90:\r\n        rotateA = 0;\r\n        rotateB = 1;\r\n        rotateC = 1;\r\n        rotateD = 0;\r\n        break;\r\n\r\n      case 270:\r\n        rotateA = 0;\r\n        rotateB = -1;\r\n        rotateC = -1;\r\n        rotateD = 0;\r\n        break;\r\n\r\n      case 0:\r\n        rotateA = 1;\r\n        rotateB = 0;\r\n        rotateC = 0;\r\n        rotateD = -1;\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\r\n    }\r\n\r\n    if (dontFlip) {\r\n      rotateC = -rotateC;\r\n      rotateD = -rotateD;\r\n    }\r\n\r\n    let offsetCanvasX, offsetCanvasY;\r\n    let width, height;\r\n\r\n    if (rotateA === 0) {\r\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\r\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\r\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\r\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\r\n    } else {\r\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\r\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\r\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\r\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\r\n    }\r\n\r\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\r\n    this.width = width;\r\n    this.height = height;\r\n  }\r\n\r\n  clone({\r\n    scale = this.scale,\r\n    rotation = this.rotation,\r\n    offsetX = this.offsetX,\r\n    offsetY = this.offsetY,\r\n    dontFlip = false\r\n  } = {}) {\r\n    return new PageViewport({\r\n      viewBox: this.viewBox.slice(),\r\n      scale,\r\n      rotation,\r\n      offsetX,\r\n      offsetY,\r\n      dontFlip\r\n    });\r\n  }\r\n\r\n  convertToViewportPoint(x, y) {\r\n    return _util.Util.applyTransform([x, y], this.transform);\r\n  }\r\n\r\n  convertToViewportRectangle(rect) {\r\n    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\r\n\r\n    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\r\n\r\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\r\n  }\r\n\r\n  convertToPdfPoint(x, y) {\r\n    return _util.Util.applyInverseTransform([x, y], this.transform);\r\n  }\r\n\r\n}\r\n\r\nexports.PageViewport = PageViewport;\r\n\r\nclass RenderingCancelledException extends _util.BaseException {\r\n  constructor(msg, type) {\r\n    super(msg);\r\n    this.type = type;\r\n  }\r\n\r\n}\r\n\r\nexports.RenderingCancelledException = RenderingCancelledException;\r\nconst LinkTarget = {\r\n  NONE: 0,\r\n  SELF: 1,\r\n  BLANK: 2,\r\n  PARENT: 3,\r\n  TOP: 4\r\n};\r\nexports.LinkTarget = LinkTarget;\r\n\r\nfunction addLinkAttributes(link, {\r\n  url,\r\n  target,\r\n  rel,\r\n  enabled = true\r\n} = {}) {\r\n  (0, _util.assert)(url && typeof url === \"string\", 'addLinkAttributes: A valid \"url\" parameter must provided.');\r\n  const urlNullRemoved = (0, _util.removeNullCharacters)(url);\r\n\r\n  if (enabled) {\r\n    link.href = link.title = urlNullRemoved;\r\n  } else {\r\n    link.href = \"\";\r\n    link.title = `Disabled: ${urlNullRemoved}`;\r\n\r\n    link.onclick = () => {\r\n      return false;\r\n    };\r\n  }\r\n\r\n  let targetStr = \"\";\r\n\r\n  switch (target) {\r\n    case LinkTarget.NONE:\r\n      break;\r\n\r\n    case LinkTarget.SELF:\r\n      targetStr = \"_self\";\r\n      break;\r\n\r\n    case LinkTarget.BLANK:\r\n      targetStr = \"_blank\";\r\n      break;\r\n\r\n    case LinkTarget.PARENT:\r\n      targetStr = \"_parent\";\r\n      break;\r\n\r\n    case LinkTarget.TOP:\r\n      targetStr = \"_top\";\r\n      break;\r\n  }\r\n\r\n  link.target = targetStr;\r\n  link.rel = typeof rel === \"string\" ? rel : DEFAULT_LINK_REL;\r\n}\r\n\r\nfunction getFilenameFromUrl(url) {\r\n  const anchor = url.indexOf(\"#\");\r\n  const query = url.indexOf(\"?\");\r\n  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\r\n  return url.substring(url.lastIndexOf(\"/\", end) + 1, end);\r\n}\r\n\r\nclass StatTimer {\r\n  constructor() {\r\n    this.started = Object.create(null);\r\n    this.times = [];\r\n  }\r\n\r\n  time(name) {\r\n    if (name in this.started) {\r\n      (0, _util.warn)(`Timer is already running for ${name}`);\r\n    }\r\n\r\n    this.started[name] = Date.now();\r\n  }\r\n\r\n  timeEnd(name) {\r\n    if (!(name in this.started)) {\r\n      (0, _util.warn)(`Timer has not been started for ${name}`);\r\n    }\r\n\r\n    this.times.push({\r\n      name,\r\n      start: this.started[name],\r\n      end: Date.now()\r\n    });\r\n    delete this.started[name];\r\n  }\r\n\r\n  toString() {\r\n    const outBuf = [];\r\n    let longest = 0;\r\n\r\n    for (const time of this.times) {\r\n      const name = time.name;\r\n\r\n      if (name.length > longest) {\r\n        longest = name.length;\r\n      }\r\n    }\r\n\r\n    for (const time of this.times) {\r\n      const duration = time.end - time.start;\r\n      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\\n`);\r\n    }\r\n\r\n    return outBuf.join(\"\");\r\n  }\r\n\r\n}\r\n\r\nexports.StatTimer = StatTimer;\r\n\r\nfunction isFetchSupported() {\r\n  return typeof fetch !== \"undefined\" && typeof Response !== \"undefined\" && \"body\" in Response.prototype && typeof ReadableStream !== \"undefined\";\r\n}\r\n\r\nfunction isValidFetchUrl(url, baseUrl) {\r\n  try {\r\n    const {\r\n      protocol\r\n    } = baseUrl ? new URL(url, baseUrl) : new URL(url);\r\n    return protocol === \"http:\" || protocol === \"https:\";\r\n  } catch (ex) {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction loadScript(src, removeScriptElement = false) {\r\n  return new Promise((resolve, reject) => {\r\n    const script = document.createElement(\"script\");\r\n    script.src = src;\r\n\r\n    script.onload = function (evt) {\r\n      if (removeScriptElement) {\r\n        script.remove();\r\n      }\r\n\r\n      resolve(evt);\r\n    };\r\n\r\n    script.onerror = function () {\r\n      reject(new Error(`Cannot load script at: ${script.src}`));\r\n    };\r\n\r\n    (document.head || document.documentElement).appendChild(script);\r\n  });\r\n}\r\n\r\nfunction deprecated(details) {\r\n  console.log(\"Deprecated API usage: \" + details);\r\n}\r\n\r\nlet pdfDateStringRegex;\r\n\r\nclass PDFDateString {\r\n  static toDateObject(input) {\r\n    if (!input || !(0, _util.isString)(input)) {\r\n      return null;\r\n    }\r\n\r\n    if (!pdfDateStringRegex) {\r\n      pdfDateStringRegex = new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\r\n    }\r\n\r\n    const matches = pdfDateStringRegex.exec(input);\r\n\r\n    if (!matches) {\r\n      return null;\r\n    }\r\n\r\n    const year = parseInt(matches[1], 10);\r\n    let month = parseInt(matches[2], 10);\r\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\r\n    let day = parseInt(matches[3], 10);\r\n    day = day >= 1 && day <= 31 ? day : 1;\r\n    let hour = parseInt(matches[4], 10);\r\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\r\n    let minute = parseInt(matches[5], 10);\r\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\r\n    let second = parseInt(matches[6], 10);\r\n    second = second >= 0 && second <= 59 ? second : 0;\r\n    const universalTimeRelation = matches[7] || \"Z\";\r\n    let offsetHour = parseInt(matches[8], 10);\r\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\r\n    let offsetMinute = parseInt(matches[9], 10) || 0;\r\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\r\n\r\n    if (universalTimeRelation === \"-\") {\r\n      hour += offsetHour;\r\n      minute += offsetMinute;\r\n    } else if (universalTimeRelation === \"+\") {\r\n      hour -= offsetHour;\r\n      minute -= offsetMinute;\r\n    }\r\n\r\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\r\n  }\r\n\r\n}\r\n\r\nexports.PDFDateString = PDFDateString;\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.arrayByteLength = arrayByteLength;\r\nexports.arraysToBytes = arraysToBytes;\r\nexports.assert = assert;\r\nexports.bytesToString = bytesToString;\r\nexports.createPromiseCapability = createPromiseCapability;\r\nexports.createValidAbsoluteUrl = createValidAbsoluteUrl;\r\nexports.encodeToXmlString = encodeToXmlString;\r\nexports.escapeString = escapeString;\r\nexports.getModificationDate = getModificationDate;\r\nexports.getVerbosityLevel = getVerbosityLevel;\r\nexports.info = info;\r\nexports.isArrayBuffer = isArrayBuffer;\r\nexports.isArrayEqual = isArrayEqual;\r\nexports.isAscii = isAscii;\r\nexports.isBool = isBool;\r\nexports.isNum = isNum;\r\nexports.isSameOrigin = isSameOrigin;\r\nexports.isString = isString;\r\nexports.objectFromEntries = objectFromEntries;\r\nexports.objectSize = objectSize;\r\nexports.removeNullCharacters = removeNullCharacters;\r\nexports.setVerbosityLevel = setVerbosityLevel;\r\nexports.shadow = shadow;\r\nexports.string32 = string32;\r\nexports.stringToBytes = stringToBytes;\r\nexports.stringToPDFString = stringToPDFString;\r\nexports.stringToUTF16BEString = stringToUTF16BEString;\r\nexports.stringToUTF8String = stringToUTF8String;\r\nexports.unreachable = unreachable;\r\nexports.utf8StringToString = utf8StringToString;\r\nexports.warn = warn;\r\nexports.VerbosityLevel = exports.Util = exports.UNSUPPORTED_FEATURES = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.createObjectURL = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;\r\n\r\n__w_pdfjs_require__(3);\r\n\r\nconst IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\r\nexports.IDENTITY_MATRIX = IDENTITY_MATRIX;\r\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\r\nexports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\r\nconst PermissionFlag = {\r\n  PRINT: 0x04,\r\n  MODIFY_CONTENTS: 0x08,\r\n  COPY: 0x10,\r\n  MODIFY_ANNOTATIONS: 0x20,\r\n  FILL_INTERACTIVE_FORMS: 0x100,\r\n  COPY_FOR_ACCESSIBILITY: 0x200,\r\n  ASSEMBLE: 0x400,\r\n  PRINT_HIGH_QUALITY: 0x800\r\n};\r\nexports.PermissionFlag = PermissionFlag;\r\nconst TextRenderingMode = {\r\n  FILL: 0,\r\n  STROKE: 1,\r\n  FILL_STROKE: 2,\r\n  INVISIBLE: 3,\r\n  FILL_ADD_TO_PATH: 4,\r\n  STROKE_ADD_TO_PATH: 5,\r\n  FILL_STROKE_ADD_TO_PATH: 6,\r\n  ADD_TO_PATH: 7,\r\n  FILL_STROKE_MASK: 3,\r\n  ADD_TO_PATH_FLAG: 4\r\n};\r\nexports.TextRenderingMode = TextRenderingMode;\r\nconst ImageKind = {\r\n  GRAYSCALE_1BPP: 1,\r\n  RGB_24BPP: 2,\r\n  RGBA_32BPP: 3\r\n};\r\nexports.ImageKind = ImageKind;\r\nconst AnnotationType = {\r\n  TEXT: 1,\r\n  LINK: 2,\r\n  FREETEXT: 3,\r\n  LINE: 4,\r\n  SQUARE: 5,\r\n  CIRCLE: 6,\r\n  POLYGON: 7,\r\n  POLYLINE: 8,\r\n  HIGHLIGHT: 9,\r\n  UNDERLINE: 10,\r\n  SQUIGGLY: 11,\r\n  STRIKEOUT: 12,\r\n  STAMP: 13,\r\n  CARET: 14,\r\n  INK: 15,\r\n  POPUP: 16,\r\n  FILEATTACHMENT: 17,\r\n  SOUND: 18,\r\n  MOVIE: 19,\r\n  WIDGET: 20,\r\n  SCREEN: 21,\r\n  PRINTERMARK: 22,\r\n  TRAPNET: 23,\r\n  WATERMARK: 24,\r\n  THREED: 25,\r\n  REDACT: 26\r\n};\r\nexports.AnnotationType = AnnotationType;\r\nconst AnnotationStateModelType = {\r\n  MARKED: \"Marked\",\r\n  REVIEW: \"Review\"\r\n};\r\nexports.AnnotationStateModelType = AnnotationStateModelType;\r\nconst AnnotationMarkedState = {\r\n  MARKED: \"Marked\",\r\n  UNMARKED: \"Unmarked\"\r\n};\r\nexports.AnnotationMarkedState = AnnotationMarkedState;\r\nconst AnnotationReviewState = {\r\n  ACCEPTED: \"Accepted\",\r\n  REJECTED: \"Rejected\",\r\n  CANCELLED: \"Cancelled\",\r\n  COMPLETED: \"Completed\",\r\n  NONE: \"None\"\r\n};\r\nexports.AnnotationReviewState = AnnotationReviewState;\r\nconst AnnotationReplyType = {\r\n  GROUP: \"Group\",\r\n  REPLY: \"R\"\r\n};\r\nexports.AnnotationReplyType = AnnotationReplyType;\r\nconst AnnotationFlag = {\r\n  INVISIBLE: 0x01,\r\n  HIDDEN: 0x02,\r\n  PRINT: 0x04,\r\n  NOZOOM: 0x08,\r\n  NOROTATE: 0x10,\r\n  NOVIEW: 0x20,\r\n  READONLY: 0x40,\r\n  LOCKED: 0x80,\r\n  TOGGLENOVIEW: 0x100,\r\n  LOCKEDCONTENTS: 0x200\r\n};\r\nexports.AnnotationFlag = AnnotationFlag;\r\nconst AnnotationFieldFlag = {\r\n  READONLY: 0x0000001,\r\n  REQUIRED: 0x0000002,\r\n  NOEXPORT: 0x0000004,\r\n  MULTILINE: 0x0001000,\r\n  PASSWORD: 0x0002000,\r\n  NOTOGGLETOOFF: 0x0004000,\r\n  RADIO: 0x0008000,\r\n  PUSHBUTTON: 0x0010000,\r\n  COMBO: 0x0020000,\r\n  EDIT: 0x0040000,\r\n  SORT: 0x0080000,\r\n  FILESELECT: 0x0100000,\r\n  MULTISELECT: 0x0200000,\r\n  DONOTSPELLCHECK: 0x0400000,\r\n  DONOTSCROLL: 0x0800000,\r\n  COMB: 0x1000000,\r\n  RICHTEXT: 0x2000000,\r\n  RADIOSINUNISON: 0x2000000,\r\n  COMMITONSELCHANGE: 0x4000000\r\n};\r\nexports.AnnotationFieldFlag = AnnotationFieldFlag;\r\nconst AnnotationBorderStyleType = {\r\n  SOLID: 1,\r\n  DASHED: 2,\r\n  BEVELED: 3,\r\n  INSET: 4,\r\n  UNDERLINE: 5\r\n};\r\nexports.AnnotationBorderStyleType = AnnotationBorderStyleType;\r\nconst AnnotationActionEventType = {\r\n  E: \"Mouse Enter\",\r\n  X: \"Mouse Exit\",\r\n  D: \"Mouse Down\",\r\n  U: \"Mouse Up\",\r\n  Fo: \"Focus\",\r\n  Bl: \"Blur\",\r\n  PO: \"PageOpen\",\r\n  PC: \"PageClose\",\r\n  PV: \"PageVisible\",\r\n  PI: \"PageInvisible\",\r\n  K: \"Keystroke\",\r\n  F: \"Format\",\r\n  V: \"Validate\",\r\n  C: \"Calculate\"\r\n};\r\nexports.AnnotationActionEventType = AnnotationActionEventType;\r\nconst DocumentActionEventType = {\r\n  WC: \"WillClose\",\r\n  WS: \"WillSave\",\r\n  DS: \"DidSave\",\r\n  WP: \"WillPrint\",\r\n  DP: \"DidPrint\"\r\n};\r\nexports.DocumentActionEventType = DocumentActionEventType;\r\nconst PageActionEventType = {\r\n  O: \"PageOpen\",\r\n  C: \"PageClose\"\r\n};\r\nexports.PageActionEventType = PageActionEventType;\r\nconst StreamType = {\r\n  UNKNOWN: \"UNKNOWN\",\r\n  FLATE: \"FLATE\",\r\n  LZW: \"LZW\",\r\n  DCT: \"DCT\",\r\n  JPX: \"JPX\",\r\n  JBIG: \"JBIG\",\r\n  A85: \"A85\",\r\n  AHX: \"AHX\",\r\n  CCF: \"CCF\",\r\n  RLX: \"RLX\"\r\n};\r\nexports.StreamType = StreamType;\r\nconst FontType = {\r\n  UNKNOWN: \"UNKNOWN\",\r\n  TYPE1: \"TYPE1\",\r\n  TYPE1C: \"TYPE1C\",\r\n  CIDFONTTYPE0: \"CIDFONTTYPE0\",\r\n  CIDFONTTYPE0C: \"CIDFONTTYPE0C\",\r\n  TRUETYPE: \"TRUETYPE\",\r\n  CIDFONTTYPE2: \"CIDFONTTYPE2\",\r\n  TYPE3: \"TYPE3\",\r\n  OPENTYPE: \"OPENTYPE\",\r\n  TYPE0: \"TYPE0\",\r\n  MMTYPE1: \"MMTYPE1\"\r\n};\r\nexports.FontType = FontType;\r\nconst VerbosityLevel = {\r\n  ERRORS: 0,\r\n  WARNINGS: 1,\r\n  INFOS: 5\r\n};\r\nexports.VerbosityLevel = VerbosityLevel;\r\nconst CMapCompressionType = {\r\n  NONE: 0,\r\n  BINARY: 1,\r\n  STREAM: 2\r\n};\r\nexports.CMapCompressionType = CMapCompressionType;\r\nconst OPS = {\r\n  dependency: 1,\r\n  setLineWidth: 2,\r\n  setLineCap: 3,\r\n  setLineJoin: 4,\r\n  setMiterLimit: 5,\r\n  setDash: 6,\r\n  setRenderingIntent: 7,\r\n  setFlatness: 8,\r\n  setGState: 9,\r\n  save: 10,\r\n  restore: 11,\r\n  transform: 12,\r\n  moveTo: 13,\r\n  lineTo: 14,\r\n  curveTo: 15,\r\n  curveTo2: 16,\r\n  curveTo3: 17,\r\n  closePath: 18,\r\n  rectangle: 19,\r\n  stroke: 20,\r\n  closeStroke: 21,\r\n  fill: 22,\r\n  eoFill: 23,\r\n  fillStroke: 24,\r\n  eoFillStroke: 25,\r\n  closeFillStroke: 26,\r\n  closeEOFillStroke: 27,\r\n  endPath: 28,\r\n  clip: 29,\r\n  eoClip: 30,\r\n  beginText: 31,\r\n  endText: 32,\r\n  setCharSpacing: 33,\r\n  setWordSpacing: 34,\r\n  setHScale: 35,\r\n  setLeading: 36,\r\n  setFont: 37,\r\n  setTextRenderingMode: 38,\r\n  setTextRise: 39,\r\n  moveText: 40,\r\n  setLeadingMoveText: 41,\r\n  setTextMatrix: 42,\r\n  nextLine: 43,\r\n  showText: 44,\r\n  showSpacedText: 45,\r\n  nextLineShowText: 46,\r\n  nextLineSetSpacingShowText: 47,\r\n  setCharWidth: 48,\r\n  setCharWidthAndBounds: 49,\r\n  setStrokeColorSpace: 50,\r\n  setFillColorSpace: 51,\r\n  setStrokeColor: 52,\r\n  setStrokeColorN: 53,\r\n  setFillColor: 54,\r\n  setFillColorN: 55,\r\n  setStrokeGray: 56,\r\n  setFillGray: 57,\r\n  setStrokeRGBColor: 58,\r\n  setFillRGBColor: 59,\r\n  setStrokeCMYKColor: 60,\r\n  setFillCMYKColor: 61,\r\n  shadingFill: 62,\r\n  beginInlineImage: 63,\r\n  beginImageData: 64,\r\n  endInlineImage: 65,\r\n  paintXObject: 66,\r\n  markPoint: 67,\r\n  markPointProps: 68,\r\n  beginMarkedContent: 69,\r\n  beginMarkedContentProps: 70,\r\n  endMarkedContent: 71,\r\n  beginCompat: 72,\r\n  endCompat: 73,\r\n  paintFormXObjectBegin: 74,\r\n  paintFormXObjectEnd: 75,\r\n  beginGroup: 76,\r\n  endGroup: 77,\r\n  beginAnnotations: 78,\r\n  endAnnotations: 79,\r\n  beginAnnotation: 80,\r\n  endAnnotation: 81,\r\n  paintJpegXObject: 82,\r\n  paintImageMaskXObject: 83,\r\n  paintImageMaskXObjectGroup: 84,\r\n  paintImageXObject: 85,\r\n  paintInlineImageXObject: 86,\r\n  paintInlineImageXObjectGroup: 87,\r\n  paintImageXObjectRepeat: 88,\r\n  paintImageMaskXObjectRepeat: 89,\r\n  paintSolidColorImageMask: 90,\r\n  constructPath: 91\r\n};\r\nexports.OPS = OPS;\r\nconst UNSUPPORTED_FEATURES = {\r\n  unknown: \"unknown\",\r\n  forms: \"forms\",\r\n  javaScript: \"javaScript\",\r\n  smask: \"smask\",\r\n  shadingPattern: \"shadingPattern\",\r\n  font: \"font\",\r\n  errorTilingPattern: \"errorTilingPattern\",\r\n  errorExtGState: \"errorExtGState\",\r\n  errorXObject: \"errorXObject\",\r\n  errorFontLoadType3: \"errorFontLoadType3\",\r\n  errorFontState: \"errorFontState\",\r\n  errorFontMissing: \"errorFontMissing\",\r\n  errorFontTranslate: \"errorFontTranslate\",\r\n  errorColorSpace: \"errorColorSpace\",\r\n  errorOperatorList: \"errorOperatorList\",\r\n  errorFontToUnicode: \"errorFontToUnicode\",\r\n  errorFontLoadNative: \"errorFontLoadNative\",\r\n  errorFontGetPath: \"errorFontGetPath\",\r\n  errorMarkedContent: \"errorMarkedContent\"\r\n};\r\nexports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\r\nconst PasswordResponses = {\r\n  NEED_PASSWORD: 1,\r\n  INCORRECT_PASSWORD: 2\r\n};\r\nexports.PasswordResponses = PasswordResponses;\r\nlet verbosity = VerbosityLevel.WARNINGS;\r\n\r\nfunction setVerbosityLevel(level) {\r\n  if (Number.isInteger(level)) {\r\n    verbosity = level;\r\n  }\r\n}\r\n\r\nfunction getVerbosityLevel() {\r\n  return verbosity;\r\n}\r\n\r\nfunction info(msg) {\r\n  if (verbosity >= VerbosityLevel.INFOS) {\r\n    console.log(`Info: ${msg}`);\r\n  }\r\n}\r\n\r\nfunction warn(msg) {\r\n  if (verbosity >= VerbosityLevel.WARNINGS) {\r\n    console.log(`Warning: ${msg}`);\r\n  }\r\n}\r\n\r\nfunction unreachable(msg) {\r\n  throw new Error(msg);\r\n}\r\n\r\nfunction assert(cond, msg) {\r\n  if (!cond) {\r\n    unreachable(msg);\r\n  }\r\n}\r\n\r\nfunction isSameOrigin(baseUrl, otherUrl) {\r\n  let base;\r\n\r\n  try {\r\n    base = new URL(baseUrl);\r\n\r\n    if (!base.origin || base.origin === \"null\") {\r\n      return false;\r\n    }\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n\r\n  const other = new URL(otherUrl, base);\r\n  return base.origin === other.origin;\r\n}\r\n\r\nfunction _isValidProtocol(url) {\r\n  if (!url) {\r\n    return false;\r\n  }\r\n\r\n  switch (url.protocol) {\r\n    case \"http:\":\r\n    case \"https:\":\r\n    case \"ftp:\":\r\n    case \"mailto:\":\r\n    case \"tel:\":\r\n      return true;\r\n\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nfunction createValidAbsoluteUrl(url, baseUrl) {\r\n  if (!url) {\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\r\n\r\n    if (_isValidProtocol(absoluteUrl)) {\r\n      return absoluteUrl;\r\n    }\r\n  } catch (ex) {}\r\n\r\n  return null;\r\n}\r\n\r\nfunction shadow(obj, prop, value) {\r\n  Object.defineProperty(obj, prop, {\r\n    value,\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: false\r\n  });\r\n  return value;\r\n}\r\n\r\nconst BaseException = function BaseExceptionClosure() {\r\n  function BaseException(message) {\r\n    if (this.constructor === BaseException) {\r\n      unreachable(\"Cannot initialize BaseException.\");\r\n    }\r\n\r\n    this.message = message;\r\n    this.name = this.constructor.name;\r\n  }\r\n\r\n  BaseException.prototype = new Error();\r\n  BaseException.constructor = BaseException;\r\n  return BaseException;\r\n}();\r\n\r\nexports.BaseException = BaseException;\r\n\r\nclass PasswordException extends BaseException {\r\n  constructor(msg, code) {\r\n    super(msg);\r\n    this.code = code;\r\n  }\r\n\r\n}\r\n\r\nexports.PasswordException = PasswordException;\r\n\r\nclass UnknownErrorException extends BaseException {\r\n  constructor(msg, details) {\r\n    super(msg);\r\n    this.details = details;\r\n  }\r\n\r\n}\r\n\r\nexports.UnknownErrorException = UnknownErrorException;\r\n\r\nclass InvalidPDFException extends BaseException {}\r\n\r\nexports.InvalidPDFException = InvalidPDFException;\r\n\r\nclass MissingPDFException extends BaseException {}\r\n\r\nexports.MissingPDFException = MissingPDFException;\r\n\r\nclass UnexpectedResponseException extends BaseException {\r\n  constructor(msg, status) {\r\n    super(msg);\r\n    this.status = status;\r\n  }\r\n\r\n}\r\n\r\nexports.UnexpectedResponseException = UnexpectedResponseException;\r\n\r\nclass FormatError extends BaseException {}\r\n\r\nexports.FormatError = FormatError;\r\n\r\nclass AbortException extends BaseException {}\r\n\r\nexports.AbortException = AbortException;\r\nconst NullCharactersRegExp = /\\x00/g;\r\n\r\nfunction removeNullCharacters(str) {\r\n  if (typeof str !== \"string\") {\r\n    warn(\"The argument for removeNullCharacters must be a string.\");\r\n    return str;\r\n  }\r\n\r\n  return str.replace(NullCharactersRegExp, \"\");\r\n}\r\n\r\nfunction bytesToString(bytes) {\r\n  assert(bytes !== null && typeof bytes === \"object\" && bytes.length !== undefined, \"Invalid argument for bytesToString\");\r\n  const length = bytes.length;\r\n  const MAX_ARGUMENT_COUNT = 8192;\r\n\r\n  if (length < MAX_ARGUMENT_COUNT) {\r\n    return String.fromCharCode.apply(null, bytes);\r\n  }\r\n\r\n  const strBuf = [];\r\n\r\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\r\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\r\n    const chunk = bytes.subarray(i, chunkEnd);\r\n    strBuf.push(String.fromCharCode.apply(null, chunk));\r\n  }\r\n\r\n  return strBuf.join(\"\");\r\n}\r\n\r\nfunction stringToBytes(str) {\r\n  assert(typeof str === \"string\", \"Invalid argument for stringToBytes\");\r\n  const length = str.length;\r\n  const bytes = new Uint8Array(length);\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    bytes[i] = str.charCodeAt(i) & 0xff;\r\n  }\r\n\r\n  return bytes;\r\n}\r\n\r\nfunction arrayByteLength(arr) {\r\n  if (arr.length !== undefined) {\r\n    return arr.length;\r\n  }\r\n\r\n  assert(arr.byteLength !== undefined, \"arrayByteLength - invalid argument.\");\r\n  return arr.byteLength;\r\n}\r\n\r\nfunction arraysToBytes(arr) {\r\n  const length = arr.length;\r\n\r\n  if (length === 1 && arr[0] instanceof Uint8Array) {\r\n    return arr[0];\r\n  }\r\n\r\n  let resultLength = 0;\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    resultLength += arrayByteLength(arr[i]);\r\n  }\r\n\r\n  let pos = 0;\r\n  const data = new Uint8Array(resultLength);\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    let item = arr[i];\r\n\r\n    if (!(item instanceof Uint8Array)) {\r\n      if (typeof item === \"string\") {\r\n        item = stringToBytes(item);\r\n      } else {\r\n        item = new Uint8Array(item);\r\n      }\r\n    }\r\n\r\n    const itemLength = item.byteLength;\r\n    data.set(item, pos);\r\n    pos += itemLength;\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\nfunction string32(value) {\r\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\r\n}\r\n\r\nfunction objectSize(obj) {\r\n  return Object.keys(obj).length;\r\n}\r\n\r\nfunction objectFromEntries(iterable) {\r\n  return Object.assign(Object.create(null), Object.fromEntries(iterable));\r\n}\r\n\r\nfunction isLittleEndian() {\r\n  const buffer8 = new Uint8Array(4);\r\n  buffer8[0] = 1;\r\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\r\n  return view32[0] === 1;\r\n}\r\n\r\nconst IsLittleEndianCached = {\r\n  get value() {\r\n    return shadow(this, \"value\", isLittleEndian());\r\n  }\r\n\r\n};\r\nexports.IsLittleEndianCached = IsLittleEndianCached;\r\n\r\nfunction isEvalSupported() {\r\n  try {\r\n    new Function(\"\");\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\n\r\nconst IsEvalSupportedCached = {\r\n  get value() {\r\n    return shadow(this, \"value\", isEvalSupported());\r\n  }\r\n\r\n};\r\nexports.IsEvalSupportedCached = IsEvalSupportedCached;\r\nconst hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, \"0\"));\r\n\r\nclass Util {\r\n  static makeHexColor(r, g, b) {\r\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\r\n  }\r\n\r\n  static transform(m1, m2) {\r\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\r\n  }\r\n\r\n  static applyTransform(p, m) {\r\n    const xt = p[0] * m[0] + p[1] * m[2] + m[4];\r\n    const yt = p[0] * m[1] + p[1] * m[3] + m[5];\r\n    return [xt, yt];\r\n  }\r\n\r\n  static applyInverseTransform(p, m) {\r\n    const d = m[0] * m[3] - m[1] * m[2];\r\n    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\r\n    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\r\n    return [xt, yt];\r\n  }\r\n\r\n  static getAxialAlignedBoundingBox(r, m) {\r\n    const p1 = Util.applyTransform(r, m);\r\n    const p2 = Util.applyTransform(r.slice(2, 4), m);\r\n    const p3 = Util.applyTransform([r[0], r[3]], m);\r\n    const p4 = Util.applyTransform([r[2], r[1]], m);\r\n    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\r\n  }\r\n\r\n  static inverseTransform(m) {\r\n    const d = m[0] * m[3] - m[1] * m[2];\r\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\r\n  }\r\n\r\n  static apply3dTransform(m, v) {\r\n    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\r\n  }\r\n\r\n  static singularValueDecompose2dScale(m) {\r\n    const transpose = [m[0], m[2], m[1], m[3]];\r\n    const a = m[0] * transpose[0] + m[1] * transpose[2];\r\n    const b = m[0] * transpose[1] + m[1] * transpose[3];\r\n    const c = m[2] * transpose[0] + m[3] * transpose[2];\r\n    const d = m[2] * transpose[1] + m[3] * transpose[3];\r\n    const first = (a + d) / 2;\r\n    const second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;\r\n    const sx = first + second || 1;\r\n    const sy = first - second || 1;\r\n    return [Math.sqrt(sx), Math.sqrt(sy)];\r\n  }\r\n\r\n  static normalizeRect(rect) {\r\n    const r = rect.slice(0);\r\n\r\n    if (rect[0] > rect[2]) {\r\n      r[0] = rect[2];\r\n      r[2] = rect[0];\r\n    }\r\n\r\n    if (rect[1] > rect[3]) {\r\n      r[1] = rect[3];\r\n      r[3] = rect[1];\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n  static intersect(rect1, rect2) {\r\n    function compare(a, b) {\r\n      return a - b;\r\n    }\r\n\r\n    const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);\r\n    const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);\r\n    const result = [];\r\n    rect1 = Util.normalizeRect(rect1);\r\n    rect2 = Util.normalizeRect(rect2);\r\n\r\n    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {\r\n      result[0] = orderedX[1];\r\n      result[2] = orderedX[2];\r\n    } else {\r\n      return null;\r\n    }\r\n\r\n    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {\r\n      result[1] = orderedY[1];\r\n      result[3] = orderedY[2];\r\n    } else {\r\n      return null;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n}\r\n\r\nexports.Util = Util;\r\nconst PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];\r\n\r\nfunction stringToPDFString(str) {\r\n  const length = str.length,\r\n        strBuf = [];\r\n\r\n  if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\r\n    for (let i = 2; i < length; i += 2) {\r\n      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));\r\n    }\r\n  } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\r\n    for (let i = 2; i < length; i += 2) {\r\n      strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));\r\n    }\r\n  } else {\r\n    for (let i = 0; i < length; ++i) {\r\n      const code = PDFStringTranslateTable[str.charCodeAt(i)];\r\n      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\r\n    }\r\n  }\r\n\r\n  return strBuf.join(\"\");\r\n}\r\n\r\nfunction escapeString(str) {\r\n  return str.replace(/([()\\\\\\n\\r])/g, match => {\r\n    if (match === \"\\n\") {\r\n      return \"\\\\n\";\r\n    } else if (match === \"\\r\") {\r\n      return \"\\\\r\";\r\n    }\r\n\r\n    return `\\\\${match}`;\r\n  });\r\n}\r\n\r\nfunction isAscii(str) {\r\n  return /^[\\x00-\\x7F]*$/.test(str);\r\n}\r\n\r\nfunction stringToUTF16BEString(str) {\r\n  const buf = [\"\\xFE\\xFF\"];\r\n\r\n  for (let i = 0, ii = str.length; i < ii; i++) {\r\n    const char = str.charCodeAt(i);\r\n    buf.push(String.fromCharCode(char >> 8 & 0xff));\r\n    buf.push(String.fromCharCode(char & 0xff));\r\n  }\r\n\r\n  return buf.join(\"\");\r\n}\r\n\r\nfunction stringToUTF8String(str) {\r\n  return decodeURIComponent(escape(str));\r\n}\r\n\r\nfunction utf8StringToString(str) {\r\n  return unescape(encodeURIComponent(str));\r\n}\r\n\r\nfunction isBool(v) {\r\n  return typeof v === \"boolean\";\r\n}\r\n\r\nfunction isNum(v) {\r\n  return typeof v === \"number\";\r\n}\r\n\r\nfunction isString(v) {\r\n  return typeof v === \"string\";\r\n}\r\n\r\nfunction isArrayBuffer(v) {\r\n  return typeof v === \"object\" && v !== null && v.byteLength !== undefined;\r\n}\r\n\r\nfunction isArrayEqual(arr1, arr2) {\r\n  if (arr1.length !== arr2.length) {\r\n    return false;\r\n  }\r\n\r\n  return arr1.every(function (element, index) {\r\n    return element === arr2[index];\r\n  });\r\n}\r\n\r\nfunction getModificationDate(date = new Date()) {\r\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\r\n  return buffer.join(\"\");\r\n}\r\n\r\nfunction createPromiseCapability() {\r\n  const capability = Object.create(null);\r\n  let isSettled = false;\r\n  Object.defineProperty(capability, \"settled\", {\r\n    get() {\r\n      return isSettled;\r\n    }\r\n\r\n  });\r\n  capability.promise = new Promise(function (resolve, reject) {\r\n    capability.resolve = function (data) {\r\n      isSettled = true;\r\n      resolve(data);\r\n    };\r\n\r\n    capability.reject = function (reason) {\r\n      isSettled = true;\r\n      reject(reason);\r\n    };\r\n  });\r\n  return capability;\r\n}\r\n\r\nconst createObjectURL = function createObjectURLClosure() {\r\n  const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n  return function createObjectURL(data, contentType, forceDataSchema = false) {\r\n    if (!forceDataSchema && URL.createObjectURL) {\r\n      const blob = new Blob([data], {\r\n        type: contentType\r\n      });\r\n      return URL.createObjectURL(blob);\r\n    }\r\n\r\n    let buffer = `data:${contentType};base64,`;\r\n\r\n    for (let i = 0, ii = data.length; i < ii; i += 3) {\r\n      const b1 = data[i] & 0xff;\r\n      const b2 = data[i + 1] & 0xff;\r\n      const b3 = data[i + 2] & 0xff;\r\n      const d1 = b1 >> 2,\r\n            d2 = (b1 & 3) << 4 | b2 >> 4;\r\n      const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\r\n      const d4 = i + 2 < ii ? b3 & 0x3f : 64;\r\n      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\r\n    }\r\n\r\n    return buffer;\r\n  };\r\n}();\r\n\r\nexports.createObjectURL = createObjectURL;\r\nconst XMLEntities = {\r\n  0x3c: \"&lt;\",\r\n  0x3e: \"&gt;\",\r\n  0x26: \"&amp;\",\r\n  0x22: \"&quot;\",\r\n  0x27: \"&apos;\"\r\n};\r\n\r\nfunction encodeToXmlString(str) {\r\n  const buffer = [];\r\n  let start = 0;\r\n\r\n  for (let i = 0, ii = str.length; i < ii; i++) {\r\n    const char = str.codePointAt(i);\r\n\r\n    if (0x20 <= char && char <= 0x7e) {\r\n      const entity = XMLEntities[char];\r\n\r\n      if (entity) {\r\n        if (start < i) {\r\n          buffer.push(str.substring(start, i));\r\n        }\r\n\r\n        buffer.push(entity);\r\n        start = i + 1;\r\n      }\r\n    } else {\r\n      if (start < i) {\r\n        buffer.push(str.substring(start, i));\r\n      }\r\n\r\n      buffer.push(`&#x${char.toString(16).toUpperCase()};`);\r\n\r\n      if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {\r\n        i++;\r\n      }\r\n\r\n      start = i + 1;\r\n    }\r\n  }\r\n\r\n  if (buffer.length === 0) {\r\n    return str;\r\n  }\r\n\r\n  if (start < str.length) {\r\n    buffer.push(str.substring(start, str.length));\r\n  }\r\n\r\n  return buffer.join(\"\");\r\n}\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nvar _is_node = __w_pdfjs_require__(4);\r\n\r\n;\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ ((__unused_webpack_module, exports) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.isNodeJS = void 0;\r\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\r\nexports.isNodeJS = isNodeJS;\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.getDocument = getDocument;\r\nexports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;\r\nexports.version = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultCMapReaderFactory = exports.DefaultCanvasFactory = exports.build = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nvar _display_utils = __w_pdfjs_require__(1);\r\n\r\nvar _font_loader = __w_pdfjs_require__(6);\r\n\r\nvar _node_utils = __w_pdfjs_require__(7);\r\n\r\nvar _annotation_storage = __w_pdfjs_require__(8);\r\n\r\nvar _api_compatibility = __w_pdfjs_require__(9);\r\n\r\nvar _canvas = __w_pdfjs_require__(10);\r\n\r\nvar _worker_options = __w_pdfjs_require__(12);\r\n\r\nvar _is_node = __w_pdfjs_require__(4);\r\n\r\nvar _message_handler = __w_pdfjs_require__(13);\r\n\r\nvar _metadata = __w_pdfjs_require__(14);\r\n\r\nvar _optional_content_config = __w_pdfjs_require__(16);\r\n\r\nvar _transport_stream = __w_pdfjs_require__(17);\r\n\r\nvar _webgl = __w_pdfjs_require__(18);\r\n\r\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\r\nconst RENDERING_CANCELLED_TIMEOUT = 100;\r\nconst DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\r\nexports.DefaultCanvasFactory = DefaultCanvasFactory;\r\nconst DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\r\nexports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\r\nlet createPDFNetworkStream;\r\n\r\nfunction setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\r\n  createPDFNetworkStream = pdfNetworkStreamFactory;\r\n}\r\n\r\nfunction getDocument(src) {\r\n  const task = new PDFDocumentLoadingTask();\r\n  let source;\r\n\r\n  if (typeof src === \"string\") {\r\n    source = {\r\n      url: src\r\n    };\r\n  } else if ((0, _util.isArrayBuffer)(src)) {\r\n    source = {\r\n      data: src\r\n    };\r\n  } else if (src instanceof PDFDataRangeTransport) {\r\n    source = {\r\n      range: src\r\n    };\r\n  } else {\r\n    if (typeof src !== \"object\") {\r\n      throw new Error(\"Invalid parameter in getDocument, \" + \"need either Uint8Array, string or a parameter object\");\r\n    }\r\n\r\n    if (!src.url && !src.data && !src.range) {\r\n      throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\r\n    }\r\n\r\n    source = src;\r\n  }\r\n\r\n  const params = Object.create(null);\r\n  let rangeTransport = null,\r\n      worker = null;\r\n\r\n  for (const key in source) {\r\n    if (key === \"url\" && typeof window !== \"undefined\") {\r\n      params[key] = new URL(source[key], window.location).href;\r\n      continue;\r\n    } else if (key === \"range\") {\r\n      rangeTransport = source[key];\r\n      continue;\r\n    } else if (key === \"worker\") {\r\n      worker = source[key];\r\n      continue;\r\n    } else if (key === \"data\" && !(source[key] instanceof Uint8Array)) {\r\n      const pdfBytes = source[key];\r\n\r\n      if (typeof pdfBytes === \"string\") {\r\n        params[key] = (0, _util.stringToBytes)(pdfBytes);\r\n      } else if (typeof pdfBytes === \"object\" && pdfBytes !== null && !isNaN(pdfBytes.length)) {\r\n        params[key] = new Uint8Array(pdfBytes);\r\n      } else if ((0, _util.isArrayBuffer)(pdfBytes)) {\r\n        params[key] = new Uint8Array(pdfBytes);\r\n      } else {\r\n        throw new Error(\"Invalid PDF binary data: either typed array, \" + \"string or array-like object is expected in the \" + \"data property.\");\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    params[key] = source[key];\r\n  }\r\n\r\n  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;\r\n  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;\r\n  params.ignoreErrors = params.stopAtErrors !== true;\r\n  params.fontExtraProperties = params.fontExtraProperties === true;\r\n  params.pdfBug = params.pdfBug === true;\r\n\r\n  if (!Number.isInteger(params.maxImageSize)) {\r\n    params.maxImageSize = -1;\r\n  }\r\n\r\n  if (typeof params.isEvalSupported !== \"boolean\") {\r\n    params.isEvalSupported = true;\r\n  }\r\n\r\n  if (typeof params.disableFontFace !== \"boolean\") {\r\n    params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;\r\n  }\r\n\r\n  if (typeof params.ownerDocument === \"undefined\") {\r\n    params.ownerDocument = globalThis.document;\r\n  }\r\n\r\n  if (typeof params.disableRange !== \"boolean\") {\r\n    params.disableRange = false;\r\n  }\r\n\r\n  if (typeof params.disableStream !== \"boolean\") {\r\n    params.disableStream = false;\r\n  }\r\n\r\n  if (typeof params.disableAutoFetch !== \"boolean\") {\r\n    params.disableAutoFetch = false;\r\n  }\r\n\r\n  (0, _util.setVerbosityLevel)(params.verbosity);\r\n\r\n  if (!worker) {\r\n    const workerParams = {\r\n      verbosity: params.verbosity,\r\n      port: _worker_options.GlobalWorkerOptions.workerPort\r\n    };\r\n    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\r\n    task._worker = worker;\r\n  }\r\n\r\n  const docId = task.docId;\r\n  worker.promise.then(function () {\r\n    if (task.destroyed) {\r\n      throw new Error(\"Loading aborted\");\r\n    }\r\n\r\n    const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);\r\n\r\n    const networkStreamPromise = new Promise(function (resolve) {\r\n      let networkStream;\r\n\r\n      if (rangeTransport) {\r\n        networkStream = new _transport_stream.PDFDataTransportStream({\r\n          length: params.length,\r\n          initialData: params.initialData,\r\n          progressiveDone: params.progressiveDone,\r\n          disableRange: params.disableRange,\r\n          disableStream: params.disableStream\r\n        }, rangeTransport);\r\n      } else if (!params.data) {\r\n        networkStream = createPDFNetworkStream({\r\n          url: params.url,\r\n          length: params.length,\r\n          httpHeaders: params.httpHeaders,\r\n          withCredentials: params.withCredentials,\r\n          rangeChunkSize: params.rangeChunkSize,\r\n          disableRange: params.disableRange,\r\n          disableStream: params.disableStream\r\n        });\r\n      }\r\n\r\n      resolve(networkStream);\r\n    });\r\n    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {\r\n      if (task.destroyed) {\r\n        throw new Error(\"Loading aborted\");\r\n      }\r\n\r\n      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\r\n      messageHandler.postMessageTransfers = worker.postMessageTransfers;\r\n      const transport = new WorkerTransport(messageHandler, task, networkStream, params);\r\n      task._transport = transport;\r\n      messageHandler.send(\"Ready\", null);\r\n    });\r\n  }).catch(task._capability.reject);\r\n  return task;\r\n}\r\n\r\nfunction _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\r\n  if (worker.destroyed) {\r\n    return Promise.reject(new Error(\"Worker was destroyed\"));\r\n  }\r\n\r\n  if (pdfDataRangeTransport) {\r\n    source.length = pdfDataRangeTransport.length;\r\n    source.initialData = pdfDataRangeTransport.initialData;\r\n    source.progressiveDone = pdfDataRangeTransport.progressiveDone;\r\n  }\r\n\r\n  return worker.messageHandler.sendWithPromise(\"GetDocRequest\", {\r\n    docId,\r\n    apiVersion: '2.7.570',\r\n    source: {\r\n      data: source.data,\r\n      url: source.url,\r\n      password: source.password,\r\n      disableAutoFetch: source.disableAutoFetch,\r\n      rangeChunkSize: source.rangeChunkSize,\r\n      length: source.length\r\n    },\r\n    maxImageSize: source.maxImageSize,\r\n    disableFontFace: source.disableFontFace,\r\n    postMessageTransfers: worker.postMessageTransfers,\r\n    docBaseUrl: source.docBaseUrl,\r\n    ignoreErrors: source.ignoreErrors,\r\n    isEvalSupported: source.isEvalSupported,\r\n    fontExtraProperties: source.fontExtraProperties\r\n  }).then(function (workerId) {\r\n    if (worker.destroyed) {\r\n      throw new Error(\"Worker was destroyed\");\r\n    }\r\n\r\n    return workerId;\r\n  });\r\n}\r\n\r\nconst PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {\r\n  let nextDocumentId = 0;\r\n\r\n  class PDFDocumentLoadingTask {\r\n    constructor() {\r\n      this._capability = (0, _util.createPromiseCapability)();\r\n      this._transport = null;\r\n      this._worker = null;\r\n      this.docId = \"d\" + nextDocumentId++;\r\n      this.destroyed = false;\r\n      this.onPassword = null;\r\n      this.onProgress = null;\r\n      this.onUnsupportedFeature = null;\r\n    }\r\n\r\n    get promise() {\r\n      return this._capability.promise;\r\n    }\r\n\r\n    destroy() {\r\n      this.destroyed = true;\r\n      const transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();\r\n      return transportDestroyed.then(() => {\r\n        this._transport = null;\r\n\r\n        if (this._worker) {\r\n          this._worker.destroy();\r\n\r\n          this._worker = null;\r\n        }\r\n      });\r\n    }\r\n\r\n  }\r\n\r\n  return PDFDocumentLoadingTask;\r\n}();\r\n\r\nclass PDFDataRangeTransport {\r\n  constructor(length, initialData, progressiveDone = false) {\r\n    this.length = length;\r\n    this.initialData = initialData;\r\n    this.progressiveDone = progressiveDone;\r\n    this._rangeListeners = [];\r\n    this._progressListeners = [];\r\n    this._progressiveReadListeners = [];\r\n    this._progressiveDoneListeners = [];\r\n    this._readyCapability = (0, _util.createPromiseCapability)();\r\n  }\r\n\r\n  addRangeListener(listener) {\r\n    this._rangeListeners.push(listener);\r\n  }\r\n\r\n  addProgressListener(listener) {\r\n    this._progressListeners.push(listener);\r\n  }\r\n\r\n  addProgressiveReadListener(listener) {\r\n    this._progressiveReadListeners.push(listener);\r\n  }\r\n\r\n  addProgressiveDoneListener(listener) {\r\n    this._progressiveDoneListeners.push(listener);\r\n  }\r\n\r\n  onDataRange(begin, chunk) {\r\n    for (const listener of this._rangeListeners) {\r\n      listener(begin, chunk);\r\n    }\r\n  }\r\n\r\n  onDataProgress(loaded, total) {\r\n    this._readyCapability.promise.then(() => {\r\n      for (const listener of this._progressListeners) {\r\n        listener(loaded, total);\r\n      }\r\n    });\r\n  }\r\n\r\n  onDataProgressiveRead(chunk) {\r\n    this._readyCapability.promise.then(() => {\r\n      for (const listener of this._progressiveReadListeners) {\r\n        listener(chunk);\r\n      }\r\n    });\r\n  }\r\n\r\n  onDataProgressiveDone() {\r\n    this._readyCapability.promise.then(() => {\r\n      for (const listener of this._progressiveDoneListeners) {\r\n        listener();\r\n      }\r\n    });\r\n  }\r\n\r\n  transportReady() {\r\n    this._readyCapability.resolve();\r\n  }\r\n\r\n  requestDataRange(begin, end) {\r\n    (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\r\n  }\r\n\r\n  abort() {}\r\n\r\n}\r\n\r\nexports.PDFDataRangeTransport = PDFDataRangeTransport;\r\n\r\nclass PDFDocumentProxy {\r\n  constructor(pdfInfo, transport) {\r\n    this._pdfInfo = pdfInfo;\r\n    this._transport = transport;\r\n  }\r\n\r\n  get annotationStorage() {\r\n    return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\r\n  }\r\n\r\n  get numPages() {\r\n    return this._pdfInfo.numPages;\r\n  }\r\n\r\n  get fingerprint() {\r\n    return this._pdfInfo.fingerprint;\r\n  }\r\n\r\n  getPage(pageNumber) {\r\n    return this._transport.getPage(pageNumber);\r\n  }\r\n\r\n  getPageIndex(ref) {\r\n    return this._transport.getPageIndex(ref);\r\n  }\r\n\r\n  getDestinations() {\r\n    return this._transport.getDestinations();\r\n  }\r\n\r\n  getDestination(id) {\r\n    return this._transport.getDestination(id);\r\n  }\r\n\r\n  getPageLabels() {\r\n    return this._transport.getPageLabels();\r\n  }\r\n\r\n  getPageLayout() {\r\n    return this._transport.getPageLayout();\r\n  }\r\n\r\n  getPageMode() {\r\n    return this._transport.getPageMode();\r\n  }\r\n\r\n  getViewerPreferences() {\r\n    return this._transport.getViewerPreferences();\r\n  }\r\n\r\n  getOpenAction() {\r\n    return this._transport.getOpenAction();\r\n  }\r\n\r\n  getAttachments() {\r\n    return this._transport.getAttachments();\r\n  }\r\n\r\n  getJavaScript() {\r\n    return this._transport.getJavaScript();\r\n  }\r\n\r\n  getJSActions() {\r\n    return this._transport.getDocJSActions();\r\n  }\r\n\r\n  getOutline() {\r\n    return this._transport.getOutline();\r\n  }\r\n\r\n  getOptionalContentConfig() {\r\n    return this._transport.getOptionalContentConfig();\r\n  }\r\n\r\n  getPermissions() {\r\n    return this._transport.getPermissions();\r\n  }\r\n\r\n  getMetadata() {\r\n    return this._transport.getMetadata();\r\n  }\r\n\r\n  getMarkInfo() {\r\n    return this._transport.getMarkInfo();\r\n  }\r\n\r\n  getData() {\r\n    return this._transport.getData();\r\n  }\r\n\r\n  getDownloadInfo() {\r\n    return this._transport.downloadInfoCapability.promise;\r\n  }\r\n\r\n  getStats() {\r\n    return this._transport.getStats();\r\n  }\r\n\r\n  cleanup() {\r\n    return this._transport.startCleanup();\r\n  }\r\n\r\n  destroy() {\r\n    return this.loadingTask.destroy();\r\n  }\r\n\r\n  get loadingParams() {\r\n    return this._transport.loadingParams;\r\n  }\r\n\r\n  get loadingTask() {\r\n    return this._transport.loadingTask;\r\n  }\r\n\r\n  saveDocument(annotationStorage) {\r\n    return this._transport.saveDocument(annotationStorage);\r\n  }\r\n\r\n  getFieldObjects() {\r\n    return this._transport.getFieldObjects();\r\n  }\r\n\r\n  hasJSActions() {\r\n    return this._transport.hasJSActions();\r\n  }\r\n\r\n  getCalculationOrderIds() {\r\n    return this._transport.getCalculationOrderIds();\r\n  }\r\n\r\n}\r\n\r\nexports.PDFDocumentProxy = PDFDocumentProxy;\r\n\r\nclass PDFPageProxy {\r\n  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {\r\n    this._pageIndex = pageIndex;\r\n    this._pageInfo = pageInfo;\r\n    this._ownerDocument = ownerDocument;\r\n    this._transport = transport;\r\n    this._stats = pdfBug ? new _display_utils.StatTimer() : null;\r\n    this._pdfBug = pdfBug;\r\n    this.commonObjs = transport.commonObjs;\r\n    this.objs = new PDFObjects();\r\n    this.cleanupAfterRender = false;\r\n    this.pendingCleanup = false;\r\n    this._intentStates = new Map();\r\n    this.destroyed = false;\r\n  }\r\n\r\n  get pageNumber() {\r\n    return this._pageIndex + 1;\r\n  }\r\n\r\n  get rotate() {\r\n    return this._pageInfo.rotate;\r\n  }\r\n\r\n  get ref() {\r\n    return this._pageInfo.ref;\r\n  }\r\n\r\n  get userUnit() {\r\n    return this._pageInfo.userUnit;\r\n  }\r\n\r\n  get view() {\r\n    return this._pageInfo.view;\r\n  }\r\n\r\n  getViewport({\r\n    scale,\r\n    rotation = this.rotate,\r\n    offsetX = 0,\r\n    offsetY = 0,\r\n    dontFlip = false\r\n  } = {}) {\r\n    return new _display_utils.PageViewport({\r\n      viewBox: this.view,\r\n      scale,\r\n      rotation,\r\n      offsetX,\r\n      offsetY,\r\n      dontFlip\r\n    });\r\n  }\r\n\r\n  getAnnotations({\r\n    intent = null\r\n  } = {}) {\r\n    if (!this.annotationsPromise || this.annotationsIntent !== intent) {\r\n      this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);\r\n      this.annotationsIntent = intent;\r\n    }\r\n\r\n    return this.annotationsPromise;\r\n  }\r\n\r\n  getJSActions() {\r\n    return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));\r\n  }\r\n\r\n  render({\r\n    canvasContext,\r\n    viewport,\r\n    intent = \"display\",\r\n    enableWebGL = false,\r\n    renderInteractiveForms = false,\r\n    transform = null,\r\n    imageLayer = null,\r\n    canvasFactory = null,\r\n    background = null,\r\n    annotationStorage = null,\r\n    optionalContentConfigPromise = null\r\n  }) {\r\n    if (this._stats) {\r\n      this._stats.time(\"Overall\");\r\n    }\r\n\r\n    const renderingIntent = intent === \"print\" ? \"print\" : \"display\";\r\n    this.pendingCleanup = false;\r\n\r\n    if (!optionalContentConfigPromise) {\r\n      optionalContentConfigPromise = this._transport.getOptionalContentConfig();\r\n    }\r\n\r\n    let intentState = this._intentStates.get(renderingIntent);\r\n\r\n    if (!intentState) {\r\n      intentState = Object.create(null);\r\n\r\n      this._intentStates.set(renderingIntent, intentState);\r\n    }\r\n\r\n    if (intentState.streamReaderCancelTimeout) {\r\n      clearTimeout(intentState.streamReaderCancelTimeout);\r\n      intentState.streamReaderCancelTimeout = null;\r\n    }\r\n\r\n    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({\r\n      ownerDocument: this._ownerDocument\r\n    });\r\n    const webGLContext = new _webgl.WebGLContext({\r\n      enable: enableWebGL\r\n    });\r\n\r\n    if (!intentState.displayReadyCapability) {\r\n      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\r\n      intentState.operatorList = {\r\n        fnArray: [],\r\n        argsArray: [],\r\n        lastChunk: false\r\n      };\r\n\r\n      if (this._stats) {\r\n        this._stats.time(\"Page Request\");\r\n      }\r\n\r\n      this._pumpOperatorList({\r\n        pageIndex: this._pageIndex,\r\n        intent: renderingIntent,\r\n        renderInteractiveForms: renderInteractiveForms === true,\r\n        annotationStorage: annotationStorage?.getAll() || null\r\n      });\r\n    }\r\n\r\n    const complete = error => {\r\n      const i = intentState.renderTasks.indexOf(internalRenderTask);\r\n\r\n      if (i >= 0) {\r\n        intentState.renderTasks.splice(i, 1);\r\n      }\r\n\r\n      if (this.cleanupAfterRender || renderingIntent === \"print\") {\r\n        this.pendingCleanup = true;\r\n      }\r\n\r\n      this._tryCleanup();\r\n\r\n      if (error) {\r\n        internalRenderTask.capability.reject(error);\r\n\r\n        this._abortOperatorList({\r\n          intentState,\r\n          reason: error\r\n        });\r\n      } else {\r\n        internalRenderTask.capability.resolve();\r\n      }\r\n\r\n      if (this._stats) {\r\n        this._stats.timeEnd(\"Rendering\");\r\n\r\n        this._stats.timeEnd(\"Overall\");\r\n      }\r\n    };\r\n\r\n    const internalRenderTask = new InternalRenderTask({\r\n      callback: complete,\r\n      params: {\r\n        canvasContext,\r\n        viewport,\r\n        transform,\r\n        imageLayer,\r\n        background\r\n      },\r\n      objs: this.objs,\r\n      commonObjs: this.commonObjs,\r\n      operatorList: intentState.operatorList,\r\n      pageIndex: this._pageIndex,\r\n      canvasFactory: canvasFactoryInstance,\r\n      webGLContext,\r\n      useRequestAnimationFrame: renderingIntent !== \"print\",\r\n      pdfBug: this._pdfBug\r\n    });\r\n\r\n    if (!intentState.renderTasks) {\r\n      intentState.renderTasks = [];\r\n    }\r\n\r\n    intentState.renderTasks.push(internalRenderTask);\r\n    const renderTask = internalRenderTask.task;\r\n    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\r\n      if (this.pendingCleanup) {\r\n        complete();\r\n        return;\r\n      }\r\n\r\n      if (this._stats) {\r\n        this._stats.time(\"Rendering\");\r\n      }\r\n\r\n      internalRenderTask.initializeGraphics({\r\n        transparency,\r\n        optionalContentConfig\r\n      });\r\n      internalRenderTask.operatorListChanged();\r\n    }).catch(complete);\r\n    return renderTask;\r\n  }\r\n\r\n  getOperatorList() {\r\n    function operatorListChanged() {\r\n      if (intentState.operatorList.lastChunk) {\r\n        intentState.opListReadCapability.resolve(intentState.operatorList);\r\n        const i = intentState.renderTasks.indexOf(opListTask);\r\n\r\n        if (i >= 0) {\r\n          intentState.renderTasks.splice(i, 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    const renderingIntent = \"oplist\";\r\n\r\n    let intentState = this._intentStates.get(renderingIntent);\r\n\r\n    if (!intentState) {\r\n      intentState = Object.create(null);\r\n\r\n      this._intentStates.set(renderingIntent, intentState);\r\n    }\r\n\r\n    let opListTask;\r\n\r\n    if (!intentState.opListReadCapability) {\r\n      opListTask = Object.create(null);\r\n      opListTask.operatorListChanged = operatorListChanged;\r\n      intentState.opListReadCapability = (0, _util.createPromiseCapability)();\r\n      intentState.renderTasks = [];\r\n      intentState.renderTasks.push(opListTask);\r\n      intentState.operatorList = {\r\n        fnArray: [],\r\n        argsArray: [],\r\n        lastChunk: false\r\n      };\r\n\r\n      if (this._stats) {\r\n        this._stats.time(\"Page Request\");\r\n      }\r\n\r\n      this._pumpOperatorList({\r\n        pageIndex: this._pageIndex,\r\n        intent: renderingIntent\r\n      });\r\n    }\r\n\r\n    return intentState.opListReadCapability.promise;\r\n  }\r\n\r\n  streamTextContent({\r\n    normalizeWhitespace = false,\r\n    disableCombineTextItems = false\r\n  } = {}) {\r\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\r\n    return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\r\n      pageIndex: this._pageIndex,\r\n      normalizeWhitespace: normalizeWhitespace === true,\r\n      combineTextItems: disableCombineTextItems !== true\r\n    }, {\r\n      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\r\n\r\n      size(textContent) {\r\n        return textContent.items.length;\r\n      }\r\n\r\n    });\r\n  }\r\n\r\n  getTextContent(params = {}) {\r\n    const readableStream = this.streamTextContent(params);\r\n    return new Promise(function (resolve, reject) {\r\n      function pump() {\r\n        reader.read().then(function ({\r\n          value,\r\n          done\r\n        }) {\r\n          if (done) {\r\n            resolve(textContent);\r\n            return;\r\n          }\r\n\r\n          Object.assign(textContent.styles, value.styles);\r\n          textContent.items.push(...value.items);\r\n          pump();\r\n        }, reject);\r\n      }\r\n\r\n      const reader = readableStream.getReader();\r\n      const textContent = {\r\n        items: [],\r\n        styles: Object.create(null)\r\n      };\r\n      pump();\r\n    });\r\n  }\r\n\r\n  _destroy() {\r\n    this.destroyed = true;\r\n    this._transport.pageCache[this._pageIndex] = null;\r\n    const waitOn = [];\r\n\r\n    for (const [intent, intentState] of this._intentStates) {\r\n      this._abortOperatorList({\r\n        intentState,\r\n        reason: new Error(\"Page was destroyed.\"),\r\n        force: true\r\n      });\r\n\r\n      if (intent === \"oplist\") {\r\n        continue;\r\n      }\r\n\r\n      for (const internalRenderTask of intentState.renderTasks) {\r\n        waitOn.push(internalRenderTask.completed);\r\n        internalRenderTask.cancel();\r\n      }\r\n    }\r\n\r\n    this.objs.clear();\r\n    this.annotationsPromise = null;\r\n    this._jsActionsPromise = null;\r\n    this.pendingCleanup = false;\r\n    return Promise.all(waitOn);\r\n  }\r\n\r\n  cleanup(resetStats = false) {\r\n    this.pendingCleanup = true;\r\n    return this._tryCleanup(resetStats);\r\n  }\r\n\r\n  _tryCleanup(resetStats = false) {\r\n    if (!this.pendingCleanup) {\r\n      return false;\r\n    }\r\n\r\n    for (const {\r\n      renderTasks,\r\n      operatorList\r\n    } of this._intentStates.values()) {\r\n      if (renderTasks.length !== 0 || !operatorList.lastChunk) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    this._intentStates.clear();\r\n\r\n    this.objs.clear();\r\n    this.annotationsPromise = null;\r\n    this._jsActionsPromise = null;\r\n\r\n    if (resetStats && this._stats) {\r\n      this._stats = new _display_utils.StatTimer();\r\n    }\r\n\r\n    this.pendingCleanup = false;\r\n    return true;\r\n  }\r\n\r\n  _startRenderPage(transparency, intent) {\r\n    const intentState = this._intentStates.get(intent);\r\n\r\n    if (!intentState) {\r\n      return;\r\n    }\r\n\r\n    if (this._stats) {\r\n      this._stats.timeEnd(\"Page Request\");\r\n    }\r\n\r\n    if (intentState.displayReadyCapability) {\r\n      intentState.displayReadyCapability.resolve(transparency);\r\n    }\r\n  }\r\n\r\n  _renderPageChunk(operatorListChunk, intentState) {\r\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\r\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\r\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\r\n    }\r\n\r\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\r\n\r\n    for (let i = 0; i < intentState.renderTasks.length; i++) {\r\n      intentState.renderTasks[i].operatorListChanged();\r\n    }\r\n\r\n    if (operatorListChunk.lastChunk) {\r\n      this._tryCleanup();\r\n    }\r\n  }\r\n\r\n  _pumpOperatorList(args) {\r\n    (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected \"intent\" argument.');\r\n\r\n    const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", args);\r\n\r\n    const reader = readableStream.getReader();\r\n\r\n    const intentState = this._intentStates.get(args.intent);\r\n\r\n    intentState.streamReader = reader;\r\n\r\n    const pump = () => {\r\n      reader.read().then(({\r\n        value,\r\n        done\r\n      }) => {\r\n        if (done) {\r\n          intentState.streamReader = null;\r\n          return;\r\n        }\r\n\r\n        if (this._transport.destroyed) {\r\n          return;\r\n        }\r\n\r\n        this._renderPageChunk(value, intentState);\r\n\r\n        pump();\r\n      }, reason => {\r\n        intentState.streamReader = null;\r\n\r\n        if (this._transport.destroyed) {\r\n          return;\r\n        }\r\n\r\n        if (intentState.operatorList) {\r\n          intentState.operatorList.lastChunk = true;\r\n\r\n          for (let i = 0; i < intentState.renderTasks.length; i++) {\r\n            intentState.renderTasks[i].operatorListChanged();\r\n          }\r\n\r\n          this._tryCleanup();\r\n        }\r\n\r\n        if (intentState.displayReadyCapability) {\r\n          intentState.displayReadyCapability.reject(reason);\r\n        } else if (intentState.opListReadCapability) {\r\n          intentState.opListReadCapability.reject(reason);\r\n        } else {\r\n          throw reason;\r\n        }\r\n      });\r\n    };\r\n\r\n    pump();\r\n  }\r\n\r\n  _abortOperatorList({\r\n    intentState,\r\n    reason,\r\n    force = false\r\n  }) {\r\n    (0, _util.assert)(reason instanceof Error || typeof reason === \"object\" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected \"reason\" argument.');\r\n\r\n    if (!intentState.streamReader) {\r\n      return;\r\n    }\r\n\r\n    if (!force) {\r\n      if (intentState.renderTasks.length !== 0) {\r\n        return;\r\n      }\r\n\r\n      if (reason instanceof _display_utils.RenderingCancelledException) {\r\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\r\n          this._abortOperatorList({\r\n            intentState,\r\n            reason,\r\n            force: true\r\n          });\r\n\r\n          intentState.streamReaderCancelTimeout = null;\r\n        }, RENDERING_CANCELLED_TIMEOUT);\r\n        return;\r\n      }\r\n    }\r\n\r\n    intentState.streamReader.cancel(new _util.AbortException(reason?.message));\r\n    intentState.streamReader = null;\r\n\r\n    if (this._transport.destroyed) {\r\n      return;\r\n    }\r\n\r\n    for (const [intent, curIntentState] of this._intentStates) {\r\n      if (curIntentState === intentState) {\r\n        this._intentStates.delete(intent);\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.cleanup();\r\n  }\r\n\r\n  get stats() {\r\n    return this._stats;\r\n  }\r\n\r\n}\r\n\r\nexports.PDFPageProxy = PDFPageProxy;\r\n\r\nclass LoopbackPort {\r\n  constructor(defer = true) {\r\n    this._listeners = [];\r\n    this._defer = defer;\r\n    this._deferred = Promise.resolve(undefined);\r\n  }\r\n\r\n  postMessage(obj, transfers) {\r\n    function cloneValue(value) {\r\n      if (typeof value !== \"object\" || value === null) {\r\n        return value;\r\n      }\r\n\r\n      if (cloned.has(value)) {\r\n        return cloned.get(value);\r\n      }\r\n\r\n      let buffer, result;\r\n\r\n      if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {\r\n        if (transfers?.includes(buffer)) {\r\n          result = new value.constructor(buffer, value.byteOffset, value.byteLength);\r\n        } else {\r\n          result = new value.constructor(value);\r\n        }\r\n\r\n        cloned.set(value, result);\r\n        return result;\r\n      }\r\n\r\n      result = Array.isArray(value) ? [] : {};\r\n      cloned.set(value, result);\r\n\r\n      for (const i in value) {\r\n        let desc,\r\n            p = value;\r\n\r\n        while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {\r\n          p = Object.getPrototypeOf(p);\r\n        }\r\n\r\n        if (typeof desc.value === \"undefined\") {\r\n          continue;\r\n        }\r\n\r\n        if (typeof desc.value === \"function\") {\r\n          if (value.hasOwnProperty && value.hasOwnProperty(i)) {\r\n            throw new Error(`LoopbackPort.postMessage - cannot clone: ${value[i]}`);\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        result[i] = cloneValue(desc.value);\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    if (!this._defer) {\r\n      this._listeners.forEach(listener => {\r\n        listener.call(this, {\r\n          data: obj\r\n        });\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    const cloned = new WeakMap();\r\n    const e = {\r\n      data: cloneValue(obj)\r\n    };\r\n\r\n    this._deferred.then(() => {\r\n      this._listeners.forEach(listener => {\r\n        listener.call(this, e);\r\n      });\r\n    });\r\n  }\r\n\r\n  addEventListener(name, listener) {\r\n    this._listeners.push(listener);\r\n  }\r\n\r\n  removeEventListener(name, listener) {\r\n    const i = this._listeners.indexOf(listener);\r\n\r\n    this._listeners.splice(i, 1);\r\n  }\r\n\r\n  terminate() {\r\n    this._listeners.length = 0;\r\n  }\r\n\r\n}\r\n\r\nexports.LoopbackPort = LoopbackPort;\r\n\r\nconst PDFWorker = function PDFWorkerClosure() {\r\n  const pdfWorkerPorts = new WeakMap();\r\n  let isWorkerDisabled = false;\r\n  let fallbackWorkerSrc;\r\n  let nextFakeWorkerId = 0;\r\n  let fakeWorkerCapability;\r\n\r\n  if (_is_node.isNodeJS && typeof require === \"function\") {\r\n    isWorkerDisabled = true;\r\n    fallbackWorkerSrc = \"./pdf.worker.js\";\r\n  } else if (typeof document === \"object\" && \"currentScript\" in document) {\r\n    const pdfjsFilePath = document.currentScript?.src;\r\n\r\n    if (pdfjsFilePath) {\r\n      fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\r\n    }\r\n  }\r\n\r\n  function getWorkerSrc() {\r\n    if (_worker_options.GlobalWorkerOptions.workerSrc) {\r\n      return _worker_options.GlobalWorkerOptions.workerSrc;\r\n    }\r\n\r\n    if (typeof fallbackWorkerSrc !== \"undefined\") {\r\n      if (!_is_node.isNodeJS) {\r\n        (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\r\n      }\r\n\r\n      return fallbackWorkerSrc;\r\n    }\r\n\r\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\r\n  }\r\n\r\n  function getMainThreadWorkerMessageHandler() {\r\n    let mainWorkerMessageHandler;\r\n\r\n    try {\r\n      mainWorkerMessageHandler = globalThis.pdfjsWorker?.WorkerMessageHandler;\r\n    } catch (ex) {}\r\n\r\n    return mainWorkerMessageHandler || null;\r\n  }\r\n\r\n  function setupFakeWorkerGlobal() {\r\n    if (fakeWorkerCapability) {\r\n      return fakeWorkerCapability.promise;\r\n    }\r\n\r\n    fakeWorkerCapability = (0, _util.createPromiseCapability)();\r\n\r\n    const loader = async function () {\r\n      const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();\r\n\r\n      if (mainWorkerMessageHandler) {\r\n        return mainWorkerMessageHandler;\r\n      }\r\n\r\n      if (_is_node.isNodeJS && typeof require === \"function\") {\r\n        const worker = eval(\"require\")(getWorkerSrc());\r\n        return worker.WorkerMessageHandler;\r\n      }\r\n\r\n      await (0, _display_utils.loadScript)(getWorkerSrc());\r\n      return window.pdfjsWorker.WorkerMessageHandler;\r\n    };\r\n\r\n    loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);\r\n    return fakeWorkerCapability.promise;\r\n  }\r\n\r\n  function createCDNWrapper(url) {\r\n    const wrapper = \"importScripts('\" + url + \"');\";\r\n    return URL.createObjectURL(new Blob([wrapper]));\r\n  }\r\n\r\n  class PDFWorker {\r\n    constructor({\r\n      name = null,\r\n      port = null,\r\n      verbosity = (0, _util.getVerbosityLevel)()\r\n    } = {}) {\r\n      if (port && pdfWorkerPorts.has(port)) {\r\n        throw new Error(\"Cannot use more than one PDFWorker per port\");\r\n      }\r\n\r\n      this.name = name;\r\n      this.destroyed = false;\r\n      this.postMessageTransfers = true;\r\n      this.verbosity = verbosity;\r\n      this._readyCapability = (0, _util.createPromiseCapability)();\r\n      this._port = null;\r\n      this._webWorker = null;\r\n      this._messageHandler = null;\r\n\r\n      if (port) {\r\n        pdfWorkerPorts.set(port, this);\r\n\r\n        this._initializeFromPort(port);\r\n\r\n        return;\r\n      }\r\n\r\n      this._initialize();\r\n    }\r\n\r\n    get promise() {\r\n      return this._readyCapability.promise;\r\n    }\r\n\r\n    get port() {\r\n      return this._port;\r\n    }\r\n\r\n    get messageHandler() {\r\n      return this._messageHandler;\r\n    }\r\n\r\n    _initializeFromPort(port) {\r\n      this._port = port;\r\n      this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\r\n\r\n      this._messageHandler.on(\"ready\", function () {});\r\n\r\n      this._readyCapability.resolve();\r\n    }\r\n\r\n    _initialize() {\r\n      if (typeof Worker !== \"undefined\" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {\r\n        let workerSrc = getWorkerSrc();\r\n\r\n        try {\r\n          if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {\r\n            workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);\r\n          }\r\n\r\n          const worker = new Worker(workerSrc);\r\n          const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\r\n\r\n          const terminateEarly = () => {\r\n            worker.removeEventListener(\"error\", onWorkerError);\r\n            messageHandler.destroy();\r\n            worker.terminate();\r\n\r\n            if (this.destroyed) {\r\n              this._readyCapability.reject(new Error(\"Worker was destroyed\"));\r\n            } else {\r\n              this._setupFakeWorker();\r\n            }\r\n          };\r\n\r\n          const onWorkerError = () => {\r\n            if (!this._webWorker) {\r\n              terminateEarly();\r\n            }\r\n          };\r\n\r\n          worker.addEventListener(\"error\", onWorkerError);\r\n          messageHandler.on(\"test\", data => {\r\n            worker.removeEventListener(\"error\", onWorkerError);\r\n\r\n            if (this.destroyed) {\r\n              terminateEarly();\r\n              return;\r\n            }\r\n\r\n            if (data) {\r\n              this._messageHandler = messageHandler;\r\n              this._port = worker;\r\n              this._webWorker = worker;\r\n\r\n              if (!data.supportTransfers) {\r\n                this.postMessageTransfers = false;\r\n              }\r\n\r\n              this._readyCapability.resolve();\r\n\r\n              messageHandler.send(\"configure\", {\r\n                verbosity: this.verbosity\r\n              });\r\n            } else {\r\n              this._setupFakeWorker();\r\n\r\n              messageHandler.destroy();\r\n              worker.terminate();\r\n            }\r\n          });\r\n          messageHandler.on(\"ready\", data => {\r\n            worker.removeEventListener(\"error\", onWorkerError);\r\n\r\n            if (this.destroyed) {\r\n              terminateEarly();\r\n              return;\r\n            }\r\n\r\n            try {\r\n              sendTest();\r\n            } catch (e) {\r\n              this._setupFakeWorker();\r\n            }\r\n          });\r\n\r\n          const sendTest = () => {\r\n            const testObj = new Uint8Array([this.postMessageTransfers ? 255 : 0]);\r\n\r\n            try {\r\n              messageHandler.send(\"test\", testObj, [testObj.buffer]);\r\n            } catch (ex) {\r\n              (0, _util.warn)(\"Cannot use postMessage transfers.\");\r\n              testObj[0] = 0;\r\n              messageHandler.send(\"test\", testObj);\r\n            }\r\n          };\r\n\r\n          sendTest();\r\n          return;\r\n        } catch (e) {\r\n          (0, _util.info)(\"The worker has been disabled.\");\r\n        }\r\n      }\r\n\r\n      this._setupFakeWorker();\r\n    }\r\n\r\n    _setupFakeWorker() {\r\n      if (!isWorkerDisabled) {\r\n        (0, _util.warn)(\"Setting up fake worker.\");\r\n        isWorkerDisabled = true;\r\n      }\r\n\r\n      setupFakeWorkerGlobal().then(WorkerMessageHandler => {\r\n        if (this.destroyed) {\r\n          this._readyCapability.reject(new Error(\"Worker was destroyed\"));\r\n\r\n          return;\r\n        }\r\n\r\n        const port = new LoopbackPort();\r\n        this._port = port;\r\n        const id = \"fake\" + nextFakeWorkerId++;\r\n        const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\r\n        WorkerMessageHandler.setup(workerHandler, port);\r\n        const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\r\n        this._messageHandler = messageHandler;\r\n\r\n        this._readyCapability.resolve();\r\n\r\n        messageHandler.send(\"configure\", {\r\n          verbosity: this.verbosity\r\n        });\r\n      }).catch(reason => {\r\n        this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\r\n      });\r\n    }\r\n\r\n    destroy() {\r\n      this.destroyed = true;\r\n\r\n      if (this._webWorker) {\r\n        this._webWorker.terminate();\r\n\r\n        this._webWorker = null;\r\n      }\r\n\r\n      pdfWorkerPorts.delete(this._port);\r\n      this._port = null;\r\n\r\n      if (this._messageHandler) {\r\n        this._messageHandler.destroy();\r\n\r\n        this._messageHandler = null;\r\n      }\r\n    }\r\n\r\n    static fromPort(params) {\r\n      if (!params || !params.port) {\r\n        throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\r\n      }\r\n\r\n      if (pdfWorkerPorts.has(params.port)) {\r\n        return pdfWorkerPorts.get(params.port);\r\n      }\r\n\r\n      return new PDFWorker(params);\r\n    }\r\n\r\n    static getWorkerSrc() {\r\n      return getWorkerSrc();\r\n    }\r\n\r\n  }\r\n\r\n  return PDFWorker;\r\n}();\r\n\r\nexports.PDFWorker = PDFWorker;\r\n\r\nclass WorkerTransport {\r\n  constructor(messageHandler, loadingTask, networkStream, params) {\r\n    this.messageHandler = messageHandler;\r\n    this.loadingTask = loadingTask;\r\n    this.commonObjs = new PDFObjects();\r\n    this.fontLoader = new _font_loader.FontLoader({\r\n      docId: loadingTask.docId,\r\n      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\r\n      ownerDocument: params.ownerDocument\r\n    });\r\n    this._params = params;\r\n    this.CMapReaderFactory = new params.CMapReaderFactory({\r\n      baseUrl: params.cMapUrl,\r\n      isCompressed: params.cMapPacked\r\n    });\r\n    this.destroyed = false;\r\n    this.destroyCapability = null;\r\n    this._passwordCapability = null;\r\n    this._networkStream = networkStream;\r\n    this._fullReader = null;\r\n    this._lastProgress = null;\r\n    this.pageCache = [];\r\n    this.pagePromises = [];\r\n    this.downloadInfoCapability = (0, _util.createPromiseCapability)();\r\n    this.setupMessageHandler();\r\n  }\r\n\r\n  get loadingTaskSettled() {\r\n    return this.loadingTask._capability.settled;\r\n  }\r\n\r\n  destroy() {\r\n    if (this.destroyCapability) {\r\n      return this.destroyCapability.promise;\r\n    }\r\n\r\n    this.destroyed = true;\r\n    this.destroyCapability = (0, _util.createPromiseCapability)();\r\n\r\n    if (this._passwordCapability) {\r\n      this._passwordCapability.reject(new Error(\"Worker was destroyed during onPassword callback\"));\r\n    }\r\n\r\n    const waitOn = [];\r\n    this.pageCache.forEach(function (page) {\r\n      if (page) {\r\n        waitOn.push(page._destroy());\r\n      }\r\n    });\r\n    this.pageCache.length = 0;\r\n    this.pagePromises.length = 0;\r\n    const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\r\n    waitOn.push(terminated);\r\n\r\n    if (this.loadingTaskSettled) {\r\n      const annotationStorageResetModified = this.loadingTask.promise.then(pdfDocument => {\r\n        if (pdfDocument.hasOwnProperty(\"annotationStorage\")) {\r\n          pdfDocument.annotationStorage.resetModified();\r\n        }\r\n      }).catch(() => {});\r\n      waitOn.push(annotationStorageResetModified);\r\n    }\r\n\r\n    Promise.all(waitOn).then(() => {\r\n      this.commonObjs.clear();\r\n      this.fontLoader.clear();\r\n      this._hasJSActionsPromise = null;\r\n\r\n      if (this._networkStream) {\r\n        this._networkStream.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\r\n      }\r\n\r\n      if (this.messageHandler) {\r\n        this.messageHandler.destroy();\r\n        this.messageHandler = null;\r\n      }\r\n\r\n      this.destroyCapability.resolve();\r\n    }, this.destroyCapability.reject);\r\n    return this.destroyCapability.promise;\r\n  }\r\n\r\n  setupMessageHandler() {\r\n    const {\r\n      messageHandler,\r\n      loadingTask\r\n    } = this;\r\n    messageHandler.on(\"GetReader\", (data, sink) => {\r\n      (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\r\n      this._fullReader = this._networkStream.getFullReader();\r\n\r\n      this._fullReader.onProgress = evt => {\r\n        this._lastProgress = {\r\n          loaded: evt.loaded,\r\n          total: evt.total\r\n        };\r\n      };\r\n\r\n      sink.onPull = () => {\r\n        this._fullReader.read().then(function ({\r\n          value,\r\n          done\r\n        }) {\r\n          if (done) {\r\n            sink.close();\r\n            return;\r\n          }\r\n\r\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetReader - expected an ArrayBuffer.\");\r\n          sink.enqueue(new Uint8Array(value), 1, [value]);\r\n        }).catch(reason => {\r\n          sink.error(reason);\r\n        });\r\n      };\r\n\r\n      sink.onCancel = reason => {\r\n        this._fullReader.cancel(reason);\r\n\r\n        sink.ready.catch(readyReason => {\r\n          if (this.destroyed) {\r\n            return;\r\n          }\r\n\r\n          throw readyReason;\r\n        });\r\n      };\r\n    });\r\n    messageHandler.on(\"ReaderHeadersReady\", data => {\r\n      const headersCapability = (0, _util.createPromiseCapability)();\r\n      const fullReader = this._fullReader;\r\n      fullReader.headersReady.then(() => {\r\n        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\r\n          if (this._lastProgress && loadingTask.onProgress) {\r\n            loadingTask.onProgress(this._lastProgress);\r\n          }\r\n\r\n          fullReader.onProgress = evt => {\r\n            if (loadingTask.onProgress) {\r\n              loadingTask.onProgress({\r\n                loaded: evt.loaded,\r\n                total: evt.total\r\n              });\r\n            }\r\n          };\r\n        }\r\n\r\n        headersCapability.resolve({\r\n          isStreamingSupported: fullReader.isStreamingSupported,\r\n          isRangeSupported: fullReader.isRangeSupported,\r\n          contentLength: fullReader.contentLength\r\n        });\r\n      }, headersCapability.reject);\r\n      return headersCapability.promise;\r\n    });\r\n    messageHandler.on(\"GetRangeReader\", (data, sink) => {\r\n      (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\r\n\r\n      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\r\n\r\n      if (!rangeReader) {\r\n        sink.close();\r\n        return;\r\n      }\r\n\r\n      sink.onPull = () => {\r\n        rangeReader.read().then(function ({\r\n          value,\r\n          done\r\n        }) {\r\n          if (done) {\r\n            sink.close();\r\n            return;\r\n          }\r\n\r\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetRangeReader - expected an ArrayBuffer.\");\r\n          sink.enqueue(new Uint8Array(value), 1, [value]);\r\n        }).catch(reason => {\r\n          sink.error(reason);\r\n        });\r\n      };\r\n\r\n      sink.onCancel = reason => {\r\n        rangeReader.cancel(reason);\r\n        sink.ready.catch(readyReason => {\r\n          if (this.destroyed) {\r\n            return;\r\n          }\r\n\r\n          throw readyReason;\r\n        });\r\n      };\r\n    });\r\n    messageHandler.on(\"GetDoc\", ({\r\n      pdfInfo\r\n    }) => {\r\n      this._numPages = pdfInfo.numPages;\r\n\r\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\r\n    });\r\n    messageHandler.on(\"DocException\", function (ex) {\r\n      let reason;\r\n\r\n      switch (ex.name) {\r\n        case \"PasswordException\":\r\n          reason = new _util.PasswordException(ex.message, ex.code);\r\n          break;\r\n\r\n        case \"InvalidPDFException\":\r\n          reason = new _util.InvalidPDFException(ex.message);\r\n          break;\r\n\r\n        case \"MissingPDFException\":\r\n          reason = new _util.MissingPDFException(ex.message);\r\n          break;\r\n\r\n        case \"UnexpectedResponseException\":\r\n          reason = new _util.UnexpectedResponseException(ex.message, ex.status);\r\n          break;\r\n\r\n        case \"UnknownErrorException\":\r\n          reason = new _util.UnknownErrorException(ex.message, ex.details);\r\n          break;\r\n      }\r\n\r\n      if (!(reason instanceof Error)) {\r\n        const msg = \"DocException - expected a valid Error.\";\r\n        (0, _util.warn)(msg);\r\n      }\r\n\r\n      loadingTask._capability.reject(reason);\r\n    });\r\n    messageHandler.on(\"PasswordRequest\", exception => {\r\n      this._passwordCapability = (0, _util.createPromiseCapability)();\r\n\r\n      if (loadingTask.onPassword) {\r\n        const updatePassword = password => {\r\n          this._passwordCapability.resolve({\r\n            password\r\n          });\r\n        };\r\n\r\n        try {\r\n          loadingTask.onPassword(updatePassword, exception.code);\r\n        } catch (ex) {\r\n          this._passwordCapability.reject(ex);\r\n        }\r\n      } else {\r\n        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\r\n      }\r\n\r\n      return this._passwordCapability.promise;\r\n    });\r\n    messageHandler.on(\"DataLoaded\", data => {\r\n      if (loadingTask.onProgress) {\r\n        loadingTask.onProgress({\r\n          loaded: data.length,\r\n          total: data.length\r\n        });\r\n      }\r\n\r\n      this.downloadInfoCapability.resolve(data);\r\n    });\r\n    messageHandler.on(\"StartRenderPage\", data => {\r\n      if (this.destroyed) {\r\n        return;\r\n      }\r\n\r\n      const page = this.pageCache[data.pageIndex];\r\n\r\n      page._startRenderPage(data.transparency, data.intent);\r\n    });\r\n    messageHandler.on(\"commonobj\", data => {\r\n      if (this.destroyed) {\r\n        return;\r\n      }\r\n\r\n      const [id, type, exportedData] = data;\r\n\r\n      if (this.commonObjs.has(id)) {\r\n        return;\r\n      }\r\n\r\n      switch (type) {\r\n        case \"Font\":\r\n          const params = this._params;\r\n\r\n          if (\"error\" in exportedData) {\r\n            const exportedError = exportedData.error;\r\n            (0, _util.warn)(`Error during font loading: ${exportedError}`);\r\n            this.commonObjs.resolve(id, exportedError);\r\n            break;\r\n          }\r\n\r\n          let fontRegistry = null;\r\n\r\n          if (params.pdfBug && globalThis.FontInspector?.enabled) {\r\n            fontRegistry = {\r\n              registerFont(font, url) {\r\n                globalThis.FontInspector.fontAdded(font, url);\r\n              }\r\n\r\n            };\r\n          }\r\n\r\n          const font = new _font_loader.FontFaceObject(exportedData, {\r\n            isEvalSupported: params.isEvalSupported,\r\n            disableFontFace: params.disableFontFace,\r\n            ignoreErrors: params.ignoreErrors,\r\n            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\r\n            fontRegistry\r\n          });\r\n          this.fontLoader.bind(font).catch(reason => {\r\n            return messageHandler.sendWithPromise(\"FontFallback\", {\r\n              id\r\n            });\r\n          }).finally(() => {\r\n            if (!params.fontExtraProperties && font.data) {\r\n              font.data = null;\r\n            }\r\n\r\n            this.commonObjs.resolve(id, font);\r\n          });\r\n          break;\r\n\r\n        case \"FontPath\":\r\n        case \"Image\":\r\n          this.commonObjs.resolve(id, exportedData);\r\n          break;\r\n\r\n        default:\r\n          throw new Error(`Got unknown common object type ${type}`);\r\n      }\r\n    });\r\n    messageHandler.on(\"obj\", data => {\r\n      if (this.destroyed) {\r\n        return undefined;\r\n      }\r\n\r\n      const [id, pageIndex, type, imageData] = data;\r\n      const pageProxy = this.pageCache[pageIndex];\r\n\r\n      if (pageProxy.objs.has(id)) {\r\n        return undefined;\r\n      }\r\n\r\n      switch (type) {\r\n        case \"Image\":\r\n          pageProxy.objs.resolve(id, imageData);\r\n          const MAX_IMAGE_SIZE_TO_STORE = 8000000;\r\n\r\n          if (imageData?.data?.length > MAX_IMAGE_SIZE_TO_STORE) {\r\n            pageProxy.cleanupAfterRender = true;\r\n          }\r\n\r\n          break;\r\n\r\n        default:\r\n          throw new Error(`Got unknown object type ${type}`);\r\n      }\r\n\r\n      return undefined;\r\n    });\r\n    messageHandler.on(\"DocProgress\", data => {\r\n      if (this.destroyed) {\r\n        return;\r\n      }\r\n\r\n      if (loadingTask.onProgress) {\r\n        loadingTask.onProgress({\r\n          loaded: data.loaded,\r\n          total: data.total\r\n        });\r\n      }\r\n    });\r\n    messageHandler.on(\"UnsupportedFeature\", this._onUnsupportedFeature.bind(this));\r\n    messageHandler.on(\"FetchBuiltInCMap\", (data, sink) => {\r\n      if (this.destroyed) {\r\n        sink.error(new Error(\"Worker was destroyed\"));\r\n        return;\r\n      }\r\n\r\n      let fetched = false;\r\n\r\n      sink.onPull = () => {\r\n        if (fetched) {\r\n          sink.close();\r\n          return;\r\n        }\r\n\r\n        fetched = true;\r\n        this.CMapReaderFactory.fetch(data).then(function (builtInCMap) {\r\n          sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);\r\n        }).catch(function (reason) {\r\n          sink.error(reason);\r\n        });\r\n      };\r\n    });\r\n  }\r\n\r\n  _onUnsupportedFeature({\r\n    featureId\r\n  }) {\r\n    if (this.destroyed) {\r\n      return;\r\n    }\r\n\r\n    if (this.loadingTask.onUnsupportedFeature) {\r\n      this.loadingTask.onUnsupportedFeature(featureId);\r\n    }\r\n  }\r\n\r\n  getData() {\r\n    return this.messageHandler.sendWithPromise(\"GetData\", null);\r\n  }\r\n\r\n  getPage(pageNumber) {\r\n    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\r\n      return Promise.reject(new Error(\"Invalid page request\"));\r\n    }\r\n\r\n    const pageIndex = pageNumber - 1;\r\n\r\n    if (pageIndex in this.pagePromises) {\r\n      return this.pagePromises[pageIndex];\r\n    }\r\n\r\n    const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\r\n      pageIndex\r\n    }).then(pageInfo => {\r\n      if (this.destroyed) {\r\n        throw new Error(\"Transport destroyed\");\r\n      }\r\n\r\n      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);\r\n      this.pageCache[pageIndex] = page;\r\n      return page;\r\n    });\r\n    this.pagePromises[pageIndex] = promise;\r\n    return promise;\r\n  }\r\n\r\n  getPageIndex(ref) {\r\n    return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\r\n      ref\r\n    }).catch(function (reason) {\r\n      return Promise.reject(new Error(reason));\r\n    });\r\n  }\r\n\r\n  getAnnotations(pageIndex, intent) {\r\n    return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\r\n      pageIndex,\r\n      intent\r\n    });\r\n  }\r\n\r\n  saveDocument(annotationStorage) {\r\n    return this.messageHandler.sendWithPromise(\"SaveDocument\", {\r\n      numPages: this._numPages,\r\n      annotationStorage: annotationStorage?.getAll() || null,\r\n      filename: this._fullReader?.filename ?? null\r\n    }).finally(() => {\r\n      if (annotationStorage) {\r\n        annotationStorage.resetModified();\r\n      }\r\n    });\r\n  }\r\n\r\n  getFieldObjects() {\r\n    return this.messageHandler.sendWithPromise(\"GetFieldObjects\", null);\r\n  }\r\n\r\n  hasJSActions() {\r\n    return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise(\"HasJSActions\", null));\r\n  }\r\n\r\n  getCalculationOrderIds() {\r\n    return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\r\n  }\r\n\r\n  getDestinations() {\r\n    return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\r\n  }\r\n\r\n  getDestination(id) {\r\n    if (typeof id !== \"string\") {\r\n      return Promise.reject(new Error(\"Invalid destination request.\"));\r\n    }\r\n\r\n    return this.messageHandler.sendWithPromise(\"GetDestination\", {\r\n      id\r\n    });\r\n  }\r\n\r\n  getPageLabels() {\r\n    return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\r\n  }\r\n\r\n  getPageLayout() {\r\n    return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\r\n  }\r\n\r\n  getPageMode() {\r\n    return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\r\n  }\r\n\r\n  getViewerPreferences() {\r\n    return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\r\n  }\r\n\r\n  getOpenAction() {\r\n    return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\r\n  }\r\n\r\n  getAttachments() {\r\n    return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\r\n  }\r\n\r\n  getJavaScript() {\r\n    return this.messageHandler.sendWithPromise(\"GetJavaScript\", null);\r\n  }\r\n\r\n  getDocJSActions() {\r\n    return this.messageHandler.sendWithPromise(\"GetDocJSActions\", null);\r\n  }\r\n\r\n  getPageJSActions(pageIndex) {\r\n    return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\r\n      pageIndex\r\n    });\r\n  }\r\n\r\n  getOutline() {\r\n    return this.messageHandler.sendWithPromise(\"GetOutline\", null);\r\n  }\r\n\r\n  getOptionalContentConfig() {\r\n    return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(results => {\r\n      return new _optional_content_config.OptionalContentConfig(results);\r\n    });\r\n  }\r\n\r\n  getPermissions() {\r\n    return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\r\n  }\r\n\r\n  getMetadata() {\r\n    return this.messageHandler.sendWithPromise(\"GetMetadata\", null).then(results => {\r\n      return {\r\n        info: results[0],\r\n        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\r\n        contentDispositionFilename: this._fullReader?.filename ?? null,\r\n        contentLength: this._fullReader?.contentLength ?? null\r\n      };\r\n    });\r\n  }\r\n\r\n  getMarkInfo() {\r\n    return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\r\n  }\r\n\r\n  getStats() {\r\n    return this.messageHandler.sendWithPromise(\"GetStats\", null);\r\n  }\r\n\r\n  startCleanup() {\r\n    return this.messageHandler.sendWithPromise(\"Cleanup\", null).then(() => {\r\n      for (let i = 0, ii = this.pageCache.length; i < ii; i++) {\r\n        const page = this.pageCache[i];\r\n\r\n        if (page) {\r\n          const cleanupSuccessful = page.cleanup();\r\n\r\n          if (!cleanupSuccessful) {\r\n            throw new Error(`startCleanup: Page ${i + 1} is currently rendering.`);\r\n          }\r\n        }\r\n      }\r\n\r\n      this.commonObjs.clear();\r\n      this.fontLoader.clear();\r\n      this._hasJSActionsPromise = null;\r\n    });\r\n  }\r\n\r\n  get loadingParams() {\r\n    const params = this._params;\r\n    return (0, _util.shadow)(this, \"loadingParams\", {\r\n      disableAutoFetch: params.disableAutoFetch,\r\n      disableFontFace: params.disableFontFace\r\n    });\r\n  }\r\n\r\n}\r\n\r\nclass PDFObjects {\r\n  constructor() {\r\n    this._objs = Object.create(null);\r\n  }\r\n\r\n  _ensureObj(objId) {\r\n    if (this._objs[objId]) {\r\n      return this._objs[objId];\r\n    }\r\n\r\n    return this._objs[objId] = {\r\n      capability: (0, _util.createPromiseCapability)(),\r\n      data: null,\r\n      resolved: false\r\n    };\r\n  }\r\n\r\n  get(objId, callback = null) {\r\n    if (callback) {\r\n      this._ensureObj(objId).capability.promise.then(callback);\r\n\r\n      return null;\r\n    }\r\n\r\n    const obj = this._objs[objId];\r\n\r\n    if (!obj || !obj.resolved) {\r\n      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\r\n    }\r\n\r\n    return obj.data;\r\n  }\r\n\r\n  has(objId) {\r\n    const obj = this._objs[objId];\r\n    return obj?.resolved || false;\r\n  }\r\n\r\n  resolve(objId, data) {\r\n    const obj = this._ensureObj(objId);\r\n\r\n    obj.resolved = true;\r\n    obj.data = data;\r\n    obj.capability.resolve(data);\r\n  }\r\n\r\n  clear() {\r\n    this._objs = Object.create(null);\r\n  }\r\n\r\n}\r\n\r\nclass RenderTask {\r\n  constructor(internalRenderTask) {\r\n    this._internalRenderTask = internalRenderTask;\r\n    this.onContinue = null;\r\n  }\r\n\r\n  get promise() {\r\n    return this._internalRenderTask.capability.promise;\r\n  }\r\n\r\n  cancel() {\r\n    this._internalRenderTask.cancel();\r\n  }\r\n\r\n}\r\n\r\nconst InternalRenderTask = function InternalRenderTaskClosure() {\r\n  const canvasInRendering = new WeakSet();\r\n\r\n  class InternalRenderTask {\r\n    constructor({\r\n      callback,\r\n      params,\r\n      objs,\r\n      commonObjs,\r\n      operatorList,\r\n      pageIndex,\r\n      canvasFactory,\r\n      webGLContext,\r\n      useRequestAnimationFrame = false,\r\n      pdfBug = false\r\n    }) {\r\n      this.callback = callback;\r\n      this.params = params;\r\n      this.objs = objs;\r\n      this.commonObjs = commonObjs;\r\n      this.operatorListIdx = null;\r\n      this.operatorList = operatorList;\r\n      this._pageIndex = pageIndex;\r\n      this.canvasFactory = canvasFactory;\r\n      this.webGLContext = webGLContext;\r\n      this._pdfBug = pdfBug;\r\n      this.running = false;\r\n      this.graphicsReadyCallback = null;\r\n      this.graphicsReady = false;\r\n      this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\r\n      this.cancelled = false;\r\n      this.capability = (0, _util.createPromiseCapability)();\r\n      this.task = new RenderTask(this);\r\n      this._continueBound = this._continue.bind(this);\r\n      this._scheduleNextBound = this._scheduleNext.bind(this);\r\n      this._nextBound = this._next.bind(this);\r\n      this._canvas = params.canvasContext.canvas;\r\n    }\r\n\r\n    get completed() {\r\n      return this.capability.promise.catch(function () {});\r\n    }\r\n\r\n    initializeGraphics({\r\n      transparency = false,\r\n      optionalContentConfig\r\n    }) {\r\n      if (this.cancelled) {\r\n        return;\r\n      }\r\n\r\n      if (this._canvas) {\r\n        if (canvasInRendering.has(this._canvas)) {\r\n          throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\r\n        }\r\n\r\n        canvasInRendering.add(this._canvas);\r\n      }\r\n\r\n      if (this._pdfBug && globalThis.StepperManager?.enabled) {\r\n        this.stepper = globalThis.StepperManager.create(this._pageIndex);\r\n        this.stepper.init(this.operatorList);\r\n        this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\r\n      }\r\n\r\n      const {\r\n        canvasContext,\r\n        viewport,\r\n        transform,\r\n        imageLayer,\r\n        background\r\n      } = this.params;\r\n      this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer, optionalContentConfig);\r\n      this.gfx.beginDrawing({\r\n        transform,\r\n        viewport,\r\n        transparency,\r\n        background\r\n      });\r\n      this.operatorListIdx = 0;\r\n      this.graphicsReady = true;\r\n\r\n      if (this.graphicsReadyCallback) {\r\n        this.graphicsReadyCallback();\r\n      }\r\n    }\r\n\r\n    cancel(error = null) {\r\n      this.running = false;\r\n      this.cancelled = true;\r\n\r\n      if (this.gfx) {\r\n        this.gfx.endDrawing();\r\n      }\r\n\r\n      if (this._canvas) {\r\n        canvasInRendering.delete(this._canvas);\r\n      }\r\n\r\n      this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, \"canvas\"));\r\n    }\r\n\r\n    operatorListChanged() {\r\n      if (!this.graphicsReady) {\r\n        if (!this.graphicsReadyCallback) {\r\n          this.graphicsReadyCallback = this._continueBound;\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if (this.stepper) {\r\n        this.stepper.updateOperatorList(this.operatorList);\r\n      }\r\n\r\n      if (this.running) {\r\n        return;\r\n      }\r\n\r\n      this._continue();\r\n    }\r\n\r\n    _continue() {\r\n      this.running = true;\r\n\r\n      if (this.cancelled) {\r\n        return;\r\n      }\r\n\r\n      if (this.task.onContinue) {\r\n        this.task.onContinue(this._scheduleNextBound);\r\n      } else {\r\n        this._scheduleNext();\r\n      }\r\n    }\r\n\r\n    _scheduleNext() {\r\n      if (this._useRequestAnimationFrame) {\r\n        window.requestAnimationFrame(() => {\r\n          this._nextBound().catch(this.cancel.bind(this));\r\n        });\r\n      } else {\r\n        Promise.resolve().then(this._nextBound).catch(this.cancel.bind(this));\r\n      }\r\n    }\r\n\r\n    async _next() {\r\n      if (this.cancelled) {\r\n        return;\r\n      }\r\n\r\n      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\r\n\r\n      if (this.operatorListIdx === this.operatorList.argsArray.length) {\r\n        this.running = false;\r\n\r\n        if (this.operatorList.lastChunk) {\r\n          this.gfx.endDrawing();\r\n\r\n          if (this._canvas) {\r\n            canvasInRendering.delete(this._canvas);\r\n          }\r\n\r\n          this.callback();\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  return InternalRenderTask;\r\n}();\r\n\r\nconst version = '2.7.570';\r\nexports.version = version;\r\nconst build = 'f2c7338b0';\r\nexports.build = build;\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.FontLoader = exports.FontFaceObject = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nclass BaseFontLoader {\r\n  constructor({\r\n    docId,\r\n    onUnsupportedFeature,\r\n    ownerDocument = globalThis.document\r\n  }) {\r\n    if (this.constructor === BaseFontLoader) {\r\n      (0, _util.unreachable)(\"Cannot initialize BaseFontLoader.\");\r\n    }\r\n\r\n    this.docId = docId;\r\n    this._onUnsupportedFeature = onUnsupportedFeature;\r\n    this._document = ownerDocument;\r\n    this.nativeFontFaces = [];\r\n    this.styleElement = null;\r\n  }\r\n\r\n  addNativeFontFace(nativeFontFace) {\r\n    this.nativeFontFaces.push(nativeFontFace);\r\n\r\n    this._document.fonts.add(nativeFontFace);\r\n  }\r\n\r\n  insertRule(rule) {\r\n    let styleElement = this.styleElement;\r\n\r\n    if (!styleElement) {\r\n      styleElement = this.styleElement = this._document.createElement(\"style\");\r\n      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;\r\n\r\n      this._document.documentElement.getElementsByTagName(\"head\")[0].appendChild(styleElement);\r\n    }\r\n\r\n    const styleSheet = styleElement.sheet;\r\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\r\n  }\r\n\r\n  clear() {\r\n    this.nativeFontFaces.forEach(nativeFontFace => {\r\n      this._document.fonts.delete(nativeFontFace);\r\n    });\r\n    this.nativeFontFaces.length = 0;\r\n\r\n    if (this.styleElement) {\r\n      this.styleElement.remove();\r\n      this.styleElement = null;\r\n    }\r\n  }\r\n\r\n  async bind(font) {\r\n    if (font.attached || font.missingFile) {\r\n      return;\r\n    }\r\n\r\n    font.attached = true;\r\n\r\n    if (this.isFontLoadingAPISupported) {\r\n      const nativeFontFace = font.createNativeFontFace();\r\n\r\n      if (nativeFontFace) {\r\n        this.addNativeFontFace(nativeFontFace);\r\n\r\n        try {\r\n          await nativeFontFace.loaded;\r\n        } catch (ex) {\r\n          this._onUnsupportedFeature({\r\n            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative\r\n          });\r\n\r\n          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\r\n          font.disableFontFace = true;\r\n          throw ex;\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    const rule = font.createFontFaceRule();\r\n\r\n    if (rule) {\r\n      this.insertRule(rule);\r\n\r\n      if (this.isSyncFontLoadingSupported) {\r\n        return;\r\n      }\r\n\r\n      await new Promise(resolve => {\r\n        const request = this._queueLoadingCallback(resolve);\r\n\r\n        this._prepareFontLoadEvent([rule], [font], request);\r\n      });\r\n    }\r\n  }\r\n\r\n  _queueLoadingCallback(callback) {\r\n    (0, _util.unreachable)(\"Abstract method `_queueLoadingCallback`.\");\r\n  }\r\n\r\n  get isFontLoadingAPISupported() {\r\n    return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", !!this._document?.fonts);\r\n  }\r\n\r\n  get isSyncFontLoadingSupported() {\r\n    (0, _util.unreachable)(\"Abstract method `isSyncFontLoadingSupported`.\");\r\n  }\r\n\r\n  get _loadTestFont() {\r\n    (0, _util.unreachable)(\"Abstract method `_loadTestFont`.\");\r\n  }\r\n\r\n  _prepareFontLoadEvent(rules, fontsToLoad, request) {\r\n    (0, _util.unreachable)(\"Abstract method `_prepareFontLoadEvent`.\");\r\n  }\r\n\r\n}\r\n\r\nlet FontLoader;\r\nexports.FontLoader = FontLoader;\r\n{\r\n  exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {\r\n    constructor(params) {\r\n      super(params);\r\n      this.loadingContext = {\r\n        requests: [],\r\n        nextRequestId: 0\r\n      };\r\n      this.loadTestFontId = 0;\r\n    }\r\n\r\n    get isSyncFontLoadingSupported() {\r\n      let supported = false;\r\n\r\n      if (typeof navigator === \"undefined\") {\r\n        supported = true;\r\n      } else {\r\n        const m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\r\n\r\n        if (m?.[1] >= 14) {\r\n          supported = true;\r\n        }\r\n      }\r\n\r\n      return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\r\n    }\r\n\r\n    _queueLoadingCallback(callback) {\r\n      function completeRequest() {\r\n        (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\r\n        request.done = true;\r\n\r\n        while (context.requests.length > 0 && context.requests[0].done) {\r\n          const otherRequest = context.requests.shift();\r\n          setTimeout(otherRequest.callback, 0);\r\n        }\r\n      }\r\n\r\n      const context = this.loadingContext;\r\n      const request = {\r\n        id: `pdfjs-font-loading-${context.nextRequestId++}`,\r\n        done: false,\r\n        complete: completeRequest,\r\n        callback\r\n      };\r\n      context.requests.push(request);\r\n      return request;\r\n    }\r\n\r\n    get _loadTestFont() {\r\n      const getLoadTestFont = function () {\r\n        return atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\r\n      };\r\n\r\n      return (0, _util.shadow)(this, \"_loadTestFont\", getLoadTestFont());\r\n    }\r\n\r\n    _prepareFontLoadEvent(rules, fonts, request) {\r\n      function int32(data, offset) {\r\n        return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\r\n      }\r\n\r\n      function spliceString(s, offset, remove, insert) {\r\n        const chunk1 = s.substring(0, offset);\r\n        const chunk2 = s.substring(offset + remove);\r\n        return chunk1 + insert + chunk2;\r\n      }\r\n\r\n      let i, ii;\r\n\r\n      const canvas = this._document.createElement(\"canvas\");\r\n\r\n      canvas.width = 1;\r\n      canvas.height = 1;\r\n      const ctx = canvas.getContext(\"2d\");\r\n      let called = 0;\r\n\r\n      function isFontReady(name, callback) {\r\n        called++;\r\n\r\n        if (called > 30) {\r\n          (0, _util.warn)(\"Load test font never loaded.\");\r\n          callback();\r\n          return;\r\n        }\r\n\r\n        ctx.font = \"30px \" + name;\r\n        ctx.fillText(\".\", 0, 20);\r\n        const imageData = ctx.getImageData(0, 0, 1, 1);\r\n\r\n        if (imageData.data[3] > 0) {\r\n          callback();\r\n          return;\r\n        }\r\n\r\n        setTimeout(isFontReady.bind(null, name, callback));\r\n      }\r\n\r\n      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\r\n      let data = this._loadTestFont;\r\n      const COMMENT_OFFSET = 976;\r\n      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\r\n      const CFF_CHECKSUM_OFFSET = 16;\r\n      const XXXX_VALUE = 0x58585858;\r\n      let checksum = int32(data, CFF_CHECKSUM_OFFSET);\r\n\r\n      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\r\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\r\n      }\r\n\r\n      if (i < loadTestFontId.length) {\r\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\r\n      }\r\n\r\n      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\r\n      const url = `url(data:font/opentype;base64,${btoa(data)});`;\r\n      const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\r\n      this.insertRule(rule);\r\n      const names = [];\r\n\r\n      for (i = 0, ii = fonts.length; i < ii; i++) {\r\n        names.push(fonts[i].loadedName);\r\n      }\r\n\r\n      names.push(loadTestFontId);\r\n\r\n      const div = this._document.createElement(\"div\");\r\n\r\n      div.style.visibility = \"hidden\";\r\n      div.style.width = div.style.height = \"10px\";\r\n      div.style.position = \"absolute\";\r\n      div.style.top = div.style.left = \"0px\";\r\n\r\n      for (i = 0, ii = names.length; i < ii; ++i) {\r\n        const span = this._document.createElement(\"span\");\r\n\r\n        span.textContent = \"Hi\";\r\n        span.style.fontFamily = names[i];\r\n        div.appendChild(span);\r\n      }\r\n\r\n      this._document.body.appendChild(div);\r\n\r\n      isFontReady(loadTestFontId, () => {\r\n        this._document.body.removeChild(div);\r\n\r\n        request.complete();\r\n      });\r\n    }\r\n\r\n  };\r\n}\r\n\r\nclass FontFaceObject {\r\n  constructor(translatedData, {\r\n    isEvalSupported = true,\r\n    disableFontFace = false,\r\n    ignoreErrors = false,\r\n    onUnsupportedFeature = null,\r\n    fontRegistry = null\r\n  }) {\r\n    this.compiledGlyphs = Object.create(null);\r\n\r\n    for (const i in translatedData) {\r\n      this[i] = translatedData[i];\r\n    }\r\n\r\n    this.isEvalSupported = isEvalSupported !== false;\r\n    this.disableFontFace = disableFontFace === true;\r\n    this.ignoreErrors = ignoreErrors === true;\r\n    this._onUnsupportedFeature = onUnsupportedFeature;\r\n    this.fontRegistry = fontRegistry;\r\n  }\r\n\r\n  createNativeFontFace() {\r\n    if (!this.data || this.disableFontFace) {\r\n      return null;\r\n    }\r\n\r\n    const nativeFontFace = new FontFace(this.loadedName, this.data, {});\r\n\r\n    if (this.fontRegistry) {\r\n      this.fontRegistry.registerFont(this);\r\n    }\r\n\r\n    return nativeFontFace;\r\n  }\r\n\r\n  createFontFaceRule() {\r\n    if (!this.data || this.disableFontFace) {\r\n      return null;\r\n    }\r\n\r\n    const data = (0, _util.bytesToString)(new Uint8Array(this.data));\r\n    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\r\n    const rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\r\n\r\n    if (this.fontRegistry) {\r\n      this.fontRegistry.registerFont(this, url);\r\n    }\r\n\r\n    return rule;\r\n  }\r\n\r\n  getPathGenerator(objs, character) {\r\n    if (this.compiledGlyphs[character] !== undefined) {\r\n      return this.compiledGlyphs[character];\r\n    }\r\n\r\n    let cmds, current;\r\n\r\n    try {\r\n      cmds = objs.get(this.loadedName + \"_path_\" + character);\r\n    } catch (ex) {\r\n      if (!this.ignoreErrors) {\r\n        throw ex;\r\n      }\r\n\r\n      if (this._onUnsupportedFeature) {\r\n        this._onUnsupportedFeature({\r\n          featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath\r\n        });\r\n      }\r\n\r\n      (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\r\n      return this.compiledGlyphs[character] = function (c, size) {};\r\n    }\r\n\r\n    if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {\r\n      let args,\r\n          js = \"\";\r\n\r\n      for (let i = 0, ii = cmds.length; i < ii; i++) {\r\n        current = cmds[i];\r\n\r\n        if (current.args !== undefined) {\r\n          args = current.args.join(\",\");\r\n        } else {\r\n          args = \"\";\r\n        }\r\n\r\n        js += \"c.\" + current.cmd + \"(\" + args + \");\\n\";\r\n      }\r\n\r\n      return this.compiledGlyphs[character] = new Function(\"c\", \"size\", js);\r\n    }\r\n\r\n    return this.compiledGlyphs[character] = function (c, size) {\r\n      for (let i = 0, ii = cmds.length; i < ii; i++) {\r\n        current = cmds[i];\r\n\r\n        if (current.cmd === \"scale\") {\r\n          current.args = [size, -size];\r\n        }\r\n\r\n        c[current.cmd].apply(c, current.args);\r\n      }\r\n    };\r\n  }\r\n\r\n}\r\n\r\nexports.FontFaceObject = FontFaceObject;\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.NodeCMapReaderFactory = exports.NodeCanvasFactory = void 0;\r\n\r\nvar _display_utils = __w_pdfjs_require__(1);\r\n\r\nvar _is_node = __w_pdfjs_require__(4);\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nlet NodeCanvasFactory = class {\r\n  constructor() {\r\n    (0, _util.unreachable)(\"Not implemented: NodeCanvasFactory\");\r\n  }\r\n\r\n};\r\nexports.NodeCanvasFactory = NodeCanvasFactory;\r\nlet NodeCMapReaderFactory = class {\r\n  constructor() {\r\n    (0, _util.unreachable)(\"Not implemented: NodeCMapReaderFactory\");\r\n  }\r\n\r\n};\r\nexports.NodeCMapReaderFactory = NodeCMapReaderFactory;\r\n\r\nif (_is_node.isNodeJS) {\r\n  exports.NodeCanvasFactory = NodeCanvasFactory = class extends _display_utils.BaseCanvasFactory {\r\n    create(width, height) {\r\n      if (width <= 0 || height <= 0) {\r\n        throw new Error(\"Invalid canvas size\");\r\n      }\r\n\r\n      const Canvas = require(\"canvas\");\r\n\r\n      const canvas = Canvas.createCanvas(width, height);\r\n      return {\r\n        canvas,\r\n        context: canvas.getContext(\"2d\")\r\n      };\r\n    }\r\n\r\n  };\r\n  exports.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _display_utils.BaseCMapReaderFactory {\r\n    _fetchData(url, compressionType) {\r\n      return new Promise((resolve, reject) => {\r\n        const fs = require(\"fs\");\r\n\r\n        fs.readFile(url, (error, data) => {\r\n          if (error || !data) {\r\n            reject(new Error(error));\r\n            return;\r\n          }\r\n\r\n          resolve({\r\n            cMapData: new Uint8Array(data),\r\n            compressionType\r\n          });\r\n        });\r\n      });\r\n    }\r\n\r\n  };\r\n}\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.AnnotationStorage = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nclass AnnotationStorage {\r\n  constructor() {\r\n    this._storage = new Map();\r\n    this._modified = false;\r\n    this.onSetModified = null;\r\n    this.onResetModified = null;\r\n  }\r\n\r\n  getOrCreateValue(key, defaultValue) {\r\n    if (this._storage.has(key)) {\r\n      return this._storage.get(key);\r\n    }\r\n\r\n    this._storage.set(key, defaultValue);\r\n\r\n    return defaultValue;\r\n  }\r\n\r\n  setValue(key, value) {\r\n    const obj = this._storage.get(key);\r\n\r\n    let modified = false;\r\n\r\n    if (obj !== undefined) {\r\n      for (const [entry, val] of Object.entries(value)) {\r\n        if (obj[entry] !== val) {\r\n          modified = true;\r\n          obj[entry] = val;\r\n        }\r\n      }\r\n    } else {\r\n      this._storage.set(key, value);\r\n\r\n      modified = true;\r\n    }\r\n\r\n    if (modified) {\r\n      this._setModified();\r\n    }\r\n  }\r\n\r\n  getAll() {\r\n    if (this._storage.size === 0) {\r\n      return null;\r\n    }\r\n\r\n    return (0, _util.objectFromEntries)(this._storage);\r\n  }\r\n\r\n  get size() {\r\n    return this._storage.size;\r\n  }\r\n\r\n  _setModified() {\r\n    if (!this._modified) {\r\n      this._modified = true;\r\n\r\n      if (typeof this.onSetModified === \"function\") {\r\n        this.onSetModified();\r\n      }\r\n    }\r\n  }\r\n\r\n  resetModified() {\r\n    if (this._modified) {\r\n      this._modified = false;\r\n\r\n      if (typeof this.onResetModified === \"function\") {\r\n        this.onResetModified();\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexports.AnnotationStorage = AnnotationStorage;\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.apiCompatibilityParams = void 0;\r\n\r\nvar _is_node = __w_pdfjs_require__(4);\r\n\r\nconst compatibilityParams = Object.create(null);\r\n{\r\n  (function checkFontFace() {\r\n    if (_is_node.isNodeJS) {\r\n      compatibilityParams.disableFontFace = true;\r\n    }\r\n  })();\r\n}\r\nconst apiCompatibilityParams = Object.freeze(compatibilityParams);\r\nexports.apiCompatibilityParams = apiCompatibilityParams;\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.CanvasGraphics = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nvar _pattern_helper = __w_pdfjs_require__(11);\r\n\r\nconst MIN_FONT_SIZE = 16;\r\nconst MAX_FONT_SIZE = 100;\r\nconst MAX_GROUP_SIZE = 4096;\r\nconst COMPILE_TYPE3_GLYPHS = true;\r\nconst MAX_SIZE_TO_COMPILE = 1000;\r\nconst FULL_CHUNK_HEIGHT = 16;\r\n\r\nfunction addContextCurrentTransform(ctx) {\r\n  if (!ctx.mozCurrentTransform) {\r\n    ctx._originalSave = ctx.save;\r\n    ctx._originalRestore = ctx.restore;\r\n    ctx._originalRotate = ctx.rotate;\r\n    ctx._originalScale = ctx.scale;\r\n    ctx._originalTranslate = ctx.translate;\r\n    ctx._originalTransform = ctx.transform;\r\n    ctx._originalSetTransform = ctx.setTransform;\r\n    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\r\n    ctx._transformStack = [];\r\n    Object.defineProperty(ctx, \"mozCurrentTransform\", {\r\n      get: function getCurrentTransform() {\r\n        return this._transformMatrix;\r\n      }\r\n    });\r\n    Object.defineProperty(ctx, \"mozCurrentTransformInverse\", {\r\n      get: function getCurrentTransformInverse() {\r\n        const m = this._transformMatrix;\r\n        const a = m[0],\r\n              b = m[1],\r\n              c = m[2],\r\n              d = m[3],\r\n              e = m[4],\r\n              f = m[5];\r\n        const ad_bc = a * d - b * c;\r\n        const bc_ad = b * c - a * d;\r\n        return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];\r\n      }\r\n    });\r\n\r\n    ctx.save = function ctxSave() {\r\n      const old = this._transformMatrix;\r\n\r\n      this._transformStack.push(old);\r\n\r\n      this._transformMatrix = old.slice(0, 6);\r\n\r\n      this._originalSave();\r\n    };\r\n\r\n    ctx.restore = function ctxRestore() {\r\n      const prev = this._transformStack.pop();\r\n\r\n      if (prev) {\r\n        this._transformMatrix = prev;\r\n\r\n        this._originalRestore();\r\n      }\r\n    };\r\n\r\n    ctx.translate = function ctxTranslate(x, y) {\r\n      const m = this._transformMatrix;\r\n      m[4] = m[0] * x + m[2] * y + m[4];\r\n      m[5] = m[1] * x + m[3] * y + m[5];\r\n\r\n      this._originalTranslate(x, y);\r\n    };\r\n\r\n    ctx.scale = function ctxScale(x, y) {\r\n      const m = this._transformMatrix;\r\n      m[0] = m[0] * x;\r\n      m[1] = m[1] * x;\r\n      m[2] = m[2] * y;\r\n      m[3] = m[3] * y;\r\n\r\n      this._originalScale(x, y);\r\n    };\r\n\r\n    ctx.transform = function ctxTransform(a, b, c, d, e, f) {\r\n      const m = this._transformMatrix;\r\n      this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];\r\n\r\n      ctx._originalTransform(a, b, c, d, e, f);\r\n    };\r\n\r\n    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\r\n      this._transformMatrix = [a, b, c, d, e, f];\r\n\r\n      ctx._originalSetTransform(a, b, c, d, e, f);\r\n    };\r\n\r\n    ctx.rotate = function ctxRotate(angle) {\r\n      const cosValue = Math.cos(angle);\r\n      const sinValue = Math.sin(angle);\r\n      const m = this._transformMatrix;\r\n      this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];\r\n\r\n      this._originalRotate(angle);\r\n    };\r\n  }\r\n}\r\n\r\nconst CachedCanvases = function CachedCanvasesClosure() {\r\n  function CachedCanvases(canvasFactory) {\r\n    this.canvasFactory = canvasFactory;\r\n    this.cache = Object.create(null);\r\n  }\r\n\r\n  CachedCanvases.prototype = {\r\n    getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {\r\n      let canvasEntry;\r\n\r\n      if (this.cache[id] !== undefined) {\r\n        canvasEntry = this.cache[id];\r\n        this.canvasFactory.reset(canvasEntry, width, height);\r\n        canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\r\n      } else {\r\n        canvasEntry = this.canvasFactory.create(width, height);\r\n        this.cache[id] = canvasEntry;\r\n      }\r\n\r\n      if (trackTransform) {\r\n        addContextCurrentTransform(canvasEntry.context);\r\n      }\r\n\r\n      return canvasEntry;\r\n    },\r\n\r\n    clear() {\r\n      for (const id in this.cache) {\r\n        const canvasEntry = this.cache[id];\r\n        this.canvasFactory.destroy(canvasEntry);\r\n        delete this.cache[id];\r\n      }\r\n    }\r\n\r\n  };\r\n  return CachedCanvases;\r\n}();\r\n\r\nfunction compileType3Glyph(imgData) {\r\n  const POINT_TO_PROCESS_LIMIT = 1000;\r\n  const width = imgData.width,\r\n        height = imgData.height,\r\n        width1 = width + 1;\r\n  let i, ii, j, j0;\r\n  const points = new Uint8Array(width1 * (height + 1));\r\n  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\r\n  const lineSize = width + 7 & ~7,\r\n        data0 = imgData.data;\r\n  const data = new Uint8Array(lineSize * height);\r\n  let pos = 0;\r\n\r\n  for (i = 0, ii = data0.length; i < ii; i++) {\r\n    const elem = data0[i];\r\n    let mask = 128;\r\n\r\n    while (mask > 0) {\r\n      data[pos++] = elem & mask ? 0 : 255;\r\n      mask >>= 1;\r\n    }\r\n  }\r\n\r\n  let count = 0;\r\n  pos = 0;\r\n\r\n  if (data[pos] !== 0) {\r\n    points[0] = 1;\r\n    ++count;\r\n  }\r\n\r\n  for (j = 1; j < width; j++) {\r\n    if (data[pos] !== data[pos + 1]) {\r\n      points[j] = data[pos] ? 2 : 1;\r\n      ++count;\r\n    }\r\n\r\n    pos++;\r\n  }\r\n\r\n  if (data[pos] !== 0) {\r\n    points[j] = 2;\r\n    ++count;\r\n  }\r\n\r\n  for (i = 1; i < height; i++) {\r\n    pos = i * lineSize;\r\n    j0 = i * width1;\r\n\r\n    if (data[pos - lineSize] !== data[pos]) {\r\n      points[j0] = data[pos] ? 1 : 8;\r\n      ++count;\r\n    }\r\n\r\n    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\r\n\r\n    for (j = 1; j < width; j++) {\r\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\r\n\r\n      if (POINT_TYPES[sum]) {\r\n        points[j0 + j] = POINT_TYPES[sum];\r\n        ++count;\r\n      }\r\n\r\n      pos++;\r\n    }\r\n\r\n    if (data[pos - lineSize] !== data[pos]) {\r\n      points[j0 + j] = data[pos] ? 2 : 4;\r\n      ++count;\r\n    }\r\n\r\n    if (count > POINT_TO_PROCESS_LIMIT) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  pos = lineSize * (height - 1);\r\n  j0 = i * width1;\r\n\r\n  if (data[pos] !== 0) {\r\n    points[j0] = 8;\r\n    ++count;\r\n  }\r\n\r\n  for (j = 1; j < width; j++) {\r\n    if (data[pos] !== data[pos + 1]) {\r\n      points[j0 + j] = data[pos] ? 4 : 8;\r\n      ++count;\r\n    }\r\n\r\n    pos++;\r\n  }\r\n\r\n  if (data[pos] !== 0) {\r\n    points[j0 + j] = 4;\r\n    ++count;\r\n  }\r\n\r\n  if (count > POINT_TO_PROCESS_LIMIT) {\r\n    return null;\r\n  }\r\n\r\n  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\r\n  const outlines = [];\r\n\r\n  for (i = 0; count && i <= height; i++) {\r\n    let p = i * width1;\r\n    const end = p + width;\r\n\r\n    while (p < end && !points[p]) {\r\n      p++;\r\n    }\r\n\r\n    if (p === end) {\r\n      continue;\r\n    }\r\n\r\n    const coords = [p % width1, i];\r\n    const p0 = p;\r\n    let type = points[p];\r\n\r\n    do {\r\n      const step = steps[type];\r\n\r\n      do {\r\n        p += step;\r\n      } while (!points[p]);\r\n\r\n      const pp = points[p];\r\n\r\n      if (pp !== 5 && pp !== 10) {\r\n        type = pp;\r\n        points[p] = 0;\r\n      } else {\r\n        type = pp & 0x33 * type >> 4;\r\n        points[p] &= type >> 2 | type << 2;\r\n      }\r\n\r\n      coords.push(p % width1);\r\n      coords.push(p / width1 | 0);\r\n\r\n      if (!points[p]) {\r\n        --count;\r\n      }\r\n    } while (p0 !== p);\r\n\r\n    outlines.push(coords);\r\n    --i;\r\n  }\r\n\r\n  const drawOutline = function (c) {\r\n    c.save();\r\n    c.scale(1 / width, -1 / height);\r\n    c.translate(0, -height);\r\n    c.beginPath();\r\n\r\n    for (let k = 0, kk = outlines.length; k < kk; k++) {\r\n      const o = outlines[k];\r\n      c.moveTo(o[0], o[1]);\r\n\r\n      for (let l = 2, ll = o.length; l < ll; l += 2) {\r\n        c.lineTo(o[l], o[l + 1]);\r\n      }\r\n    }\r\n\r\n    c.fill();\r\n    c.beginPath();\r\n    c.restore();\r\n  };\r\n\r\n  return drawOutline;\r\n}\r\n\r\nconst CanvasExtraState = function CanvasExtraStateClosure() {\r\n  function CanvasExtraState() {\r\n    this.alphaIsShape = false;\r\n    this.fontSize = 0;\r\n    this.fontSizeScale = 1;\r\n    this.textMatrix = _util.IDENTITY_MATRIX;\r\n    this.textMatrixScale = 1;\r\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\r\n    this.leading = 0;\r\n    this.x = 0;\r\n    this.y = 0;\r\n    this.lineX = 0;\r\n    this.lineY = 0;\r\n    this.charSpacing = 0;\r\n    this.wordSpacing = 0;\r\n    this.textHScale = 1;\r\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\r\n    this.textRise = 0;\r\n    this.fillColor = \"#000000\";\r\n    this.strokeColor = \"#000000\";\r\n    this.patternFill = false;\r\n    this.fillAlpha = 1;\r\n    this.strokeAlpha = 1;\r\n    this.lineWidth = 1;\r\n    this.activeSMask = null;\r\n    this.resumeSMaskCtx = null;\r\n    this.transferMaps = null;\r\n  }\r\n\r\n  CanvasExtraState.prototype = {\r\n    clone: function CanvasExtraState_clone() {\r\n      return Object.create(this);\r\n    },\r\n    setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n  };\r\n  return CanvasExtraState;\r\n}();\r\n\r\nconst CanvasGraphics = function CanvasGraphicsClosure() {\r\n  const EXECUTION_TIME = 15;\r\n  const EXECUTION_STEPS = 10;\r\n\r\n  function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer, optionalContentConfig) {\r\n    this.ctx = canvasCtx;\r\n    this.current = new CanvasExtraState();\r\n    this.stateStack = [];\r\n    this.pendingClip = null;\r\n    this.pendingEOFill = false;\r\n    this.res = null;\r\n    this.xobjs = null;\r\n    this.commonObjs = commonObjs;\r\n    this.objs = objs;\r\n    this.canvasFactory = canvasFactory;\r\n    this.webGLContext = webGLContext;\r\n    this.imageLayer = imageLayer;\r\n    this.groupStack = [];\r\n    this.processingType3 = null;\r\n    this.baseTransform = null;\r\n    this.baseTransformStack = [];\r\n    this.groupLevel = 0;\r\n    this.smaskStack = [];\r\n    this.smaskCounter = 0;\r\n    this.tempSMask = null;\r\n    this.contentVisible = true;\r\n    this.markedContentStack = [];\r\n    this.optionalContentConfig = optionalContentConfig;\r\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\r\n\r\n    if (canvasCtx) {\r\n      addContextCurrentTransform(canvasCtx);\r\n    }\r\n\r\n    this._cachedGetSinglePixelWidth = null;\r\n  }\r\n\r\n  function putBinaryImageData(ctx, imgData, transferMaps = null) {\r\n    if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\r\n      ctx.putImageData(imgData, 0, 0);\r\n      return;\r\n    }\r\n\r\n    const height = imgData.height,\r\n          width = imgData.width;\r\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\r\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\r\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\r\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\r\n    let srcPos = 0,\r\n        destPos;\r\n    const src = imgData.data;\r\n    const dest = chunkImgData.data;\r\n    let i, j, thisChunkHeight, elemsInThisChunk;\r\n    let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;\r\n\r\n    if (transferMaps) {\r\n      switch (transferMaps.length) {\r\n        case 1:\r\n          transferMapRed = transferMaps[0];\r\n          transferMapGreen = transferMaps[0];\r\n          transferMapBlue = transferMaps[0];\r\n          transferMapGray = transferMaps[0];\r\n          break;\r\n\r\n        case 4:\r\n          transferMapRed = transferMaps[0];\r\n          transferMapGreen = transferMaps[1];\r\n          transferMapBlue = transferMaps[2];\r\n          transferMapGray = transferMaps[3];\r\n          break;\r\n      }\r\n    }\r\n\r\n    if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\r\n      const srcLength = src.byteLength;\r\n      const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\r\n      const dest32DataLength = dest32.length;\r\n      const fullSrcDiff = width + 7 >> 3;\r\n      let white = 0xffffffff;\r\n      let black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;\r\n\r\n      if (transferMapGray) {\r\n        if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {\r\n          [white, black] = [black, white];\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < totalChunks; i++) {\r\n        thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\r\n        destPos = 0;\r\n\r\n        for (j = 0; j < thisChunkHeight; j++) {\r\n          const srcDiff = srcLength - srcPos;\r\n          let k = 0;\r\n          const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\r\n          const kEndUnrolled = kEnd & ~7;\r\n          let mask = 0;\r\n          let srcByte = 0;\r\n\r\n          for (; k < kEndUnrolled; k += 8) {\r\n            srcByte = src[srcPos++];\r\n            dest32[destPos++] = srcByte & 128 ? white : black;\r\n            dest32[destPos++] = srcByte & 64 ? white : black;\r\n            dest32[destPos++] = srcByte & 32 ? white : black;\r\n            dest32[destPos++] = srcByte & 16 ? white : black;\r\n            dest32[destPos++] = srcByte & 8 ? white : black;\r\n            dest32[destPos++] = srcByte & 4 ? white : black;\r\n            dest32[destPos++] = srcByte & 2 ? white : black;\r\n            dest32[destPos++] = srcByte & 1 ? white : black;\r\n          }\r\n\r\n          for (; k < kEnd; k++) {\r\n            if (mask === 0) {\r\n              srcByte = src[srcPos++];\r\n              mask = 128;\r\n            }\r\n\r\n            dest32[destPos++] = srcByte & mask ? white : black;\r\n            mask >>= 1;\r\n          }\r\n        }\r\n\r\n        while (destPos < dest32DataLength) {\r\n          dest32[destPos++] = 0;\r\n        }\r\n\r\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\r\n      }\r\n    } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\r\n      const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\r\n      j = 0;\r\n      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\r\n\r\n      for (i = 0; i < fullChunks; i++) {\r\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\r\n        srcPos += elemsInThisChunk;\r\n\r\n        if (hasTransferMaps) {\r\n          for (let k = 0; k < elemsInThisChunk; k += 4) {\r\n            if (transferMapRed) {\r\n              dest[k + 0] = transferMapRed[dest[k + 0]];\r\n            }\r\n\r\n            if (transferMapGreen) {\r\n              dest[k + 1] = transferMapGreen[dest[k + 1]];\r\n            }\r\n\r\n            if (transferMapBlue) {\r\n              dest[k + 2] = transferMapBlue[dest[k + 2]];\r\n            }\r\n          }\r\n        }\r\n\r\n        ctx.putImageData(chunkImgData, 0, j);\r\n        j += FULL_CHUNK_HEIGHT;\r\n      }\r\n\r\n      if (i < totalChunks) {\r\n        elemsInThisChunk = width * partialChunkHeight * 4;\r\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\r\n\r\n        if (hasTransferMaps) {\r\n          for (let k = 0; k < elemsInThisChunk; k += 4) {\r\n            if (transferMapRed) {\r\n              dest[k + 0] = transferMapRed[dest[k + 0]];\r\n            }\r\n\r\n            if (transferMapGreen) {\r\n              dest[k + 1] = transferMapGreen[dest[k + 1]];\r\n            }\r\n\r\n            if (transferMapBlue) {\r\n              dest[k + 2] = transferMapBlue[dest[k + 2]];\r\n            }\r\n          }\r\n        }\r\n\r\n        ctx.putImageData(chunkImgData, 0, j);\r\n      }\r\n    } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\r\n      const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\r\n      thisChunkHeight = FULL_CHUNK_HEIGHT;\r\n      elemsInThisChunk = width * thisChunkHeight;\r\n\r\n      for (i = 0; i < totalChunks; i++) {\r\n        if (i >= fullChunks) {\r\n          thisChunkHeight = partialChunkHeight;\r\n          elemsInThisChunk = width * thisChunkHeight;\r\n        }\r\n\r\n        destPos = 0;\r\n\r\n        for (j = elemsInThisChunk; j--;) {\r\n          dest[destPos++] = src[srcPos++];\r\n          dest[destPos++] = src[srcPos++];\r\n          dest[destPos++] = src[srcPos++];\r\n          dest[destPos++] = 255;\r\n        }\r\n\r\n        if (hasTransferMaps) {\r\n          for (let k = 0; k < destPos; k += 4) {\r\n            if (transferMapRed) {\r\n              dest[k + 0] = transferMapRed[dest[k + 0]];\r\n            }\r\n\r\n            if (transferMapGreen) {\r\n              dest[k + 1] = transferMapGreen[dest[k + 1]];\r\n            }\r\n\r\n            if (transferMapBlue) {\r\n              dest[k + 2] = transferMapBlue[dest[k + 2]];\r\n            }\r\n          }\r\n        }\r\n\r\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\r\n      }\r\n    } else {\r\n      throw new Error(`bad image kind: ${imgData.kind}`);\r\n    }\r\n  }\r\n\r\n  function putBinaryImageMask(ctx, imgData) {\r\n    const height = imgData.height,\r\n          width = imgData.width;\r\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\r\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\r\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\r\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\r\n    let srcPos = 0;\r\n    const src = imgData.data;\r\n    const dest = chunkImgData.data;\r\n\r\n    for (let i = 0; i < totalChunks; i++) {\r\n      const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\r\n      let destPos = 3;\r\n\r\n      for (let j = 0; j < thisChunkHeight; j++) {\r\n        let elem,\r\n            mask = 0;\r\n\r\n        for (let k = 0; k < width; k++) {\r\n          if (!mask) {\r\n            elem = src[srcPos++];\r\n            mask = 128;\r\n          }\r\n\r\n          dest[destPos] = elem & mask ? 0 : 255;\r\n          destPos += 4;\r\n          mask >>= 1;\r\n        }\r\n      }\r\n\r\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\r\n    }\r\n  }\r\n\r\n  function copyCtxState(sourceCtx, destCtx) {\r\n    const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\"];\r\n\r\n    for (let i = 0, ii = properties.length; i < ii; i++) {\r\n      const property = properties[i];\r\n\r\n      if (sourceCtx[property] !== undefined) {\r\n        destCtx[property] = sourceCtx[property];\r\n      }\r\n    }\r\n\r\n    if (sourceCtx.setLineDash !== undefined) {\r\n      destCtx.setLineDash(sourceCtx.getLineDash());\r\n      destCtx.lineDashOffset = sourceCtx.lineDashOffset;\r\n    }\r\n  }\r\n\r\n  function resetCtxToDefault(ctx) {\r\n    ctx.strokeStyle = \"#000000\";\r\n    ctx.fillStyle = \"#000000\";\r\n    ctx.fillRule = \"nonzero\";\r\n    ctx.globalAlpha = 1;\r\n    ctx.lineWidth = 1;\r\n    ctx.lineCap = \"butt\";\r\n    ctx.lineJoin = \"miter\";\r\n    ctx.miterLimit = 10;\r\n    ctx.globalCompositeOperation = \"source-over\";\r\n    ctx.font = \"10px sans-serif\";\r\n\r\n    if (ctx.setLineDash !== undefined) {\r\n      ctx.setLineDash([]);\r\n      ctx.lineDashOffset = 0;\r\n    }\r\n  }\r\n\r\n  function composeSMaskBackdrop(bytes, r0, g0, b0) {\r\n    const length = bytes.length;\r\n\r\n    for (let i = 3; i < length; i += 4) {\r\n      const alpha = bytes[i];\r\n\r\n      if (alpha === 0) {\r\n        bytes[i - 3] = r0;\r\n        bytes[i - 2] = g0;\r\n        bytes[i - 1] = b0;\r\n      } else if (alpha < 255) {\r\n        const alpha_ = 255 - alpha;\r\n        bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\r\n        bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\r\n        bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\r\n      }\r\n    }\r\n  }\r\n\r\n  function composeSMaskAlpha(maskData, layerData, transferMap) {\r\n    const length = maskData.length;\r\n    const scale = 1 / 255;\r\n\r\n    for (let i = 3; i < length; i += 4) {\r\n      const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\r\n      layerData[i] = layerData[i] * alpha * scale | 0;\r\n    }\r\n  }\r\n\r\n  function composeSMaskLuminosity(maskData, layerData, transferMap) {\r\n    const length = maskData.length;\r\n\r\n    for (let i = 3; i < length; i += 4) {\r\n      const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\r\n      layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\r\n    }\r\n  }\r\n\r\n  function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {\r\n    const hasBackdrop = !!backdrop;\r\n    const r0 = hasBackdrop ? backdrop[0] : 0;\r\n    const g0 = hasBackdrop ? backdrop[1] : 0;\r\n    const b0 = hasBackdrop ? backdrop[2] : 0;\r\n    let composeFn;\r\n\r\n    if (subtype === \"Luminosity\") {\r\n      composeFn = composeSMaskLuminosity;\r\n    } else {\r\n      composeFn = composeSMaskAlpha;\r\n    }\r\n\r\n    const PIXELS_TO_PROCESS = 1048576;\r\n    const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\r\n\r\n    for (let row = 0; row < height; row += chunkSize) {\r\n      const chunkHeight = Math.min(chunkSize, height - row);\r\n      const maskData = maskCtx.getImageData(0, row, width, chunkHeight);\r\n      const layerData = layerCtx.getImageData(0, row, width, chunkHeight);\r\n\r\n      if (hasBackdrop) {\r\n        composeSMaskBackdrop(maskData.data, r0, g0, b0);\r\n      }\r\n\r\n      composeFn(maskData.data, layerData.data, transferMap);\r\n      maskCtx.putImageData(layerData, 0, row);\r\n    }\r\n  }\r\n\r\n  function composeSMask(ctx, smask, layerCtx, webGLContext) {\r\n    const mask = smask.canvas;\r\n    const maskCtx = smask.context;\r\n    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);\r\n    const backdrop = smask.backdrop || null;\r\n\r\n    if (!smask.transferMap && webGLContext.isEnabled) {\r\n      const composed = webGLContext.composeSMask({\r\n        layer: layerCtx.canvas,\r\n        mask,\r\n        properties: {\r\n          subtype: smask.subtype,\r\n          backdrop\r\n        }\r\n      });\r\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n      ctx.drawImage(composed, smask.offsetX, smask.offsetY);\r\n      return;\r\n    }\r\n\r\n    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);\r\n    ctx.drawImage(mask, 0, 0);\r\n  }\r\n\r\n  const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\r\n  const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\r\n  const NORMAL_CLIP = {};\r\n  const EO_CLIP = {};\r\n  CanvasGraphics.prototype = {\r\n    beginDrawing({\r\n      transform,\r\n      viewport,\r\n      transparency = false,\r\n      background = null\r\n    }) {\r\n      const width = this.ctx.canvas.width;\r\n      const height = this.ctx.canvas.height;\r\n      this.ctx.save();\r\n      this.ctx.fillStyle = background || \"rgb(255, 255, 255)\";\r\n      this.ctx.fillRect(0, 0, width, height);\r\n      this.ctx.restore();\r\n\r\n      if (transparency) {\r\n        const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height, true);\r\n        this.compositeCtx = this.ctx;\r\n        this.transparentCanvas = transparentCanvas.canvas;\r\n        this.ctx = transparentCanvas.context;\r\n        this.ctx.save();\r\n        this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);\r\n      }\r\n\r\n      this.ctx.save();\r\n      resetCtxToDefault(this.ctx);\r\n\r\n      if (transform) {\r\n        this.ctx.transform.apply(this.ctx, transform);\r\n      }\r\n\r\n      this.ctx.transform.apply(this.ctx, viewport.transform);\r\n      this.baseTransform = this.ctx.mozCurrentTransform.slice();\r\n      this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);\r\n\r\n      if (this.imageLayer) {\r\n        this.imageLayer.beginLayout();\r\n      }\r\n    },\r\n\r\n    executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\r\n      const argsArray = operatorList.argsArray;\r\n      const fnArray = operatorList.fnArray;\r\n      let i = executionStartIdx || 0;\r\n      const argsArrayLen = argsArray.length;\r\n\r\n      if (argsArrayLen === i) {\r\n        return i;\r\n      }\r\n\r\n      const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\r\n      const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\r\n      let steps = 0;\r\n      const commonObjs = this.commonObjs;\r\n      const objs = this.objs;\r\n      let fnId;\r\n\r\n      while (true) {\r\n        if (stepper !== undefined && i === stepper.nextBreakPoint) {\r\n          stepper.breakIt(i, continueCallback);\r\n          return i;\r\n        }\r\n\r\n        fnId = fnArray[i];\r\n\r\n        if (fnId !== _util.OPS.dependency) {\r\n          this[fnId].apply(this, argsArray[i]);\r\n        } else {\r\n          for (const depObjId of argsArray[i]) {\r\n            const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\r\n\r\n            if (!objsPool.has(depObjId)) {\r\n              objsPool.get(depObjId, continueCallback);\r\n              return i;\r\n            }\r\n          }\r\n        }\r\n\r\n        i++;\r\n\r\n        if (i === argsArrayLen) {\r\n          return i;\r\n        }\r\n\r\n        if (chunkOperations && ++steps > EXECUTION_STEPS) {\r\n          if (Date.now() > endTime) {\r\n            continueCallback();\r\n            return i;\r\n          }\r\n\r\n          steps = 0;\r\n        }\r\n      }\r\n    },\r\n    endDrawing: function CanvasGraphics_endDrawing() {\r\n      while (this.stateStack.length || this.current.activeSMask !== null) {\r\n        this.restore();\r\n      }\r\n\r\n      this.ctx.restore();\r\n\r\n      if (this.transparentCanvas) {\r\n        this.ctx = this.compositeCtx;\r\n        this.ctx.save();\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this.ctx.drawImage(this.transparentCanvas, 0, 0);\r\n        this.ctx.restore();\r\n        this.transparentCanvas = null;\r\n      }\r\n\r\n      this.cachedCanvases.clear();\r\n      this.webGLContext.clear();\r\n\r\n      if (this.imageLayer) {\r\n        this.imageLayer.endLayout();\r\n      }\r\n    },\r\n    setLineWidth: function CanvasGraphics_setLineWidth(width) {\r\n      this.current.lineWidth = width;\r\n      this.ctx.lineWidth = width;\r\n    },\r\n    setLineCap: function CanvasGraphics_setLineCap(style) {\r\n      this.ctx.lineCap = LINE_CAP_STYLES[style];\r\n    },\r\n    setLineJoin: function CanvasGraphics_setLineJoin(style) {\r\n      this.ctx.lineJoin = LINE_JOIN_STYLES[style];\r\n    },\r\n    setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {\r\n      this.ctx.miterLimit = limit;\r\n    },\r\n    setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {\r\n      const ctx = this.ctx;\r\n\r\n      if (ctx.setLineDash !== undefined) {\r\n        ctx.setLineDash(dashArray);\r\n        ctx.lineDashOffset = dashPhase;\r\n      }\r\n    },\r\n\r\n    setRenderingIntent(intent) {},\r\n\r\n    setFlatness(flatness) {},\r\n\r\n    setGState: function CanvasGraphics_setGState(states) {\r\n      for (let i = 0, ii = states.length; i < ii; i++) {\r\n        const state = states[i];\r\n        const key = state[0];\r\n        const value = state[1];\r\n\r\n        switch (key) {\r\n          case \"LW\":\r\n            this.setLineWidth(value);\r\n            break;\r\n\r\n          case \"LC\":\r\n            this.setLineCap(value);\r\n            break;\r\n\r\n          case \"LJ\":\r\n            this.setLineJoin(value);\r\n            break;\r\n\r\n          case \"ML\":\r\n            this.setMiterLimit(value);\r\n            break;\r\n\r\n          case \"D\":\r\n            this.setDash(value[0], value[1]);\r\n            break;\r\n\r\n          case \"RI\":\r\n            this.setRenderingIntent(value);\r\n            break;\r\n\r\n          case \"FL\":\r\n            this.setFlatness(value);\r\n            break;\r\n\r\n          case \"Font\":\r\n            this.setFont(value[0], value[1]);\r\n            break;\r\n\r\n          case \"CA\":\r\n            this.current.strokeAlpha = state[1];\r\n            break;\r\n\r\n          case \"ca\":\r\n            this.current.fillAlpha = state[1];\r\n            this.ctx.globalAlpha = state[1];\r\n            break;\r\n\r\n          case \"BM\":\r\n            this.ctx.globalCompositeOperation = value;\r\n            break;\r\n\r\n          case \"SMask\":\r\n            if (this.current.activeSMask) {\r\n              if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {\r\n                this.suspendSMaskGroup();\r\n              } else {\r\n                this.endSMaskGroup();\r\n              }\r\n            }\r\n\r\n            this.current.activeSMask = value ? this.tempSMask : null;\r\n\r\n            if (this.current.activeSMask) {\r\n              this.beginSMaskGroup();\r\n            }\r\n\r\n            this.tempSMask = null;\r\n            break;\r\n\r\n          case \"TR\":\r\n            this.current.transferMaps = value;\r\n        }\r\n      }\r\n    },\r\n    beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {\r\n      const activeSMask = this.current.activeSMask;\r\n      const drawnWidth = activeSMask.canvas.width;\r\n      const drawnHeight = activeSMask.canvas.height;\r\n      const cacheId = \"smaskGroupAt\" + this.groupLevel;\r\n      const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\r\n      const currentCtx = this.ctx;\r\n      const currentTransform = currentCtx.mozCurrentTransform;\r\n      this.ctx.save();\r\n      const groupCtx = scratchCanvas.context;\r\n      groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);\r\n      groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);\r\n      groupCtx.transform.apply(groupCtx, currentTransform);\r\n      activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;\r\n      copyCtxState(currentCtx, groupCtx);\r\n      this.ctx = groupCtx;\r\n      this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\r\n      this.groupStack.push(currentCtx);\r\n      this.groupLevel++;\r\n    },\r\n    suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {\r\n      const groupCtx = this.ctx;\r\n      this.groupLevel--;\r\n      this.ctx = this.groupStack.pop();\r\n      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\r\n      this.ctx.restore();\r\n      this.ctx.save();\r\n      copyCtxState(groupCtx, this.ctx);\r\n      this.current.resumeSMaskCtx = groupCtx;\r\n\r\n      const deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\r\n\r\n      this.ctx.transform.apply(this.ctx, deltaTransform);\r\n      groupCtx.save();\r\n      groupCtx.setTransform(1, 0, 0, 1, 0, 0);\r\n      groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);\r\n      groupCtx.restore();\r\n    },\r\n    resumeSMaskGroup: function CanvasGraphics_resumeSMaskGroup() {\r\n      const groupCtx = this.current.resumeSMaskCtx;\r\n      const currentCtx = this.ctx;\r\n      this.ctx = groupCtx;\r\n      this.groupStack.push(currentCtx);\r\n      this.groupLevel++;\r\n    },\r\n    endSMaskGroup: function CanvasGraphics_endSMaskGroup() {\r\n      const groupCtx = this.ctx;\r\n      this.groupLevel--;\r\n      this.ctx = this.groupStack.pop();\r\n      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\r\n      this.ctx.restore();\r\n      copyCtxState(groupCtx, this.ctx);\r\n\r\n      const deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\r\n\r\n      this.ctx.transform.apply(this.ctx, deltaTransform);\r\n    },\r\n    save: function CanvasGraphics_save() {\r\n      this.ctx.save();\r\n      const old = this.current;\r\n      this.stateStack.push(old);\r\n      this.current = old.clone();\r\n      this.current.resumeSMaskCtx = null;\r\n    },\r\n    restore: function CanvasGraphics_restore() {\r\n      if (this.current.resumeSMaskCtx) {\r\n        this.resumeSMaskGroup();\r\n      }\r\n\r\n      if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {\r\n        this.endSMaskGroup();\r\n      }\r\n\r\n      if (this.stateStack.length !== 0) {\r\n        this.current = this.stateStack.pop();\r\n        this.ctx.restore();\r\n        this.pendingClip = null;\r\n        this._cachedGetSinglePixelWidth = null;\r\n      } else {\r\n        this.current.activeSMask = null;\r\n      }\r\n    },\r\n    transform: function CanvasGraphics_transform(a, b, c, d, e, f) {\r\n      this.ctx.transform(a, b, c, d, e, f);\r\n      this._cachedGetSinglePixelWidth = null;\r\n    },\r\n    constructPath: function CanvasGraphics_constructPath(ops, args) {\r\n      const ctx = this.ctx;\r\n      const current = this.current;\r\n      let x = current.x,\r\n          y = current.y;\r\n\r\n      for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {\r\n        switch (ops[i] | 0) {\r\n          case _util.OPS.rectangle:\r\n            x = args[j++];\r\n            y = args[j++];\r\n            const width = args[j++];\r\n            const height = args[j++];\r\n            const xw = x + width;\r\n            const yh = y + height;\r\n            ctx.moveTo(x, y);\r\n\r\n            if (width === 0 || height === 0) {\r\n              ctx.lineTo(xw, yh);\r\n            } else {\r\n              ctx.lineTo(xw, y);\r\n              ctx.lineTo(xw, yh);\r\n              ctx.lineTo(x, yh);\r\n            }\r\n\r\n            ctx.closePath();\r\n            break;\r\n\r\n          case _util.OPS.moveTo:\r\n            x = args[j++];\r\n            y = args[j++];\r\n            ctx.moveTo(x, y);\r\n            break;\r\n\r\n          case _util.OPS.lineTo:\r\n            x = args[j++];\r\n            y = args[j++];\r\n            ctx.lineTo(x, y);\r\n            break;\r\n\r\n          case _util.OPS.curveTo:\r\n            x = args[j + 4];\r\n            y = args[j + 5];\r\n            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\r\n            j += 6;\r\n            break;\r\n\r\n          case _util.OPS.curveTo2:\r\n            ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\r\n            x = args[j + 2];\r\n            y = args[j + 3];\r\n            j += 4;\r\n            break;\r\n\r\n          case _util.OPS.curveTo3:\r\n            x = args[j + 2];\r\n            y = args[j + 3];\r\n            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\r\n            j += 4;\r\n            break;\r\n\r\n          case _util.OPS.closePath:\r\n            ctx.closePath();\r\n            break;\r\n        }\r\n      }\r\n\r\n      current.setCurrentPoint(x, y);\r\n    },\r\n    closePath: function CanvasGraphics_closePath() {\r\n      this.ctx.closePath();\r\n    },\r\n    stroke: function CanvasGraphics_stroke(consumePath) {\r\n      consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\r\n      const ctx = this.ctx;\r\n      const strokeColor = this.current.strokeColor;\r\n      ctx.globalAlpha = this.current.strokeAlpha;\r\n\r\n      if (this.contentVisible) {\r\n        if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\r\n          ctx.save();\r\n          const transform = ctx.mozCurrentTransform;\r\n\r\n          const scale = _util.Util.singularValueDecompose2dScale(transform)[0];\r\n\r\n          ctx.strokeStyle = strokeColor.getPattern(ctx, this);\r\n          const lineWidth = this.getSinglePixelWidth();\r\n          const scaledLineWidth = this.current.lineWidth * scale;\r\n\r\n          if (lineWidth < 0 && -lineWidth >= scaledLineWidth) {\r\n            ctx.resetTransform();\r\n            ctx.lineWidth = Math.round(this._combinedScaleFactor);\r\n          } else {\r\n            ctx.lineWidth = Math.max(lineWidth, scaledLineWidth);\r\n          }\r\n\r\n          ctx.stroke();\r\n          ctx.restore();\r\n        } else {\r\n          const lineWidth = this.getSinglePixelWidth();\r\n\r\n          if (lineWidth < 0 && -lineWidth >= this.current.lineWidth) {\r\n            ctx.save();\r\n            ctx.resetTransform();\r\n            ctx.lineWidth = Math.round(this._combinedScaleFactor);\r\n            ctx.stroke();\r\n            ctx.restore();\r\n          } else {\r\n            ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);\r\n            ctx.stroke();\r\n          }\r\n        }\r\n      }\r\n\r\n      if (consumePath) {\r\n        this.consumePath();\r\n      }\r\n\r\n      ctx.globalAlpha = this.current.fillAlpha;\r\n    },\r\n    closeStroke: function CanvasGraphics_closeStroke() {\r\n      this.closePath();\r\n      this.stroke();\r\n    },\r\n    fill: function CanvasGraphics_fill(consumePath) {\r\n      consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\r\n      const ctx = this.ctx;\r\n      const fillColor = this.current.fillColor;\r\n      const isPatternFill = this.current.patternFill;\r\n      let needRestore = false;\r\n\r\n      if (isPatternFill) {\r\n        ctx.save();\r\n\r\n        if (this.baseTransform) {\r\n          ctx.setTransform.apply(ctx, this.baseTransform);\r\n        }\r\n\r\n        ctx.fillStyle = fillColor.getPattern(ctx, this);\r\n        needRestore = true;\r\n      }\r\n\r\n      if (this.contentVisible) {\r\n        if (this.pendingEOFill) {\r\n          ctx.fill(\"evenodd\");\r\n          this.pendingEOFill = false;\r\n        } else {\r\n          ctx.fill();\r\n        }\r\n      }\r\n\r\n      if (needRestore) {\r\n        ctx.restore();\r\n      }\r\n\r\n      if (consumePath) {\r\n        this.consumePath();\r\n      }\r\n    },\r\n    eoFill: function CanvasGraphics_eoFill() {\r\n      this.pendingEOFill = true;\r\n      this.fill();\r\n    },\r\n    fillStroke: function CanvasGraphics_fillStroke() {\r\n      this.fill(false);\r\n      this.stroke(false);\r\n      this.consumePath();\r\n    },\r\n    eoFillStroke: function CanvasGraphics_eoFillStroke() {\r\n      this.pendingEOFill = true;\r\n      this.fillStroke();\r\n    },\r\n    closeFillStroke: function CanvasGraphics_closeFillStroke() {\r\n      this.closePath();\r\n      this.fillStroke();\r\n    },\r\n    closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {\r\n      this.pendingEOFill = true;\r\n      this.closePath();\r\n      this.fillStroke();\r\n    },\r\n    endPath: function CanvasGraphics_endPath() {\r\n      this.consumePath();\r\n    },\r\n    clip: function CanvasGraphics_clip() {\r\n      this.pendingClip = NORMAL_CLIP;\r\n    },\r\n    eoClip: function CanvasGraphics_eoClip() {\r\n      this.pendingClip = EO_CLIP;\r\n    },\r\n    beginText: function CanvasGraphics_beginText() {\r\n      this.current.textMatrix = _util.IDENTITY_MATRIX;\r\n      this.current.textMatrixScale = 1;\r\n      this.current.x = this.current.lineX = 0;\r\n      this.current.y = this.current.lineY = 0;\r\n    },\r\n    endText: function CanvasGraphics_endText() {\r\n      const paths = this.pendingTextPaths;\r\n      const ctx = this.ctx;\r\n\r\n      if (paths === undefined) {\r\n        ctx.beginPath();\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n      ctx.beginPath();\r\n\r\n      for (let i = 0; i < paths.length; i++) {\r\n        const path = paths[i];\r\n        ctx.setTransform.apply(ctx, path.transform);\r\n        ctx.translate(path.x, path.y);\r\n        path.addToPath(ctx, path.fontSize);\r\n      }\r\n\r\n      ctx.restore();\r\n      ctx.clip();\r\n      ctx.beginPath();\r\n      delete this.pendingTextPaths;\r\n    },\r\n    setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {\r\n      this.current.charSpacing = spacing;\r\n    },\r\n    setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {\r\n      this.current.wordSpacing = spacing;\r\n    },\r\n    setHScale: function CanvasGraphics_setHScale(scale) {\r\n      this.current.textHScale = scale / 100;\r\n    },\r\n    setLeading: function CanvasGraphics_setLeading(leading) {\r\n      this.current.leading = -leading;\r\n    },\r\n    setFont: function CanvasGraphics_setFont(fontRefName, size) {\r\n      const fontObj = this.commonObjs.get(fontRefName);\r\n      const current = this.current;\r\n\r\n      if (!fontObj) {\r\n        throw new Error(`Can't find font for ${fontRefName}`);\r\n      }\r\n\r\n      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\r\n\r\n      if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\r\n        (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\r\n      }\r\n\r\n      if (size < 0) {\r\n        size = -size;\r\n        current.fontDirection = -1;\r\n      } else {\r\n        current.fontDirection = 1;\r\n      }\r\n\r\n      this.current.font = fontObj;\r\n      this.current.fontSize = size;\r\n\r\n      if (fontObj.isType3Font) {\r\n        return;\r\n      }\r\n\r\n      const name = fontObj.loadedName || \"sans-serif\";\r\n      let bold = \"normal\";\r\n\r\n      if (fontObj.black) {\r\n        bold = \"900\";\r\n      } else if (fontObj.bold) {\r\n        bold = \"bold\";\r\n      }\r\n\r\n      const italic = fontObj.italic ? \"italic\" : \"normal\";\r\n      const typeface = `\"${name}\", ${fontObj.fallbackName}`;\r\n      let browserFontSize = size;\r\n\r\n      if (size < MIN_FONT_SIZE) {\r\n        browserFontSize = MIN_FONT_SIZE;\r\n      } else if (size > MAX_FONT_SIZE) {\r\n        browserFontSize = MAX_FONT_SIZE;\r\n      }\r\n\r\n      this.current.fontSizeScale = size / browserFontSize;\r\n      this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\r\n    },\r\n    setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {\r\n      this.current.textRenderingMode = mode;\r\n    },\r\n    setTextRise: function CanvasGraphics_setTextRise(rise) {\r\n      this.current.textRise = rise;\r\n    },\r\n    moveText: function CanvasGraphics_moveText(x, y) {\r\n      this.current.x = this.current.lineX += x;\r\n      this.current.y = this.current.lineY += y;\r\n    },\r\n    setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {\r\n      this.setLeading(-y);\r\n      this.moveText(x, y);\r\n    },\r\n    setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {\r\n      this.current.textMatrix = [a, b, c, d, e, f];\r\n      this.current.textMatrixScale = Math.sqrt(a * a + b * b);\r\n      this.current.x = this.current.lineX = 0;\r\n      this.current.y = this.current.lineY = 0;\r\n    },\r\n    nextLine: function CanvasGraphics_nextLine() {\r\n      this.moveText(0, this.current.leading);\r\n    },\r\n\r\n    paintChar(character, x, y, patternTransform, resetLineWidthToOne) {\r\n      const ctx = this.ctx;\r\n      const current = this.current;\r\n      const font = current.font;\r\n      const textRenderingMode = current.textRenderingMode;\r\n      const fontSize = current.fontSize / current.fontSizeScale;\r\n      const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\r\n      const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\r\n      const patternFill = current.patternFill && !font.missingFile;\r\n      let addToPath;\r\n\r\n      if (font.disableFontFace || isAddToPathSet || patternFill) {\r\n        addToPath = font.getPathGenerator(this.commonObjs, character);\r\n      }\r\n\r\n      if (font.disableFontFace || patternFill) {\r\n        ctx.save();\r\n        ctx.translate(x, y);\r\n        ctx.beginPath();\r\n        addToPath(ctx, fontSize);\r\n\r\n        if (patternTransform) {\r\n          ctx.setTransform.apply(ctx, patternTransform);\r\n        }\r\n\r\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n          ctx.fill();\r\n        }\r\n\r\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n          if (resetLineWidthToOne) {\r\n            ctx.resetTransform();\r\n            ctx.lineWidth = Math.round(this._combinedScaleFactor);\r\n          }\r\n\r\n          ctx.stroke();\r\n        }\r\n\r\n        ctx.restore();\r\n      } else {\r\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n          ctx.fillText(character, x, y);\r\n        }\r\n\r\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n          if (resetLineWidthToOne) {\r\n            ctx.save();\r\n            ctx.moveTo(x, y);\r\n            ctx.resetTransform();\r\n            ctx.lineWidth = Math.round(this._combinedScaleFactor);\r\n            ctx.strokeText(character, 0, 0);\r\n            ctx.restore();\r\n          } else {\r\n            ctx.strokeText(character, x, y);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (isAddToPathSet) {\r\n        const paths = this.pendingTextPaths || (this.pendingTextPaths = []);\r\n        paths.push({\r\n          transform: ctx.mozCurrentTransform,\r\n          x,\r\n          y,\r\n          fontSize,\r\n          addToPath\r\n        });\r\n      }\r\n    },\r\n\r\n    get isFontSubpixelAAEnabled() {\r\n      const {\r\n        context: ctx\r\n      } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\r\n      ctx.scale(1.5, 1);\r\n      ctx.fillText(\"I\", 0, 10);\r\n      const data = ctx.getImageData(0, 0, 10, 10).data;\r\n      let enabled = false;\r\n\r\n      for (let i = 3; i < data.length; i += 4) {\r\n        if (data[i] > 0 && data[i] < 255) {\r\n          enabled = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\r\n    },\r\n\r\n    showText: function CanvasGraphics_showText(glyphs) {\r\n      const current = this.current;\r\n      const font = current.font;\r\n\r\n      if (font.isType3Font) {\r\n        return this.showType3Text(glyphs);\r\n      }\r\n\r\n      const fontSize = current.fontSize;\r\n\r\n      if (fontSize === 0) {\r\n        return undefined;\r\n      }\r\n\r\n      const ctx = this.ctx;\r\n      const fontSizeScale = current.fontSizeScale;\r\n      const charSpacing = current.charSpacing;\r\n      const wordSpacing = current.wordSpacing;\r\n      const fontDirection = current.fontDirection;\r\n      const textHScale = current.textHScale * fontDirection;\r\n      const glyphsLength = glyphs.length;\r\n      const vertical = font.vertical;\r\n      const spacingDir = vertical ? 1 : -1;\r\n      const defaultVMetrics = font.defaultVMetrics;\r\n      const widthAdvanceScale = fontSize * current.fontMatrix[0];\r\n      const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\r\n      ctx.save();\r\n      let patternTransform;\r\n\r\n      if (current.patternFill) {\r\n        ctx.save();\r\n        const pattern = current.fillColor.getPattern(ctx, this);\r\n        patternTransform = ctx.mozCurrentTransform;\r\n        ctx.restore();\r\n        ctx.fillStyle = pattern;\r\n      }\r\n\r\n      ctx.transform.apply(ctx, current.textMatrix);\r\n      ctx.translate(current.x, current.y + current.textRise);\r\n\r\n      if (fontDirection > 0) {\r\n        ctx.scale(textHScale, -1);\r\n      } else {\r\n        ctx.scale(textHScale, 1);\r\n      }\r\n\r\n      let lineWidth = current.lineWidth;\r\n      let resetLineWidthToOne = false;\r\n      const scale = current.textMatrixScale;\r\n\r\n      if (scale === 0 || lineWidth === 0) {\r\n        const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\r\n\r\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n          this._cachedGetSinglePixelWidth = null;\r\n          lineWidth = this.getSinglePixelWidth();\r\n          resetLineWidthToOne = lineWidth < 0;\r\n        }\r\n      } else {\r\n        lineWidth /= scale;\r\n      }\r\n\r\n      if (fontSizeScale !== 1.0) {\r\n        ctx.scale(fontSizeScale, fontSizeScale);\r\n        lineWidth /= fontSizeScale;\r\n      }\r\n\r\n      ctx.lineWidth = lineWidth;\r\n      let x = 0,\r\n          i;\r\n\r\n      for (i = 0; i < glyphsLength; ++i) {\r\n        const glyph = glyphs[i];\r\n\r\n        if ((0, _util.isNum)(glyph)) {\r\n          x += spacingDir * glyph * fontSize / 1000;\r\n          continue;\r\n        }\r\n\r\n        let restoreNeeded = false;\r\n        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\r\n        const character = glyph.fontChar;\r\n        const accent = glyph.accent;\r\n        let scaledX, scaledY;\r\n        let width = glyph.width;\r\n\r\n        if (vertical) {\r\n          const vmetric = glyph.vmetric || defaultVMetrics;\r\n          const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\r\n          const vy = vmetric[2] * widthAdvanceScale;\r\n          width = vmetric ? -vmetric[0] : width;\r\n          scaledX = vx / fontSizeScale;\r\n          scaledY = (x + vy) / fontSizeScale;\r\n        } else {\r\n          scaledX = x / fontSizeScale;\r\n          scaledY = 0;\r\n        }\r\n\r\n        if (font.remeasure && width > 0) {\r\n          const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\r\n\r\n          if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\r\n            const characterScaleX = width / measuredWidth;\r\n            restoreNeeded = true;\r\n            ctx.save();\r\n            ctx.scale(characterScaleX, 1);\r\n            scaledX /= characterScaleX;\r\n          } else if (width !== measuredWidth) {\r\n            scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\r\n          }\r\n        }\r\n\r\n        if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\r\n          if (simpleFillText && !accent) {\r\n            ctx.fillText(character, scaledX, scaledY);\r\n          } else {\r\n            this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);\r\n\r\n            if (accent) {\r\n              const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\r\n              const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\r\n              this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);\r\n            }\r\n          }\r\n        }\r\n\r\n        let charWidth;\r\n\r\n        if (vertical) {\r\n          charWidth = width * widthAdvanceScale - spacing * fontDirection;\r\n        } else {\r\n          charWidth = width * widthAdvanceScale + spacing * fontDirection;\r\n        }\r\n\r\n        x += charWidth;\r\n\r\n        if (restoreNeeded) {\r\n          ctx.restore();\r\n        }\r\n      }\r\n\r\n      if (vertical) {\r\n        current.y -= x;\r\n      } else {\r\n        current.x += x * textHScale;\r\n      }\r\n\r\n      ctx.restore();\r\n    },\r\n    showType3Text: function CanvasGraphics_showType3Text(glyphs) {\r\n      const ctx = this.ctx;\r\n      const current = this.current;\r\n      const font = current.font;\r\n      const fontSize = current.fontSize;\r\n      const fontDirection = current.fontDirection;\r\n      const spacingDir = font.vertical ? 1 : -1;\r\n      const charSpacing = current.charSpacing;\r\n      const wordSpacing = current.wordSpacing;\r\n      const textHScale = current.textHScale * fontDirection;\r\n      const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\r\n      const glyphsLength = glyphs.length;\r\n      const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\r\n      let i, glyph, width, spacingLength;\r\n\r\n      if (isTextInvisible || fontSize === 0) {\r\n        return;\r\n      }\r\n\r\n      this._cachedGetSinglePixelWidth = null;\r\n      ctx.save();\r\n      ctx.transform.apply(ctx, current.textMatrix);\r\n      ctx.translate(current.x, current.y);\r\n      ctx.scale(textHScale, fontDirection);\r\n\r\n      for (i = 0; i < glyphsLength; ++i) {\r\n        glyph = glyphs[i];\r\n\r\n        if ((0, _util.isNum)(glyph)) {\r\n          spacingLength = spacingDir * glyph * fontSize / 1000;\r\n          this.ctx.translate(spacingLength, 0);\r\n          current.x += spacingLength * textHScale;\r\n          continue;\r\n        }\r\n\r\n        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\r\n        const operatorList = font.charProcOperatorList[glyph.operatorListId];\r\n\r\n        if (!operatorList) {\r\n          (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\r\n          continue;\r\n        }\r\n\r\n        if (this.contentVisible) {\r\n          this.processingType3 = glyph;\r\n          this.save();\r\n          ctx.scale(fontSize, fontSize);\r\n          ctx.transform.apply(ctx, fontMatrix);\r\n          this.executeOperatorList(operatorList);\r\n          this.restore();\r\n        }\r\n\r\n        const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\r\n\r\n        width = transformed[0] * fontSize + spacing;\r\n        ctx.translate(width, 0);\r\n        current.x += width * textHScale;\r\n      }\r\n\r\n      ctx.restore();\r\n      this.processingType3 = null;\r\n    },\r\n    setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},\r\n    setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\r\n      this.ctx.rect(llx, lly, urx - llx, ury - lly);\r\n      this.clip();\r\n      this.endPath();\r\n    },\r\n    getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {\r\n      let pattern;\r\n\r\n      if (IR[0] === \"TilingPattern\") {\r\n        const color = IR[1];\r\n        const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();\r\n        const canvasGraphicsFactory = {\r\n          createCanvasGraphics: ctx => {\r\n            return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext);\r\n          }\r\n        };\r\n        pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\r\n      } else {\r\n        pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);\r\n      }\r\n\r\n      return pattern;\r\n    },\r\n    setStrokeColorN: function CanvasGraphics_setStrokeColorN() {\r\n      this.current.strokeColor = this.getColorN_Pattern(arguments);\r\n    },\r\n    setFillColorN: function CanvasGraphics_setFillColorN() {\r\n      this.current.fillColor = this.getColorN_Pattern(arguments);\r\n      this.current.patternFill = true;\r\n    },\r\n    setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {\r\n      const color = _util.Util.makeHexColor(r, g, b);\r\n\r\n      this.ctx.strokeStyle = color;\r\n      this.current.strokeColor = color;\r\n    },\r\n    setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {\r\n      const color = _util.Util.makeHexColor(r, g, b);\r\n\r\n      this.ctx.fillStyle = color;\r\n      this.current.fillColor = color;\r\n      this.current.patternFill = false;\r\n    },\r\n    shadingFill: function CanvasGraphics_shadingFill(patternIR) {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      const ctx = this.ctx;\r\n      this.save();\r\n      const pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);\r\n      ctx.fillStyle = pattern.getPattern(ctx, this, true);\r\n      const inv = ctx.mozCurrentTransformInverse;\r\n\r\n      if (inv) {\r\n        const canvas = ctx.canvas;\r\n        const width = canvas.width;\r\n        const height = canvas.height;\r\n\r\n        const bl = _util.Util.applyTransform([0, 0], inv);\r\n\r\n        const br = _util.Util.applyTransform([0, height], inv);\r\n\r\n        const ul = _util.Util.applyTransform([width, 0], inv);\r\n\r\n        const ur = _util.Util.applyTransform([width, height], inv);\r\n\r\n        const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\r\n        const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\r\n        const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\r\n        const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\r\n        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\r\n      } else {\r\n        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\r\n      }\r\n\r\n      this.restore();\r\n    },\r\n    beginInlineImage: function CanvasGraphics_beginInlineImage() {\r\n      (0, _util.unreachable)(\"Should not call beginInlineImage\");\r\n    },\r\n    beginImageData: function CanvasGraphics_beginImageData() {\r\n      (0, _util.unreachable)(\"Should not call beginImageData\");\r\n    },\r\n    paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      this.save();\r\n      this.baseTransformStack.push(this.baseTransform);\r\n\r\n      if (Array.isArray(matrix) && matrix.length === 6) {\r\n        this.transform.apply(this, matrix);\r\n      }\r\n\r\n      this.baseTransform = this.ctx.mozCurrentTransform;\r\n\r\n      if (bbox) {\r\n        const width = bbox[2] - bbox[0];\r\n        const height = bbox[3] - bbox[1];\r\n        this.ctx.rect(bbox[0], bbox[1], width, height);\r\n        this.clip();\r\n        this.endPath();\r\n      }\r\n    },\r\n    paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      this.restore();\r\n      this.baseTransform = this.baseTransformStack.pop();\r\n    },\r\n    beginGroup: function CanvasGraphics_beginGroup(group) {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      this.save();\r\n      const currentCtx = this.ctx;\r\n\r\n      if (!group.isolated) {\r\n        (0, _util.info)(\"TODO: Support non-isolated groups.\");\r\n      }\r\n\r\n      if (group.knockout) {\r\n        (0, _util.warn)(\"Knockout groups not supported.\");\r\n      }\r\n\r\n      const currentTransform = currentCtx.mozCurrentTransform;\r\n\r\n      if (group.matrix) {\r\n        currentCtx.transform.apply(currentCtx, group.matrix);\r\n      }\r\n\r\n      if (!group.bbox) {\r\n        throw new Error(\"Bounding box is required.\");\r\n      }\r\n\r\n      let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);\r\n\r\n      const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\r\n      bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\r\n      const offsetX = Math.floor(bounds[0]);\r\n      const offsetY = Math.floor(bounds[1]);\r\n      let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\r\n      let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\r\n      let scaleX = 1,\r\n          scaleY = 1;\r\n\r\n      if (drawnWidth > MAX_GROUP_SIZE) {\r\n        scaleX = drawnWidth / MAX_GROUP_SIZE;\r\n        drawnWidth = MAX_GROUP_SIZE;\r\n      }\r\n\r\n      if (drawnHeight > MAX_GROUP_SIZE) {\r\n        scaleY = drawnHeight / MAX_GROUP_SIZE;\r\n        drawnHeight = MAX_GROUP_SIZE;\r\n      }\r\n\r\n      let cacheId = \"groupAt\" + this.groupLevel;\r\n\r\n      if (group.smask) {\r\n        cacheId += \"_smask_\" + this.smaskCounter++ % 2;\r\n      }\r\n\r\n      const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\r\n      const groupCtx = scratchCanvas.context;\r\n      groupCtx.scale(1 / scaleX, 1 / scaleY);\r\n      groupCtx.translate(-offsetX, -offsetY);\r\n      groupCtx.transform.apply(groupCtx, currentTransform);\r\n\r\n      if (group.smask) {\r\n        this.smaskStack.push({\r\n          canvas: scratchCanvas.canvas,\r\n          context: groupCtx,\r\n          offsetX,\r\n          offsetY,\r\n          scaleX,\r\n          scaleY,\r\n          subtype: group.smask.subtype,\r\n          backdrop: group.smask.backdrop,\r\n          transferMap: group.smask.transferMap || null,\r\n          startTransformInverse: null\r\n        });\r\n      } else {\r\n        currentCtx.setTransform(1, 0, 0, 1, 0, 0);\r\n        currentCtx.translate(offsetX, offsetY);\r\n        currentCtx.scale(scaleX, scaleY);\r\n      }\r\n\r\n      copyCtxState(currentCtx, groupCtx);\r\n      this.ctx = groupCtx;\r\n      this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\r\n      this.groupStack.push(currentCtx);\r\n      this.groupLevel++;\r\n      this.current.activeSMask = null;\r\n    },\r\n    endGroup: function CanvasGraphics_endGroup(group) {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      this.groupLevel--;\r\n      const groupCtx = this.ctx;\r\n      this.ctx = this.groupStack.pop();\r\n\r\n      if (this.ctx.imageSmoothingEnabled !== undefined) {\r\n        this.ctx.imageSmoothingEnabled = false;\r\n      } else {\r\n        this.ctx.mozImageSmoothingEnabled = false;\r\n      }\r\n\r\n      if (group.smask) {\r\n        this.tempSMask = this.smaskStack.pop();\r\n      } else {\r\n        this.ctx.drawImage(groupCtx.canvas, 0, 0);\r\n      }\r\n\r\n      this.restore();\r\n    },\r\n    beginAnnotations: function CanvasGraphics_beginAnnotations() {\r\n      this.save();\r\n\r\n      if (this.baseTransform) {\r\n        this.ctx.setTransform.apply(this.ctx, this.baseTransform);\r\n      }\r\n    },\r\n    endAnnotations: function CanvasGraphics_endAnnotations() {\r\n      this.restore();\r\n    },\r\n    beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {\r\n      this.save();\r\n      resetCtxToDefault(this.ctx);\r\n      this.current = new CanvasExtraState();\r\n\r\n      if (Array.isArray(rect) && rect.length === 4) {\r\n        const width = rect[2] - rect[0];\r\n        const height = rect[3] - rect[1];\r\n        this.ctx.rect(rect[0], rect[1], width, height);\r\n        this.clip();\r\n        this.endPath();\r\n      }\r\n\r\n      this.transform.apply(this, transform);\r\n      this.transform.apply(this, matrix);\r\n    },\r\n    endAnnotation: function CanvasGraphics_endAnnotation() {\r\n      this.restore();\r\n    },\r\n    paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      const ctx = this.ctx;\r\n      const width = img.width,\r\n            height = img.height;\r\n      const fillColor = this.current.fillColor;\r\n      const isPatternFill = this.current.patternFill;\r\n      const glyph = this.processingType3;\r\n\r\n      if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\r\n        if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\r\n          glyph.compiled = compileType3Glyph({\r\n            data: img.data,\r\n            width,\r\n            height\r\n          });\r\n        } else {\r\n          glyph.compiled = null;\r\n        }\r\n      }\r\n\r\n      if (glyph?.compiled) {\r\n        glyph.compiled(ctx);\r\n        return;\r\n      }\r\n\r\n      const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\r\n      const maskCtx = maskCanvas.context;\r\n      maskCtx.save();\r\n      putBinaryImageMask(maskCtx, img);\r\n      maskCtx.globalCompositeOperation = \"source-in\";\r\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\r\n      maskCtx.fillRect(0, 0, width, height);\r\n      maskCtx.restore();\r\n      this.paintInlineImageXObject(maskCanvas.canvas);\r\n    },\r\n\r\n    paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      const width = imgData.width;\r\n      const height = imgData.height;\r\n      const fillColor = this.current.fillColor;\r\n      const isPatternFill = this.current.patternFill;\r\n      const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\r\n      const maskCtx = maskCanvas.context;\r\n      maskCtx.save();\r\n      putBinaryImageMask(maskCtx, imgData);\r\n      maskCtx.globalCompositeOperation = \"source-in\";\r\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\r\n      maskCtx.fillRect(0, 0, width, height);\r\n      maskCtx.restore();\r\n      const ctx = this.ctx;\r\n\r\n      for (let i = 0, ii = positions.length; i < ii; i += 2) {\r\n        ctx.save();\r\n        ctx.transform(scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]);\r\n        ctx.scale(1, -1);\r\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\r\n        ctx.restore();\r\n      }\r\n    },\r\n\r\n    paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      const ctx = this.ctx;\r\n      const fillColor = this.current.fillColor;\r\n      const isPatternFill = this.current.patternFill;\r\n\r\n      for (let i = 0, ii = images.length; i < ii; i++) {\r\n        const image = images[i];\r\n        const width = image.width,\r\n              height = image.height;\r\n        const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\r\n        const maskCtx = maskCanvas.context;\r\n        maskCtx.save();\r\n        putBinaryImageMask(maskCtx, image);\r\n        maskCtx.globalCompositeOperation = \"source-in\";\r\n        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\r\n        maskCtx.fillRect(0, 0, width, height);\r\n        maskCtx.restore();\r\n        ctx.save();\r\n        ctx.transform.apply(ctx, image.transform);\r\n        ctx.scale(1, -1);\r\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\r\n        ctx.restore();\r\n      }\r\n    },\r\n    paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\r\n\r\n      if (!imgData) {\r\n        (0, _util.warn)(\"Dependent image isn't ready yet\");\r\n        return;\r\n      }\r\n\r\n      this.paintInlineImageXObject(imgData);\r\n    },\r\n    paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\r\n\r\n      if (!imgData) {\r\n        (0, _util.warn)(\"Dependent image isn't ready yet\");\r\n        return;\r\n      }\r\n\r\n      const width = imgData.width;\r\n      const height = imgData.height;\r\n      const map = [];\r\n\r\n      for (let i = 0, ii = positions.length; i < ii; i += 2) {\r\n        map.push({\r\n          transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\r\n          x: 0,\r\n          y: 0,\r\n          w: width,\r\n          h: height\r\n        });\r\n      }\r\n\r\n      this.paintInlineImageXObjectGroup(imgData, map);\r\n    },\r\n    paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      const width = imgData.width;\r\n      const height = imgData.height;\r\n      const ctx = this.ctx;\r\n      this.save();\r\n      ctx.scale(1 / width, -1 / height);\r\n      const currentTransform = ctx.mozCurrentTransformInverse;\r\n      const a = currentTransform[0],\r\n            b = currentTransform[1];\r\n      let widthScale = Math.max(Math.sqrt(a * a + b * b), 1);\r\n      const c = currentTransform[2],\r\n            d = currentTransform[3];\r\n      let heightScale = Math.max(Math.sqrt(c * c + d * d), 1);\r\n      let imgToPaint, tmpCanvas, tmpCtx;\r\n\r\n      if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\r\n        imgToPaint = imgData;\r\n      } else {\r\n        tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\r\n        tmpCtx = tmpCanvas.context;\r\n        putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\r\n        imgToPaint = tmpCanvas.canvas;\r\n      }\r\n\r\n      let paintWidth = width,\r\n          paintHeight = height;\r\n      let tmpCanvasId = \"prescale1\";\r\n\r\n      while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\r\n        let newWidth = paintWidth,\r\n            newHeight = paintHeight;\r\n\r\n        if (widthScale > 2 && paintWidth > 1) {\r\n          newWidth = Math.ceil(paintWidth / 2);\r\n          widthScale /= paintWidth / newWidth;\r\n        }\r\n\r\n        if (heightScale > 2 && paintHeight > 1) {\r\n          newHeight = Math.ceil(paintHeight / 2);\r\n          heightScale /= paintHeight / newHeight;\r\n        }\r\n\r\n        tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\r\n        tmpCtx = tmpCanvas.context;\r\n        tmpCtx.clearRect(0, 0, newWidth, newHeight);\r\n        tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\r\n        imgToPaint = tmpCanvas.canvas;\r\n        paintWidth = newWidth;\r\n        paintHeight = newHeight;\r\n        tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\r\n      }\r\n\r\n      ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);\r\n\r\n      if (this.imageLayer) {\r\n        const position = this.getCanvasPosition(0, -height);\r\n        this.imageLayer.appendImage({\r\n          imgData,\r\n          left: position[0],\r\n          top: position[1],\r\n          width: width / currentTransform[0],\r\n          height: height / currentTransform[3]\r\n        });\r\n      }\r\n\r\n      this.restore();\r\n    },\r\n    paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      const ctx = this.ctx;\r\n      const w = imgData.width;\r\n      const h = imgData.height;\r\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\r\n      const tmpCtx = tmpCanvas.context;\r\n      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\r\n\r\n      for (let i = 0, ii = map.length; i < ii; i++) {\r\n        const entry = map[i];\r\n        ctx.save();\r\n        ctx.transform.apply(ctx, entry.transform);\r\n        ctx.scale(1, -1);\r\n        ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\r\n\r\n        if (this.imageLayer) {\r\n          const position = this.getCanvasPosition(entry.x, entry.y);\r\n          this.imageLayer.appendImage({\r\n            imgData,\r\n            left: position[0],\r\n            top: position[1],\r\n            width: w,\r\n            height: h\r\n          });\r\n        }\r\n\r\n        ctx.restore();\r\n      }\r\n    },\r\n    paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {\r\n      if (!this.contentVisible) {\r\n        return;\r\n      }\r\n\r\n      this.ctx.fillRect(0, 0, 1, 1);\r\n    },\r\n    markPoint: function CanvasGraphics_markPoint(tag) {},\r\n    markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},\r\n    beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {\r\n      this.markedContentStack.push({\r\n        visible: true\r\n      });\r\n    },\r\n    beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {\r\n      if (tag === \"OC\") {\r\n        this.markedContentStack.push({\r\n          visible: this.optionalContentConfig.isVisible(properties)\r\n        });\r\n      } else {\r\n        this.markedContentStack.push({\r\n          visible: true\r\n        });\r\n      }\r\n\r\n      this.contentVisible = this.isContentVisible();\r\n    },\r\n    endMarkedContent: function CanvasGraphics_endMarkedContent() {\r\n      this.markedContentStack.pop();\r\n      this.contentVisible = this.isContentVisible();\r\n    },\r\n    beginCompat: function CanvasGraphics_beginCompat() {},\r\n    endCompat: function CanvasGraphics_endCompat() {},\r\n    consumePath: function CanvasGraphics_consumePath() {\r\n      const ctx = this.ctx;\r\n\r\n      if (this.pendingClip) {\r\n        if (this.pendingClip === EO_CLIP) {\r\n          ctx.clip(\"evenodd\");\r\n        } else {\r\n          ctx.clip();\r\n        }\r\n\r\n        this.pendingClip = null;\r\n      }\r\n\r\n      ctx.beginPath();\r\n    },\r\n\r\n    getSinglePixelWidth() {\r\n      if (this._cachedGetSinglePixelWidth === null) {\r\n        const m = this.ctx.mozCurrentTransform;\r\n        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\r\n        const sqNorm1 = m[0] ** 2 + m[2] ** 2;\r\n        const sqNorm2 = m[1] ** 2 + m[3] ** 2;\r\n        const pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;\r\n\r\n        if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {\r\n          this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);\r\n        } else if (absDet > Number.EPSILON) {\r\n          this._cachedGetSinglePixelWidth = pixelHeight * 1.0000001;\r\n        } else {\r\n          this._cachedGetSinglePixelWidth = 1;\r\n        }\r\n      }\r\n\r\n      return this._cachedGetSinglePixelWidth;\r\n    },\r\n\r\n    getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {\r\n      const transform = this.ctx.mozCurrentTransform;\r\n      return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];\r\n    },\r\n    isContentVisible: function CanvasGraphics_isContentVisible() {\r\n      for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\r\n        if (!this.markedContentStack[i].visible) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }\r\n  };\r\n\r\n  for (const op in _util.OPS) {\r\n    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\r\n  }\r\n\r\n  return CanvasGraphics;\r\n}();\r\n\r\nexports.CanvasGraphics = CanvasGraphics;\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.getShadingPatternFromIR = getShadingPatternFromIR;\r\nexports.TilingPattern = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nconst ShadingIRs = {};\r\n\r\nfunction applyBoundingBox(ctx, bbox) {\r\n  if (!bbox || typeof Path2D === \"undefined\") {\r\n    return;\r\n  }\r\n\r\n  const width = bbox[2] - bbox[0];\r\n  const height = bbox[3] - bbox[1];\r\n  const region = new Path2D();\r\n  region.rect(bbox[0], bbox[1], width, height);\r\n  ctx.clip(region);\r\n}\r\n\r\nShadingIRs.RadialAxial = {\r\n  fromIR: function RadialAxial_fromIR(raw) {\r\n    const type = raw[1];\r\n    const bbox = raw[2];\r\n    const colorStops = raw[3];\r\n    const p0 = raw[4];\r\n    const p1 = raw[5];\r\n    const r0 = raw[6];\r\n    const r1 = raw[7];\r\n    return {\r\n      getPattern: function RadialAxial_getPattern(ctx) {\r\n        applyBoundingBox(ctx, bbox);\r\n        let grad;\r\n\r\n        if (type === \"axial\") {\r\n          grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);\r\n        } else if (type === \"radial\") {\r\n          grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);\r\n        }\r\n\r\n        for (let i = 0, ii = colorStops.length; i < ii; ++i) {\r\n          const c = colorStops[i];\r\n          grad.addColorStop(c[0], c[1]);\r\n        }\r\n\r\n        return grad;\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\nconst createMeshCanvas = function createMeshCanvasClosure() {\r\n  function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\r\n    const coords = context.coords,\r\n          colors = context.colors;\r\n    const bytes = data.data,\r\n          rowSize = data.width * 4;\r\n    let tmp;\r\n\r\n    if (coords[p1 + 1] > coords[p2 + 1]) {\r\n      tmp = p1;\r\n      p1 = p2;\r\n      p2 = tmp;\r\n      tmp = c1;\r\n      c1 = c2;\r\n      c2 = tmp;\r\n    }\r\n\r\n    if (coords[p2 + 1] > coords[p3 + 1]) {\r\n      tmp = p2;\r\n      p2 = p3;\r\n      p3 = tmp;\r\n      tmp = c2;\r\n      c2 = c3;\r\n      c3 = tmp;\r\n    }\r\n\r\n    if (coords[p1 + 1] > coords[p2 + 1]) {\r\n      tmp = p1;\r\n      p1 = p2;\r\n      p2 = tmp;\r\n      tmp = c1;\r\n      c1 = c2;\r\n      c2 = tmp;\r\n    }\r\n\r\n    const x1 = (coords[p1] + context.offsetX) * context.scaleX;\r\n    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\r\n    const x2 = (coords[p2] + context.offsetX) * context.scaleX;\r\n    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\r\n    const x3 = (coords[p3] + context.offsetX) * context.scaleX;\r\n    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\r\n\r\n    if (y1 >= y3) {\r\n      return;\r\n    }\r\n\r\n    const c1r = colors[c1],\r\n          c1g = colors[c1 + 1],\r\n          c1b = colors[c1 + 2];\r\n    const c2r = colors[c2],\r\n          c2g = colors[c2 + 1],\r\n          c2b = colors[c2 + 2];\r\n    const c3r = colors[c3],\r\n          c3g = colors[c3 + 1],\r\n          c3b = colors[c3 + 2];\r\n    const minY = Math.round(y1),\r\n          maxY = Math.round(y3);\r\n    let xa, car, cag, cab;\r\n    let xb, cbr, cbg, cbb;\r\n\r\n    for (let y = minY; y <= maxY; y++) {\r\n      if (y < y2) {\r\n        let k;\r\n\r\n        if (y < y1) {\r\n          k = 0;\r\n        } else if (y1 === y2) {\r\n          k = 1;\r\n        } else {\r\n          k = (y1 - y) / (y1 - y2);\r\n        }\r\n\r\n        xa = x1 - (x1 - x2) * k;\r\n        car = c1r - (c1r - c2r) * k;\r\n        cag = c1g - (c1g - c2g) * k;\r\n        cab = c1b - (c1b - c2b) * k;\r\n      } else {\r\n        let k;\r\n\r\n        if (y > y3) {\r\n          k = 1;\r\n        } else if (y2 === y3) {\r\n          k = 0;\r\n        } else {\r\n          k = (y2 - y) / (y2 - y3);\r\n        }\r\n\r\n        xa = x2 - (x2 - x3) * k;\r\n        car = c2r - (c2r - c3r) * k;\r\n        cag = c2g - (c2g - c3g) * k;\r\n        cab = c2b - (c2b - c3b) * k;\r\n      }\r\n\r\n      let k;\r\n\r\n      if (y < y1) {\r\n        k = 0;\r\n      } else if (y > y3) {\r\n        k = 1;\r\n      } else {\r\n        k = (y1 - y) / (y1 - y3);\r\n      }\r\n\r\n      xb = x1 - (x1 - x3) * k;\r\n      cbr = c1r - (c1r - c3r) * k;\r\n      cbg = c1g - (c1g - c3g) * k;\r\n      cbb = c1b - (c1b - c3b) * k;\r\n      const x1_ = Math.round(Math.min(xa, xb));\r\n      const x2_ = Math.round(Math.max(xa, xb));\r\n      let j = rowSize * y + x1_ * 4;\r\n\r\n      for (let x = x1_; x <= x2_; x++) {\r\n        k = (xa - x) / (xa - xb);\r\n\r\n        if (k < 0) {\r\n          k = 0;\r\n        } else if (k > 1) {\r\n          k = 1;\r\n        }\r\n\r\n        bytes[j++] = car - (car - cbr) * k | 0;\r\n        bytes[j++] = cag - (cag - cbg) * k | 0;\r\n        bytes[j++] = cab - (cab - cbb) * k | 0;\r\n        bytes[j++] = 255;\r\n      }\r\n    }\r\n  }\r\n\r\n  function drawFigure(data, figure, context) {\r\n    const ps = figure.coords;\r\n    const cs = figure.colors;\r\n    let i, ii;\r\n\r\n    switch (figure.type) {\r\n      case \"lattice\":\r\n        const verticesPerRow = figure.verticesPerRow;\r\n        const rows = Math.floor(ps.length / verticesPerRow) - 1;\r\n        const cols = verticesPerRow - 1;\r\n\r\n        for (i = 0; i < rows; i++) {\r\n          let q = i * verticesPerRow;\r\n\r\n          for (let j = 0; j < cols; j++, q++) {\r\n            drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\r\n            drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\r\n          }\r\n        }\r\n\r\n        break;\r\n\r\n      case \"triangles\":\r\n        for (i = 0, ii = ps.length; i < ii; i += 3) {\r\n          drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\r\n        }\r\n\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"illegal figure\");\r\n    }\r\n  }\r\n\r\n  function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {\r\n    const EXPECTED_SCALE = 1.1;\r\n    const MAX_PATTERN_SIZE = 3000;\r\n    const BORDER_SIZE = 2;\r\n    const offsetX = Math.floor(bounds[0]);\r\n    const offsetY = Math.floor(bounds[1]);\r\n    const boundsWidth = Math.ceil(bounds[2]) - offsetX;\r\n    const boundsHeight = Math.ceil(bounds[3]) - offsetY;\r\n    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\r\n    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\r\n    const scaleX = boundsWidth / width;\r\n    const scaleY = boundsHeight / height;\r\n    const context = {\r\n      coords,\r\n      colors,\r\n      offsetX: -offsetX,\r\n      offsetY: -offsetY,\r\n      scaleX: 1 / scaleX,\r\n      scaleY: 1 / scaleY\r\n    };\r\n    const paddedWidth = width + BORDER_SIZE * 2;\r\n    const paddedHeight = height + BORDER_SIZE * 2;\r\n    let canvas, tmpCanvas, i, ii;\r\n\r\n    if (webGLContext.isEnabled) {\r\n      canvas = webGLContext.drawFigures({\r\n        width,\r\n        height,\r\n        backgroundColor,\r\n        figures,\r\n        context\r\n      });\r\n      tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\r\n      tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);\r\n      canvas = tmpCanvas.canvas;\r\n    } else {\r\n      tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\r\n      const tmpCtx = tmpCanvas.context;\r\n      const data = tmpCtx.createImageData(width, height);\r\n\r\n      if (backgroundColor) {\r\n        const bytes = data.data;\r\n\r\n        for (i = 0, ii = bytes.length; i < ii; i += 4) {\r\n          bytes[i] = backgroundColor[0];\r\n          bytes[i + 1] = backgroundColor[1];\r\n          bytes[i + 2] = backgroundColor[2];\r\n          bytes[i + 3] = 255;\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < figures.length; i++) {\r\n        drawFigure(data, figures[i], context);\r\n      }\r\n\r\n      tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\r\n      canvas = tmpCanvas.canvas;\r\n    }\r\n\r\n    return {\r\n      canvas,\r\n      offsetX: offsetX - BORDER_SIZE * scaleX,\r\n      offsetY: offsetY - BORDER_SIZE * scaleY,\r\n      scaleX,\r\n      scaleY\r\n    };\r\n  }\r\n\r\n  return createMeshCanvas;\r\n}();\r\n\r\nShadingIRs.Mesh = {\r\n  fromIR: function Mesh_fromIR(raw) {\r\n    const coords = raw[2];\r\n    const colors = raw[3];\r\n    const figures = raw[4];\r\n    const bounds = raw[5];\r\n    const matrix = raw[6];\r\n    const bbox = raw[7];\r\n    const background = raw[8];\r\n    return {\r\n      getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {\r\n        applyBoundingBox(ctx, bbox);\r\n        let scale;\r\n\r\n        if (shadingFill) {\r\n          scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\r\n        } else {\r\n          scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\r\n\r\n          if (matrix) {\r\n            const matrixScale = _util.Util.singularValueDecompose2dScale(matrix);\r\n\r\n            scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\r\n          }\r\n        }\r\n\r\n        const temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);\r\n\r\n        if (!shadingFill) {\r\n          ctx.setTransform.apply(ctx, owner.baseTransform);\r\n\r\n          if (matrix) {\r\n            ctx.transform.apply(ctx, matrix);\r\n          }\r\n        }\r\n\r\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\r\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\r\n        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\r\n      }\r\n    };\r\n  }\r\n};\r\nShadingIRs.Dummy = {\r\n  fromIR: function Dummy_fromIR() {\r\n    return {\r\n      getPattern: function Dummy_fromIR_getPattern() {\r\n        return \"hotpink\";\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\nfunction getShadingPatternFromIR(raw) {\r\n  const shadingIR = ShadingIRs[raw[0]];\r\n\r\n  if (!shadingIR) {\r\n    throw new Error(`Unknown IR type: ${raw[0]}`);\r\n  }\r\n\r\n  return shadingIR.fromIR(raw);\r\n}\r\n\r\nconst TilingPattern = function TilingPatternClosure() {\r\n  const PaintType = {\r\n    COLORED: 1,\r\n    UNCOLORED: 2\r\n  };\r\n  const MAX_PATTERN_SIZE = 3000;\r\n\r\n  function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\r\n    this.operatorList = IR[2];\r\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\r\n    this.bbox = IR[4];\r\n    this.xstep = IR[5];\r\n    this.ystep = IR[6];\r\n    this.paintType = IR[7];\r\n    this.tilingType = IR[8];\r\n    this.color = color;\r\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\r\n    this.baseTransform = baseTransform;\r\n    this.ctx = ctx;\r\n  }\r\n\r\n  TilingPattern.prototype = {\r\n    createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {\r\n      const operatorList = this.operatorList;\r\n      const bbox = this.bbox;\r\n      const xstep = this.xstep;\r\n      const ystep = this.ystep;\r\n      const paintType = this.paintType;\r\n      const tilingType = this.tilingType;\r\n      const color = this.color;\r\n      const canvasGraphicsFactory = this.canvasGraphicsFactory;\r\n      (0, _util.info)(\"TilingType: \" + tilingType);\r\n      const x0 = bbox[0],\r\n            y0 = bbox[1],\r\n            x1 = bbox[2],\r\n            y1 = bbox[3];\r\n\r\n      const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\r\n\r\n      const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\r\n\r\n      const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\r\n      const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\r\n      const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\r\n      const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\r\n      const tmpCtx = tmpCanvas.context;\r\n      const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\r\n      graphics.groupLevel = owner.groupLevel;\r\n      this.setFillAndStrokeStyleToContext(graphics, paintType, color);\r\n      graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\r\n      graphics.transform(1, 0, 0, 1, -x0, -y0);\r\n      this.clipBbox(graphics, bbox, x0, y0, x1, y1);\r\n      graphics.executeOperatorList(operatorList);\r\n      this.ctx.transform(1, 0, 0, 1, x0, y0);\r\n      this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);\r\n      return tmpCanvas.canvas;\r\n    },\r\n    getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {\r\n      step = Math.abs(step);\r\n      const maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);\r\n      let size = Math.ceil(step * scale);\r\n\r\n      if (size >= maxSize) {\r\n        size = maxSize;\r\n      } else {\r\n        scale = size / step;\r\n      }\r\n\r\n      return {\r\n        scale,\r\n        size\r\n      };\r\n    },\r\n    clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {\r\n      if (Array.isArray(bbox) && bbox.length === 4) {\r\n        const bboxWidth = x1 - x0;\r\n        const bboxHeight = y1 - y0;\r\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\r\n        graphics.clip();\r\n        graphics.endPath();\r\n      }\r\n    },\r\n    setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {\r\n      const context = graphics.ctx,\r\n            current = graphics.current;\r\n\r\n      switch (paintType) {\r\n        case PaintType.COLORED:\r\n          const ctx = this.ctx;\r\n          context.fillStyle = ctx.fillStyle;\r\n          context.strokeStyle = ctx.strokeStyle;\r\n          current.fillColor = ctx.fillStyle;\r\n          current.strokeColor = ctx.strokeStyle;\r\n          break;\r\n\r\n        case PaintType.UNCOLORED:\r\n          const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\r\n\r\n          context.fillStyle = cssColor;\r\n          context.strokeStyle = cssColor;\r\n          current.fillColor = cssColor;\r\n          current.strokeColor = cssColor;\r\n          break;\r\n\r\n        default:\r\n          throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\r\n      }\r\n    },\r\n    getPattern: function TilingPattern_getPattern(ctx, owner) {\r\n      ctx = this.ctx;\r\n      ctx.setTransform.apply(ctx, this.baseTransform);\r\n      ctx.transform.apply(ctx, this.matrix);\r\n      const temporaryPatternCanvas = this.createPatternCanvas(owner);\r\n      return ctx.createPattern(temporaryPatternCanvas, \"repeat\");\r\n    }\r\n  };\r\n  return TilingPattern;\r\n}();\r\n\r\nexports.TilingPattern = TilingPattern;\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ ((__unused_webpack_module, exports) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.GlobalWorkerOptions = void 0;\r\nconst GlobalWorkerOptions = Object.create(null);\r\nexports.GlobalWorkerOptions = GlobalWorkerOptions;\r\nGlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;\r\nGlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? \"\" : GlobalWorkerOptions.workerSrc;\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.MessageHandler = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nconst CallbackKind = {\r\n  UNKNOWN: 0,\r\n  DATA: 1,\r\n  ERROR: 2\r\n};\r\nconst StreamKind = {\r\n  UNKNOWN: 0,\r\n  CANCEL: 1,\r\n  CANCEL_COMPLETE: 2,\r\n  CLOSE: 3,\r\n  ENQUEUE: 4,\r\n  ERROR: 5,\r\n  PULL: 6,\r\n  PULL_COMPLETE: 7,\r\n  START_COMPLETE: 8\r\n};\r\n\r\nfunction wrapReason(reason) {\r\n  if (typeof reason !== \"object\" || reason === null) {\r\n    return reason;\r\n  }\r\n\r\n  switch (reason.name) {\r\n    case \"AbortException\":\r\n      return new _util.AbortException(reason.message);\r\n\r\n    case \"MissingPDFException\":\r\n      return new _util.MissingPDFException(reason.message);\r\n\r\n    case \"UnexpectedResponseException\":\r\n      return new _util.UnexpectedResponseException(reason.message, reason.status);\r\n\r\n    case \"UnknownErrorException\":\r\n      return new _util.UnknownErrorException(reason.message, reason.details);\r\n\r\n    default:\r\n      return new _util.UnknownErrorException(reason.message, reason.toString());\r\n  }\r\n}\r\n\r\nclass MessageHandler {\r\n  constructor(sourceName, targetName, comObj) {\r\n    this.sourceName = sourceName;\r\n    this.targetName = targetName;\r\n    this.comObj = comObj;\r\n    this.callbackId = 1;\r\n    this.streamId = 1;\r\n    this.postMessageTransfers = true;\r\n    this.streamSinks = Object.create(null);\r\n    this.streamControllers = Object.create(null);\r\n    this.callbackCapabilities = Object.create(null);\r\n    this.actionHandler = Object.create(null);\r\n\r\n    this._onComObjOnMessage = event => {\r\n      const data = event.data;\r\n\r\n      if (data.targetName !== this.sourceName) {\r\n        return;\r\n      }\r\n\r\n      if (data.stream) {\r\n        this._processStreamMessage(data);\r\n\r\n        return;\r\n      }\r\n\r\n      if (data.callback) {\r\n        const callbackId = data.callbackId;\r\n        const capability = this.callbackCapabilities[callbackId];\r\n\r\n        if (!capability) {\r\n          throw new Error(`Cannot resolve callback ${callbackId}`);\r\n        }\r\n\r\n        delete this.callbackCapabilities[callbackId];\r\n\r\n        if (data.callback === CallbackKind.DATA) {\r\n          capability.resolve(data.data);\r\n        } else if (data.callback === CallbackKind.ERROR) {\r\n          capability.reject(wrapReason(data.reason));\r\n        } else {\r\n          throw new Error(\"Unexpected callback case\");\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      const action = this.actionHandler[data.action];\r\n\r\n      if (!action) {\r\n        throw new Error(`Unknown action from worker: ${data.action}`);\r\n      }\r\n\r\n      if (data.callbackId) {\r\n        const cbSourceName = this.sourceName;\r\n        const cbTargetName = data.sourceName;\r\n        new Promise(function (resolve) {\r\n          resolve(action(data.data));\r\n        }).then(function (result) {\r\n          comObj.postMessage({\r\n            sourceName: cbSourceName,\r\n            targetName: cbTargetName,\r\n            callback: CallbackKind.DATA,\r\n            callbackId: data.callbackId,\r\n            data: result\r\n          });\r\n        }, function (reason) {\r\n          comObj.postMessage({\r\n            sourceName: cbSourceName,\r\n            targetName: cbTargetName,\r\n            callback: CallbackKind.ERROR,\r\n            callbackId: data.callbackId,\r\n            reason: wrapReason(reason)\r\n          });\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (data.streamId) {\r\n        this._createStreamSink(data);\r\n\r\n        return;\r\n      }\r\n\r\n      action(data.data);\r\n    };\r\n\r\n    comObj.addEventListener(\"message\", this._onComObjOnMessage);\r\n  }\r\n\r\n  on(actionName, handler) {\r\n    const ah = this.actionHandler;\r\n\r\n    if (ah[actionName]) {\r\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\r\n    }\r\n\r\n    ah[actionName] = handler;\r\n  }\r\n\r\n  send(actionName, data, transfers) {\r\n    this._postMessage({\r\n      sourceName: this.sourceName,\r\n      targetName: this.targetName,\r\n      action: actionName,\r\n      data\r\n    }, transfers);\r\n  }\r\n\r\n  sendWithPromise(actionName, data, transfers) {\r\n    const callbackId = this.callbackId++;\r\n    const capability = (0, _util.createPromiseCapability)();\r\n    this.callbackCapabilities[callbackId] = capability;\r\n\r\n    try {\r\n      this._postMessage({\r\n        sourceName: this.sourceName,\r\n        targetName: this.targetName,\r\n        action: actionName,\r\n        callbackId,\r\n        data\r\n      }, transfers);\r\n    } catch (ex) {\r\n      capability.reject(ex);\r\n    }\r\n\r\n    return capability.promise;\r\n  }\r\n\r\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\r\n    const streamId = this.streamId++;\r\n    const sourceName = this.sourceName;\r\n    const targetName = this.targetName;\r\n    const comObj = this.comObj;\r\n    return new ReadableStream({\r\n      start: controller => {\r\n        const startCapability = (0, _util.createPromiseCapability)();\r\n        this.streamControllers[streamId] = {\r\n          controller,\r\n          startCall: startCapability,\r\n          pullCall: null,\r\n          cancelCall: null,\r\n          isClosed: false\r\n        };\r\n\r\n        this._postMessage({\r\n          sourceName,\r\n          targetName,\r\n          action: actionName,\r\n          streamId,\r\n          data,\r\n          desiredSize: controller.desiredSize\r\n        }, transfers);\r\n\r\n        return startCapability.promise;\r\n      },\r\n      pull: controller => {\r\n        const pullCapability = (0, _util.createPromiseCapability)();\r\n        this.streamControllers[streamId].pullCall = pullCapability;\r\n        comObj.postMessage({\r\n          sourceName,\r\n          targetName,\r\n          stream: StreamKind.PULL,\r\n          streamId,\r\n          desiredSize: controller.desiredSize\r\n        });\r\n        return pullCapability.promise;\r\n      },\r\n      cancel: reason => {\r\n        (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\r\n        const cancelCapability = (0, _util.createPromiseCapability)();\r\n        this.streamControllers[streamId].cancelCall = cancelCapability;\r\n        this.streamControllers[streamId].isClosed = true;\r\n        comObj.postMessage({\r\n          sourceName,\r\n          targetName,\r\n          stream: StreamKind.CANCEL,\r\n          streamId,\r\n          reason: wrapReason(reason)\r\n        });\r\n        return cancelCapability.promise;\r\n      }\r\n    }, queueingStrategy);\r\n  }\r\n\r\n  _createStreamSink(data) {\r\n    const self = this;\r\n    const action = this.actionHandler[data.action];\r\n    const streamId = data.streamId;\r\n    const sourceName = this.sourceName;\r\n    const targetName = data.sourceName;\r\n    const comObj = this.comObj;\r\n    const streamSink = {\r\n      enqueue(chunk, size = 1, transfers) {\r\n        if (this.isCancelled) {\r\n          return;\r\n        }\r\n\r\n        const lastDesiredSize = this.desiredSize;\r\n        this.desiredSize -= size;\r\n\r\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\r\n          this.sinkCapability = (0, _util.createPromiseCapability)();\r\n          this.ready = this.sinkCapability.promise;\r\n        }\r\n\r\n        self._postMessage({\r\n          sourceName,\r\n          targetName,\r\n          stream: StreamKind.ENQUEUE,\r\n          streamId,\r\n          chunk\r\n        }, transfers);\r\n      },\r\n\r\n      close() {\r\n        if (this.isCancelled) {\r\n          return;\r\n        }\r\n\r\n        this.isCancelled = true;\r\n        comObj.postMessage({\r\n          sourceName,\r\n          targetName,\r\n          stream: StreamKind.CLOSE,\r\n          streamId\r\n        });\r\n        delete self.streamSinks[streamId];\r\n      },\r\n\r\n      error(reason) {\r\n        (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\r\n\r\n        if (this.isCancelled) {\r\n          return;\r\n        }\r\n\r\n        this.isCancelled = true;\r\n        comObj.postMessage({\r\n          sourceName,\r\n          targetName,\r\n          stream: StreamKind.ERROR,\r\n          streamId,\r\n          reason: wrapReason(reason)\r\n        });\r\n      },\r\n\r\n      sinkCapability: (0, _util.createPromiseCapability)(),\r\n      onPull: null,\r\n      onCancel: null,\r\n      isCancelled: false,\r\n      desiredSize: data.desiredSize,\r\n      ready: null\r\n    };\r\n    streamSink.sinkCapability.resolve();\r\n    streamSink.ready = streamSink.sinkCapability.promise;\r\n    this.streamSinks[streamId] = streamSink;\r\n    new Promise(function (resolve) {\r\n      resolve(action(data.data, streamSink));\r\n    }).then(function () {\r\n      comObj.postMessage({\r\n        sourceName,\r\n        targetName,\r\n        stream: StreamKind.START_COMPLETE,\r\n        streamId,\r\n        success: true\r\n      });\r\n    }, function (reason) {\r\n      comObj.postMessage({\r\n        sourceName,\r\n        targetName,\r\n        stream: StreamKind.START_COMPLETE,\r\n        streamId,\r\n        reason: wrapReason(reason)\r\n      });\r\n    });\r\n  }\r\n\r\n  _processStreamMessage(data) {\r\n    const streamId = data.streamId;\r\n    const sourceName = this.sourceName;\r\n    const targetName = data.sourceName;\r\n    const comObj = this.comObj;\r\n\r\n    switch (data.stream) {\r\n      case StreamKind.START_COMPLETE:\r\n        if (data.success) {\r\n          this.streamControllers[streamId].startCall.resolve();\r\n        } else {\r\n          this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));\r\n        }\r\n\r\n        break;\r\n\r\n      case StreamKind.PULL_COMPLETE:\r\n        if (data.success) {\r\n          this.streamControllers[streamId].pullCall.resolve();\r\n        } else {\r\n          this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));\r\n        }\r\n\r\n        break;\r\n\r\n      case StreamKind.PULL:\r\n        if (!this.streamSinks[streamId]) {\r\n          comObj.postMessage({\r\n            sourceName,\r\n            targetName,\r\n            stream: StreamKind.PULL_COMPLETE,\r\n            streamId,\r\n            success: true\r\n          });\r\n          break;\r\n        }\r\n\r\n        if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {\r\n          this.streamSinks[streamId].sinkCapability.resolve();\r\n        }\r\n\r\n        this.streamSinks[streamId].desiredSize = data.desiredSize;\r\n        const {\r\n          onPull\r\n        } = this.streamSinks[data.streamId];\r\n        new Promise(function (resolve) {\r\n          resolve(onPull && onPull());\r\n        }).then(function () {\r\n          comObj.postMessage({\r\n            sourceName,\r\n            targetName,\r\n            stream: StreamKind.PULL_COMPLETE,\r\n            streamId,\r\n            success: true\r\n          });\r\n        }, function (reason) {\r\n          comObj.postMessage({\r\n            sourceName,\r\n            targetName,\r\n            stream: StreamKind.PULL_COMPLETE,\r\n            streamId,\r\n            reason: wrapReason(reason)\r\n          });\r\n        });\r\n        break;\r\n\r\n      case StreamKind.ENQUEUE:\r\n        (0, _util.assert)(this.streamControllers[streamId], \"enqueue should have stream controller\");\r\n\r\n        if (this.streamControllers[streamId].isClosed) {\r\n          break;\r\n        }\r\n\r\n        this.streamControllers[streamId].controller.enqueue(data.chunk);\r\n        break;\r\n\r\n      case StreamKind.CLOSE:\r\n        (0, _util.assert)(this.streamControllers[streamId], \"close should have stream controller\");\r\n\r\n        if (this.streamControllers[streamId].isClosed) {\r\n          break;\r\n        }\r\n\r\n        this.streamControllers[streamId].isClosed = true;\r\n        this.streamControllers[streamId].controller.close();\r\n\r\n        this._deleteStreamController(streamId);\r\n\r\n        break;\r\n\r\n      case StreamKind.ERROR:\r\n        (0, _util.assert)(this.streamControllers[streamId], \"error should have stream controller\");\r\n        this.streamControllers[streamId].controller.error(wrapReason(data.reason));\r\n\r\n        this._deleteStreamController(streamId);\r\n\r\n        break;\r\n\r\n      case StreamKind.CANCEL_COMPLETE:\r\n        if (data.success) {\r\n          this.streamControllers[streamId].cancelCall.resolve();\r\n        } else {\r\n          this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));\r\n        }\r\n\r\n        this._deleteStreamController(streamId);\r\n\r\n        break;\r\n\r\n      case StreamKind.CANCEL:\r\n        if (!this.streamSinks[streamId]) {\r\n          break;\r\n        }\r\n\r\n        const {\r\n          onCancel\r\n        } = this.streamSinks[data.streamId];\r\n        new Promise(function (resolve) {\r\n          resolve(onCancel && onCancel(wrapReason(data.reason)));\r\n        }).then(function () {\r\n          comObj.postMessage({\r\n            sourceName,\r\n            targetName,\r\n            stream: StreamKind.CANCEL_COMPLETE,\r\n            streamId,\r\n            success: true\r\n          });\r\n        }, function (reason) {\r\n          comObj.postMessage({\r\n            sourceName,\r\n            targetName,\r\n            stream: StreamKind.CANCEL_COMPLETE,\r\n            streamId,\r\n            reason: wrapReason(reason)\r\n          });\r\n        });\r\n        this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));\r\n        this.streamSinks[streamId].isCancelled = true;\r\n        delete this.streamSinks[streamId];\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"Unexpected stream case\");\r\n    }\r\n  }\r\n\r\n  async _deleteStreamController(streamId) {\r\n    await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) {\r\n      return capability && capability.promise;\r\n    }));\r\n    delete this.streamControllers[streamId];\r\n  }\r\n\r\n  _postMessage(message, transfers) {\r\n    if (transfers && this.postMessageTransfers) {\r\n      this.comObj.postMessage(message, transfers);\r\n    } else {\r\n      this.comObj.postMessage(message);\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\r\n  }\r\n\r\n}\r\n\r\nexports.MessageHandler = MessageHandler;\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.Metadata = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nvar _xml_parser = __w_pdfjs_require__(15);\r\n\r\nclass Metadata {\r\n  constructor(data) {\r\n    (0, _util.assert)(typeof data === \"string\", \"Metadata: input is not a string\");\r\n    data = this._repair(data);\r\n    const parser = new _xml_parser.SimpleXMLParser({\r\n      lowerCaseName: true\r\n    });\r\n    const xmlDocument = parser.parseFromString(data);\r\n    this._metadataMap = new Map();\r\n\r\n    if (xmlDocument) {\r\n      this._parse(xmlDocument);\r\n    }\r\n\r\n    this._data = data;\r\n  }\r\n\r\n  _repair(data) {\r\n    return data.replace(/^[^<]+/, \"\").replace(/>\\\\376\\\\377([^<]+)/g, function (all, codes) {\r\n      const bytes = codes.replace(/\\\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {\r\n        return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);\r\n      }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) {\r\n        switch (name) {\r\n          case \"amp\":\r\n            return \"&\";\r\n\r\n          case \"apos\":\r\n            return \"'\";\r\n\r\n          case \"gt\":\r\n            return \">\";\r\n\r\n          case \"lt\":\r\n            return \"<\";\r\n\r\n          case \"quot\":\r\n            return '\"';\r\n        }\r\n\r\n        throw new Error(`_repair: ${name} isn't defined.`);\r\n      });\r\n      let chars = \"\";\r\n\r\n      for (let i = 0, ii = bytes.length; i < ii; i += 2) {\r\n        const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);\r\n\r\n        if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {\r\n          chars += String.fromCharCode(code);\r\n        } else {\r\n          chars += \"&#x\" + (0x10000 + code).toString(16).substring(1) + \";\";\r\n        }\r\n      }\r\n\r\n      return \">\" + chars;\r\n    });\r\n  }\r\n\r\n  _getSequence(entry) {\r\n    const name = entry.nodeName;\r\n\r\n    if (name !== \"rdf:bag\" && name !== \"rdf:seq\" && name !== \"rdf:alt\") {\r\n      return null;\r\n    }\r\n\r\n    return entry.childNodes.filter(node => node.nodeName === \"rdf:li\");\r\n  }\r\n\r\n  _getCreators(entry) {\r\n    if (entry.nodeName !== \"dc:creator\") {\r\n      return false;\r\n    }\r\n\r\n    if (!entry.hasChildNodes()) {\r\n      return true;\r\n    }\r\n\r\n    const seqNode = entry.childNodes[0];\r\n    const authors = this._getSequence(seqNode) || [];\r\n\r\n    this._metadataMap.set(entry.nodeName, authors.map(node => node.textContent.trim()));\r\n\r\n    return true;\r\n  }\r\n\r\n  _parse(xmlDocument) {\r\n    let rdf = xmlDocument.documentElement;\r\n\r\n    if (rdf.nodeName !== \"rdf:rdf\") {\r\n      rdf = rdf.firstChild;\r\n\r\n      while (rdf && rdf.nodeName !== \"rdf:rdf\") {\r\n        rdf = rdf.nextSibling;\r\n      }\r\n    }\r\n\r\n    if (!rdf || rdf.nodeName !== \"rdf:rdf\" || !rdf.hasChildNodes()) {\r\n      return;\r\n    }\r\n\r\n    for (const desc of rdf.childNodes) {\r\n      if (desc.nodeName !== \"rdf:description\") {\r\n        continue;\r\n      }\r\n\r\n      for (const entry of desc.childNodes) {\r\n        const name = entry.nodeName;\r\n\r\n        if (name === \"#text\") {\r\n          continue;\r\n        }\r\n\r\n        if (this._getCreators(entry)) {\r\n          continue;\r\n        }\r\n\r\n        this._metadataMap.set(name, entry.textContent.trim());\r\n      }\r\n    }\r\n  }\r\n\r\n  getRaw() {\r\n    return this._data;\r\n  }\r\n\r\n  get(name) {\r\n    return this._metadataMap.get(name) ?? null;\r\n  }\r\n\r\n  getAll() {\r\n    return (0, _util.objectFromEntries)(this._metadataMap);\r\n  }\r\n\r\n  has(name) {\r\n    return this._metadataMap.has(name);\r\n  }\r\n\r\n}\r\n\r\nexports.Metadata = Metadata;\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.SimpleXMLParser = exports.SimpleDOMNode = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nconst XMLParserErrorCode = {\r\n  NoError: 0,\r\n  EndOfDocument: -1,\r\n  UnterminatedCdat: -2,\r\n  UnterminatedXmlDeclaration: -3,\r\n  UnterminatedDoctypeDeclaration: -4,\r\n  UnterminatedComment: -5,\r\n  MalformedElement: -6,\r\n  OutOfMemory: -7,\r\n  UnterminatedAttributeValue: -8,\r\n  UnterminatedElement: -9,\r\n  ElementNeverBegun: -10\r\n};\r\n\r\nfunction isWhitespace(s, index) {\r\n  const ch = s[index];\r\n  return ch === \" \" || ch === \"\\n\" || ch === \"\\r\" || ch === \"\\t\";\r\n}\r\n\r\nfunction isWhitespaceString(s) {\r\n  for (let i = 0, ii = s.length; i < ii; i++) {\r\n    if (!isWhitespace(s, i)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nclass XMLParserBase {\r\n  _resolveEntities(s) {\r\n    return s.replace(/&([^;]+);/g, (all, entity) => {\r\n      if (entity.substring(0, 2) === \"#x\") {\r\n        return String.fromCodePoint(parseInt(entity.substring(2), 16));\r\n      } else if (entity.substring(0, 1) === \"#\") {\r\n        return String.fromCodePoint(parseInt(entity.substring(1), 10));\r\n      }\r\n\r\n      switch (entity) {\r\n        case \"lt\":\r\n          return \"<\";\r\n\r\n        case \"gt\":\r\n          return \">\";\r\n\r\n        case \"amp\":\r\n          return \"&\";\r\n\r\n        case \"quot\":\r\n          return '\"';\r\n      }\r\n\r\n      return this.onResolveEntity(entity);\r\n    });\r\n  }\r\n\r\n  _parseContent(s, start) {\r\n    const attributes = [];\r\n    let pos = start;\r\n\r\n    function skipWs() {\r\n      while (pos < s.length && isWhitespace(s, pos)) {\r\n        ++pos;\r\n      }\r\n    }\r\n\r\n    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \">\" && s[pos] !== \"/\") {\r\n      ++pos;\r\n    }\r\n\r\n    const name = s.substring(start, pos);\r\n    skipWs();\r\n\r\n    while (pos < s.length && s[pos] !== \">\" && s[pos] !== \"/\" && s[pos] !== \"?\") {\r\n      skipWs();\r\n      let attrName = \"\",\r\n          attrValue = \"\";\r\n\r\n      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \"=\") {\r\n        attrName += s[pos];\r\n        ++pos;\r\n      }\r\n\r\n      skipWs();\r\n\r\n      if (s[pos] !== \"=\") {\r\n        return null;\r\n      }\r\n\r\n      ++pos;\r\n      skipWs();\r\n      const attrEndChar = s[pos];\r\n\r\n      if (attrEndChar !== '\"' && attrEndChar !== \"'\") {\r\n        return null;\r\n      }\r\n\r\n      const attrEndIndex = s.indexOf(attrEndChar, ++pos);\r\n\r\n      if (attrEndIndex < 0) {\r\n        return null;\r\n      }\r\n\r\n      attrValue = s.substring(pos, attrEndIndex);\r\n      attributes.push({\r\n        name: attrName,\r\n        value: this._resolveEntities(attrValue)\r\n      });\r\n      pos = attrEndIndex + 1;\r\n      skipWs();\r\n    }\r\n\r\n    return {\r\n      name,\r\n      attributes,\r\n      parsed: pos - start\r\n    };\r\n  }\r\n\r\n  _parseProcessingInstruction(s, start) {\r\n    let pos = start;\r\n\r\n    function skipWs() {\r\n      while (pos < s.length && isWhitespace(s, pos)) {\r\n        ++pos;\r\n      }\r\n    }\r\n\r\n    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \">\" && s[pos] !== \"/\") {\r\n      ++pos;\r\n    }\r\n\r\n    const name = s.substring(start, pos);\r\n    skipWs();\r\n    const attrStart = pos;\r\n\r\n    while (pos < s.length && (s[pos] !== \"?\" || s[pos + 1] !== \">\")) {\r\n      ++pos;\r\n    }\r\n\r\n    const value = s.substring(attrStart, pos);\r\n    return {\r\n      name,\r\n      value,\r\n      parsed: pos - start\r\n    };\r\n  }\r\n\r\n  parseXml(s) {\r\n    let i = 0;\r\n\r\n    while (i < s.length) {\r\n      const ch = s[i];\r\n      let j = i;\r\n\r\n      if (ch === \"<\") {\r\n        ++j;\r\n        const ch2 = s[j];\r\n        let q;\r\n\r\n        switch (ch2) {\r\n          case \"/\":\r\n            ++j;\r\n            q = s.indexOf(\">\", j);\r\n\r\n            if (q < 0) {\r\n              this.onError(XMLParserErrorCode.UnterminatedElement);\r\n              return;\r\n            }\r\n\r\n            this.onEndElement(s.substring(j, q));\r\n            j = q + 1;\r\n            break;\r\n\r\n          case \"?\":\r\n            ++j;\r\n\r\n            const pi = this._parseProcessingInstruction(s, j);\r\n\r\n            if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== \"?>\") {\r\n              this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);\r\n              return;\r\n            }\r\n\r\n            this.onPi(pi.name, pi.value);\r\n            j += pi.parsed + 2;\r\n            break;\r\n\r\n          case \"!\":\r\n            if (s.substring(j + 1, j + 3) === \"--\") {\r\n              q = s.indexOf(\"-->\", j + 3);\r\n\r\n              if (q < 0) {\r\n                this.onError(XMLParserErrorCode.UnterminatedComment);\r\n                return;\r\n              }\r\n\r\n              this.onComment(s.substring(j + 3, q));\r\n              j = q + 3;\r\n            } else if (s.substring(j + 1, j + 8) === \"[CDATA[\") {\r\n              q = s.indexOf(\"]]>\", j + 8);\r\n\r\n              if (q < 0) {\r\n                this.onError(XMLParserErrorCode.UnterminatedCdat);\r\n                return;\r\n              }\r\n\r\n              this.onCdata(s.substring(j + 8, q));\r\n              j = q + 3;\r\n            } else if (s.substring(j + 1, j + 8) === \"DOCTYPE\") {\r\n              const q2 = s.indexOf(\"[\", j + 8);\r\n              let complexDoctype = false;\r\n              q = s.indexOf(\">\", j + 8);\r\n\r\n              if (q < 0) {\r\n                this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\r\n                return;\r\n              }\r\n\r\n              if (q2 > 0 && q > q2) {\r\n                q = s.indexOf(\"]>\", j + 8);\r\n\r\n                if (q < 0) {\r\n                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\r\n                  return;\r\n                }\r\n\r\n                complexDoctype = true;\r\n              }\r\n\r\n              const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));\r\n              this.onDoctype(doctypeContent);\r\n              j = q + (complexDoctype ? 2 : 1);\r\n            } else {\r\n              this.onError(XMLParserErrorCode.MalformedElement);\r\n              return;\r\n            }\r\n\r\n            break;\r\n\r\n          default:\r\n            const content = this._parseContent(s, j);\r\n\r\n            if (content === null) {\r\n              this.onError(XMLParserErrorCode.MalformedElement);\r\n              return;\r\n            }\r\n\r\n            let isClosed = false;\r\n\r\n            if (s.substring(j + content.parsed, j + content.parsed + 2) === \"/>\") {\r\n              isClosed = true;\r\n            } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== \">\") {\r\n              this.onError(XMLParserErrorCode.UnterminatedElement);\r\n              return;\r\n            }\r\n\r\n            this.onBeginElement(content.name, content.attributes, isClosed);\r\n            j += content.parsed + (isClosed ? 2 : 1);\r\n            break;\r\n        }\r\n      } else {\r\n        while (j < s.length && s[j] !== \"<\") {\r\n          j++;\r\n        }\r\n\r\n        const text = s.substring(i, j);\r\n        this.onText(this._resolveEntities(text));\r\n      }\r\n\r\n      i = j;\r\n    }\r\n  }\r\n\r\n  onResolveEntity(name) {\r\n    return `&${name};`;\r\n  }\r\n\r\n  onPi(name, value) {}\r\n\r\n  onComment(text) {}\r\n\r\n  onCdata(text) {}\r\n\r\n  onDoctype(doctypeContent) {}\r\n\r\n  onText(text) {}\r\n\r\n  onBeginElement(name, attributes, isEmpty) {}\r\n\r\n  onEndElement(name) {}\r\n\r\n  onError(code) {}\r\n\r\n}\r\n\r\nclass SimpleDOMNode {\r\n  constructor(nodeName, nodeValue) {\r\n    this.nodeName = nodeName;\r\n    this.nodeValue = nodeValue;\r\n    Object.defineProperty(this, \"parentNode\", {\r\n      value: null,\r\n      writable: true\r\n    });\r\n  }\r\n\r\n  get firstChild() {\r\n    return this.childNodes && this.childNodes[0];\r\n  }\r\n\r\n  get nextSibling() {\r\n    const childNodes = this.parentNode.childNodes;\r\n\r\n    if (!childNodes) {\r\n      return undefined;\r\n    }\r\n\r\n    const index = childNodes.indexOf(this);\r\n\r\n    if (index === -1) {\r\n      return undefined;\r\n    }\r\n\r\n    return childNodes[index + 1];\r\n  }\r\n\r\n  get textContent() {\r\n    if (!this.childNodes) {\r\n      return this.nodeValue || \"\";\r\n    }\r\n\r\n    return this.childNodes.map(function (child) {\r\n      return child.textContent;\r\n    }).join(\"\");\r\n  }\r\n\r\n  hasChildNodes() {\r\n    return this.childNodes && this.childNodes.length > 0;\r\n  }\r\n\r\n  searchNode(paths, pos) {\r\n    if (pos >= paths.length) {\r\n      return this;\r\n    }\r\n\r\n    const component = paths[pos];\r\n    const stack = [];\r\n    let node = this;\r\n\r\n    while (true) {\r\n      if (component.name === node.nodeName) {\r\n        if (component.pos === 0) {\r\n          const res = node.searchNode(paths, pos + 1);\r\n\r\n          if (res !== null) {\r\n            return res;\r\n          }\r\n        } else if (stack.length === 0) {\r\n          return null;\r\n        } else {\r\n          const [parent] = stack.pop();\r\n          let siblingPos = 0;\r\n\r\n          for (const child of parent.childNodes) {\r\n            if (component.name === child.nodeName) {\r\n              if (siblingPos === component.pos) {\r\n                return child.searchNode(paths, pos + 1);\r\n              }\r\n\r\n              siblingPos++;\r\n            }\r\n          }\r\n\r\n          return node.searchNode(paths, pos + 1);\r\n        }\r\n      }\r\n\r\n      if (node.childNodes && node.childNodes.length !== 0) {\r\n        stack.push([node, 0]);\r\n        node = node.childNodes[0];\r\n      } else if (stack.length === 0) {\r\n        return null;\r\n      } else {\r\n        while (stack.length !== 0) {\r\n          const [parent, currentPos] = stack.pop();\r\n          const newPos = currentPos + 1;\r\n\r\n          if (newPos < parent.childNodes.length) {\r\n            stack.push([parent, newPos]);\r\n            node = parent.childNodes[newPos];\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (stack.length === 0) {\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  dump(buffer) {\r\n    if (this.nodeName === \"#text\") {\r\n      buffer.push((0, _util.encodeToXmlString)(this.nodeValue));\r\n      return;\r\n    }\r\n\r\n    buffer.push(`<${this.nodeName}`);\r\n\r\n    if (this.attributes) {\r\n      for (const attribute of this.attributes) {\r\n        buffer.push(` ${attribute.name}=\"${(0, _util.encodeToXmlString)(attribute.value)}\"`);\r\n      }\r\n    }\r\n\r\n    if (this.hasChildNodes()) {\r\n      buffer.push(\">\");\r\n\r\n      for (const child of this.childNodes) {\r\n        child.dump(buffer);\r\n      }\r\n\r\n      buffer.push(`</${this.nodeName}>`);\r\n    } else if (this.nodeValue) {\r\n      buffer.push(`>${(0, _util.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`);\r\n    } else {\r\n      buffer.push(\"/>\");\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexports.SimpleDOMNode = SimpleDOMNode;\r\n\r\nclass SimpleXMLParser extends XMLParserBase {\r\n  constructor({\r\n    hasAttributes = false,\r\n    lowerCaseName = false\r\n  }) {\r\n    super();\r\n    this._currentFragment = null;\r\n    this._stack = null;\r\n    this._errorCode = XMLParserErrorCode.NoError;\r\n    this._hasAttributes = hasAttributes;\r\n    this._lowerCaseName = lowerCaseName;\r\n  }\r\n\r\n  parseFromString(data) {\r\n    this._currentFragment = [];\r\n    this._stack = [];\r\n    this._errorCode = XMLParserErrorCode.NoError;\r\n    this.parseXml(data);\r\n\r\n    if (this._errorCode !== XMLParserErrorCode.NoError) {\r\n      return undefined;\r\n    }\r\n\r\n    const [documentElement] = this._currentFragment;\r\n\r\n    if (!documentElement) {\r\n      return undefined;\r\n    }\r\n\r\n    return {\r\n      documentElement\r\n    };\r\n  }\r\n\r\n  onResolveEntity(name) {\r\n    switch (name) {\r\n      case \"apos\":\r\n        return \"'\";\r\n    }\r\n\r\n    return super.onResolveEntity(name);\r\n  }\r\n\r\n  onText(text) {\r\n    if (isWhitespaceString(text)) {\r\n      return;\r\n    }\r\n\r\n    const node = new SimpleDOMNode(\"#text\", text);\r\n\r\n    this._currentFragment.push(node);\r\n  }\r\n\r\n  onCdata(text) {\r\n    const node = new SimpleDOMNode(\"#text\", text);\r\n\r\n    this._currentFragment.push(node);\r\n  }\r\n\r\n  onBeginElement(name, attributes, isEmpty) {\r\n    if (this._lowerCaseName) {\r\n      name = name.toLowerCase();\r\n    }\r\n\r\n    const node = new SimpleDOMNode(name);\r\n    node.childNodes = [];\r\n\r\n    if (this._hasAttributes) {\r\n      node.attributes = attributes;\r\n    }\r\n\r\n    this._currentFragment.push(node);\r\n\r\n    if (isEmpty) {\r\n      return;\r\n    }\r\n\r\n    this._stack.push(this._currentFragment);\r\n\r\n    this._currentFragment = node.childNodes;\r\n  }\r\n\r\n  onEndElement(name) {\r\n    this._currentFragment = this._stack.pop() || [];\r\n    const lastElement = this._currentFragment[this._currentFragment.length - 1];\r\n\r\n    if (!lastElement) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0, ii = lastElement.childNodes.length; i < ii; i++) {\r\n      lastElement.childNodes[i].parentNode = lastElement;\r\n    }\r\n  }\r\n\r\n  onError(code) {\r\n    this._errorCode = code;\r\n  }\r\n\r\n}\r\n\r\nexports.SimpleXMLParser = SimpleXMLParser;\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.OptionalContentConfig = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nclass OptionalContentGroup {\r\n  constructor(name, intent) {\r\n    this.visible = true;\r\n    this.name = name;\r\n    this.intent = intent;\r\n  }\r\n\r\n}\r\n\r\nclass OptionalContentConfig {\r\n  constructor(data) {\r\n    this.name = null;\r\n    this.creator = null;\r\n    this._order = null;\r\n    this._groups = new Map();\r\n\r\n    if (data === null) {\r\n      return;\r\n    }\r\n\r\n    this.name = data.name;\r\n    this.creator = data.creator;\r\n    this._order = data.order;\r\n\r\n    for (const group of data.groups) {\r\n      this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\r\n    }\r\n\r\n    if (data.baseState === \"OFF\") {\r\n      for (const group of this._groups) {\r\n        group.visible = false;\r\n      }\r\n    }\r\n\r\n    for (const on of data.on) {\r\n      this._groups.get(on).visible = true;\r\n    }\r\n\r\n    for (const off of data.off) {\r\n      this._groups.get(off).visible = false;\r\n    }\r\n  }\r\n\r\n  isVisible(group) {\r\n    if (group.type === \"OCG\") {\r\n      if (!this._groups.has(group.id)) {\r\n        (0, _util.warn)(`Optional content group not found: ${group.id}`);\r\n        return true;\r\n      }\r\n\r\n      return this._groups.get(group.id).visible;\r\n    } else if (group.type === \"OCMD\") {\r\n      if (group.expression) {\r\n        (0, _util.warn)(\"Visibility expression not supported yet.\");\r\n      }\r\n\r\n      if (!group.policy || group.policy === \"AnyOn\") {\r\n        for (const id of group.ids) {\r\n          if (!this._groups.has(id)) {\r\n            (0, _util.warn)(`Optional content group not found: ${id}`);\r\n            return true;\r\n          }\r\n\r\n          if (this._groups.get(id).visible) {\r\n            return true;\r\n          }\r\n        }\r\n\r\n        return false;\r\n      } else if (group.policy === \"AllOn\") {\r\n        for (const id of group.ids) {\r\n          if (!this._groups.has(id)) {\r\n            (0, _util.warn)(`Optional content group not found: ${id}`);\r\n            return true;\r\n          }\r\n\r\n          if (!this._groups.get(id).visible) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        return true;\r\n      } else if (group.policy === \"AnyOff\") {\r\n        for (const id of group.ids) {\r\n          if (!this._groups.has(id)) {\r\n            (0, _util.warn)(`Optional content group not found: ${id}`);\r\n            return true;\r\n          }\r\n\r\n          if (!this._groups.get(id).visible) {\r\n            return true;\r\n          }\r\n        }\r\n\r\n        return false;\r\n      } else if (group.policy === \"AllOff\") {\r\n        for (const id of group.ids) {\r\n          if (!this._groups.has(id)) {\r\n            (0, _util.warn)(`Optional content group not found: ${id}`);\r\n            return true;\r\n          }\r\n\r\n          if (this._groups.get(id).visible) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\r\n      return true;\r\n    }\r\n\r\n    (0, _util.warn)(`Unknown group type ${group.type}.`);\r\n    return true;\r\n  }\r\n\r\n  setVisibility(id, visible = true) {\r\n    if (!this._groups.has(id)) {\r\n      (0, _util.warn)(`Optional content group not found: ${id}`);\r\n      return;\r\n    }\r\n\r\n    this._groups.get(id).visible = !!visible;\r\n  }\r\n\r\n  getOrder() {\r\n    if (!this._groups.size) {\r\n      return null;\r\n    }\r\n\r\n    if (this._order) {\r\n      return this._order.slice();\r\n    }\r\n\r\n    return Array.from(this._groups.keys());\r\n  }\r\n\r\n  getGroups() {\r\n    if (!this._groups.size) {\r\n      return null;\r\n    }\r\n\r\n    return (0, _util.objectFromEntries)(this._groups);\r\n  }\r\n\r\n  getGroup(id) {\r\n    return this._groups.get(id) || null;\r\n  }\r\n\r\n}\r\n\r\nexports.OptionalContentConfig = OptionalContentConfig;\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.PDFDataTransportStream = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nclass PDFDataTransportStream {\r\n  constructor(params, pdfDataRangeTransport) {\r\n    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\r\n    this._queuedChunks = [];\r\n    this._progressiveDone = params.progressiveDone || false;\r\n    const initialData = params.initialData;\r\n\r\n    if (initialData?.length > 0) {\r\n      const buffer = new Uint8Array(initialData).buffer;\r\n\r\n      this._queuedChunks.push(buffer);\r\n    }\r\n\r\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\r\n    this._isStreamingSupported = !params.disableStream;\r\n    this._isRangeSupported = !params.disableRange;\r\n    this._contentLength = params.length;\r\n    this._fullRequestReader = null;\r\n    this._rangeReaders = [];\r\n\r\n    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {\r\n      this._onReceiveData({\r\n        begin,\r\n        chunk\r\n      });\r\n    });\r\n\r\n    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {\r\n      this._onProgress({\r\n        loaded,\r\n        total\r\n      });\r\n    });\r\n\r\n    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {\r\n      this._onReceiveData({\r\n        chunk\r\n      });\r\n    });\r\n\r\n    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {\r\n      this._onProgressiveDone();\r\n    });\r\n\r\n    this._pdfDataRangeTransport.transportReady();\r\n  }\r\n\r\n  _onReceiveData(args) {\r\n    const buffer = new Uint8Array(args.chunk).buffer;\r\n\r\n    if (args.begin === undefined) {\r\n      if (this._fullRequestReader) {\r\n        this._fullRequestReader._enqueue(buffer);\r\n      } else {\r\n        this._queuedChunks.push(buffer);\r\n      }\r\n    } else {\r\n      const found = this._rangeReaders.some(function (rangeReader) {\r\n        if (rangeReader._begin !== args.begin) {\r\n          return false;\r\n        }\r\n\r\n        rangeReader._enqueue(buffer);\r\n\r\n        return true;\r\n      });\r\n\r\n      (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\r\n    }\r\n  }\r\n\r\n  get _progressiveDataLength() {\r\n    return this._fullRequestReader?._loaded ?? 0;\r\n  }\r\n\r\n  _onProgress(evt) {\r\n    if (evt.total === undefined) {\r\n      const firstReader = this._rangeReaders[0];\r\n\r\n      if (firstReader?.onProgress) {\r\n        firstReader.onProgress({\r\n          loaded: evt.loaded\r\n        });\r\n      }\r\n    } else {\r\n      const fullReader = this._fullRequestReader;\r\n\r\n      if (fullReader?.onProgress) {\r\n        fullReader.onProgress({\r\n          loaded: evt.loaded,\r\n          total: evt.total\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  _onProgressiveDone() {\r\n    if (this._fullRequestReader) {\r\n      this._fullRequestReader.progressiveDone();\r\n    }\r\n\r\n    this._progressiveDone = true;\r\n  }\r\n\r\n  _removeRangeReader(reader) {\r\n    const i = this._rangeReaders.indexOf(reader);\r\n\r\n    if (i >= 0) {\r\n      this._rangeReaders.splice(i, 1);\r\n    }\r\n  }\r\n\r\n  getFullReader() {\r\n    (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\r\n    const queuedChunks = this._queuedChunks;\r\n    this._queuedChunks = null;\r\n    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone);\r\n  }\r\n\r\n  getRangeReader(begin, end) {\r\n    if (end <= this._progressiveDataLength) {\r\n      return null;\r\n    }\r\n\r\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\r\n\r\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\r\n\r\n    this._rangeReaders.push(reader);\r\n\r\n    return reader;\r\n  }\r\n\r\n  cancelAllRequests(reason) {\r\n    if (this._fullRequestReader) {\r\n      this._fullRequestReader.cancel(reason);\r\n    }\r\n\r\n    const readers = this._rangeReaders.slice(0);\r\n\r\n    readers.forEach(function (rangeReader) {\r\n      rangeReader.cancel(reason);\r\n    });\r\n\r\n    this._pdfDataRangeTransport.abort();\r\n  }\r\n\r\n}\r\n\r\nexports.PDFDataTransportStream = PDFDataTransportStream;\r\n\r\nclass PDFDataTransportStreamReader {\r\n  constructor(stream, queuedChunks, progressiveDone = false) {\r\n    this._stream = stream;\r\n    this._done = progressiveDone || false;\r\n    this._filename = null;\r\n    this._queuedChunks = queuedChunks || [];\r\n    this._loaded = 0;\r\n\r\n    for (const chunk of this._queuedChunks) {\r\n      this._loaded += chunk.byteLength;\r\n    }\r\n\r\n    this._requests = [];\r\n    this._headersReady = Promise.resolve();\r\n    stream._fullRequestReader = this;\r\n    this.onProgress = null;\r\n  }\r\n\r\n  _enqueue(chunk) {\r\n    if (this._done) {\r\n      return;\r\n    }\r\n\r\n    if (this._requests.length > 0) {\r\n      const requestCapability = this._requests.shift();\r\n\r\n      requestCapability.resolve({\r\n        value: chunk,\r\n        done: false\r\n      });\r\n    } else {\r\n      this._queuedChunks.push(chunk);\r\n    }\r\n\r\n    this._loaded += chunk.byteLength;\r\n  }\r\n\r\n  get headersReady() {\r\n    return this._headersReady;\r\n  }\r\n\r\n  get filename() {\r\n    return this._filename;\r\n  }\r\n\r\n  get isRangeSupported() {\r\n    return this._stream._isRangeSupported;\r\n  }\r\n\r\n  get isStreamingSupported() {\r\n    return this._stream._isStreamingSupported;\r\n  }\r\n\r\n  get contentLength() {\r\n    return this._stream._contentLength;\r\n  }\r\n\r\n  async read() {\r\n    if (this._queuedChunks.length > 0) {\r\n      const chunk = this._queuedChunks.shift();\r\n\r\n      return {\r\n        value: chunk,\r\n        done: false\r\n      };\r\n    }\r\n\r\n    if (this._done) {\r\n      return {\r\n        value: undefined,\r\n        done: true\r\n      };\r\n    }\r\n\r\n    const requestCapability = (0, _util.createPromiseCapability)();\r\n\r\n    this._requests.push(requestCapability);\r\n\r\n    return requestCapability.promise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    this._done = true;\r\n\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    });\r\n\r\n    this._requests = [];\r\n  }\r\n\r\n  progressiveDone() {\r\n    if (this._done) {\r\n      return;\r\n    }\r\n\r\n    this._done = true;\r\n  }\r\n\r\n}\r\n\r\nclass PDFDataTransportStreamRangeReader {\r\n  constructor(stream, begin, end) {\r\n    this._stream = stream;\r\n    this._begin = begin;\r\n    this._end = end;\r\n    this._queuedChunk = null;\r\n    this._requests = [];\r\n    this._done = false;\r\n    this.onProgress = null;\r\n  }\r\n\r\n  _enqueue(chunk) {\r\n    if (this._done) {\r\n      return;\r\n    }\r\n\r\n    if (this._requests.length === 0) {\r\n      this._queuedChunk = chunk;\r\n    } else {\r\n      const requestsCapability = this._requests.shift();\r\n\r\n      requestsCapability.resolve({\r\n        value: chunk,\r\n        done: false\r\n      });\r\n\r\n      this._requests.forEach(function (requestCapability) {\r\n        requestCapability.resolve({\r\n          value: undefined,\r\n          done: true\r\n        });\r\n      });\r\n\r\n      this._requests = [];\r\n    }\r\n\r\n    this._done = true;\r\n\r\n    this._stream._removeRangeReader(this);\r\n  }\r\n\r\n  get isStreamingSupported() {\r\n    return false;\r\n  }\r\n\r\n  async read() {\r\n    if (this._queuedChunk) {\r\n      const chunk = this._queuedChunk;\r\n      this._queuedChunk = null;\r\n      return {\r\n        value: chunk,\r\n        done: false\r\n      };\r\n    }\r\n\r\n    if (this._done) {\r\n      return {\r\n        value: undefined,\r\n        done: true\r\n      };\r\n    }\r\n\r\n    const requestCapability = (0, _util.createPromiseCapability)();\r\n\r\n    this._requests.push(requestCapability);\r\n\r\n    return requestCapability.promise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    this._done = true;\r\n\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    });\r\n\r\n    this._requests = [];\r\n\r\n    this._stream._removeRangeReader(this);\r\n  }\r\n\r\n}\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.WebGLContext = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nclass WebGLContext {\r\n  constructor({\r\n    enable = false\r\n  }) {\r\n    this._enabled = enable === true;\r\n  }\r\n\r\n  get isEnabled() {\r\n    let enabled = this._enabled;\r\n\r\n    if (enabled) {\r\n      enabled = WebGLUtils.tryInitGL();\r\n    }\r\n\r\n    return (0, _util.shadow)(this, \"isEnabled\", enabled);\r\n  }\r\n\r\n  composeSMask({\r\n    layer,\r\n    mask,\r\n    properties\r\n  }) {\r\n    return WebGLUtils.composeSMask(layer, mask, properties);\r\n  }\r\n\r\n  drawFigures({\r\n    width,\r\n    height,\r\n    backgroundColor,\r\n    figures,\r\n    context\r\n  }) {\r\n    return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);\r\n  }\r\n\r\n  clear() {\r\n    WebGLUtils.cleanup();\r\n  }\r\n\r\n}\r\n\r\nexports.WebGLContext = WebGLContext;\r\n\r\nconst WebGLUtils = function WebGLUtilsClosure() {\r\n  function loadShader(gl, code, shaderType) {\r\n    const shader = gl.createShader(shaderType);\r\n    gl.shaderSource(shader, code);\r\n    gl.compileShader(shader);\r\n    const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n\r\n    if (!compiled) {\r\n      const errorMsg = gl.getShaderInfoLog(shader);\r\n      throw new Error(\"Error during shader compilation: \" + errorMsg);\r\n    }\r\n\r\n    return shader;\r\n  }\r\n\r\n  function createVertexShader(gl, code) {\r\n    return loadShader(gl, code, gl.VERTEX_SHADER);\r\n  }\r\n\r\n  function createFragmentShader(gl, code) {\r\n    return loadShader(gl, code, gl.FRAGMENT_SHADER);\r\n  }\r\n\r\n  function createProgram(gl, shaders) {\r\n    const program = gl.createProgram();\r\n\r\n    for (let i = 0, ii = shaders.length; i < ii; ++i) {\r\n      gl.attachShader(program, shaders[i]);\r\n    }\r\n\r\n    gl.linkProgram(program);\r\n    const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n\r\n    if (!linked) {\r\n      const errorMsg = gl.getProgramInfoLog(program);\r\n      throw new Error(\"Error during program linking: \" + errorMsg);\r\n    }\r\n\r\n    return program;\r\n  }\r\n\r\n  function createTexture(gl, image, textureId) {\r\n    gl.activeTexture(textureId);\r\n    const texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n    return texture;\r\n  }\r\n\r\n  let currentGL, currentCanvas;\r\n\r\n  function generateGL() {\r\n    if (currentGL) {\r\n      return;\r\n    }\r\n\r\n    currentCanvas = document.createElement(\"canvas\");\r\n    currentGL = currentCanvas.getContext(\"webgl\", {\r\n      premultipliedalpha: false\r\n    });\r\n  }\r\n\r\n  const smaskVertexShaderCode = \"\\\r\n  attribute vec2 a_position;                                    \\\r\n  attribute vec2 a_texCoord;                                    \\\r\n                                                                \\\r\n  uniform vec2 u_resolution;                                    \\\r\n                                                                \\\r\n  varying vec2 v_texCoord;                                      \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \\\r\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\r\n                                                                \\\r\n    v_texCoord = a_texCoord;                                    \\\r\n  }                                                             \";\r\n  const smaskFragmentShaderCode = \"\\\r\n  precision mediump float;                                      \\\r\n                                                                \\\r\n  uniform vec4 u_backdrop;                                      \\\r\n  uniform int u_subtype;                                        \\\r\n  uniform sampler2D u_image;                                    \\\r\n  uniform sampler2D u_mask;                                     \\\r\n                                                                \\\r\n  varying vec2 v_texCoord;                                      \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    vec4 imageColor = texture2D(u_image, v_texCoord);           \\\r\n    vec4 maskColor = texture2D(u_mask, v_texCoord);             \\\r\n    if (u_backdrop.a > 0.0) {                                   \\\r\n      maskColor.rgb = maskColor.rgb * maskColor.a +             \\\r\n                      u_backdrop.rgb * (1.0 - maskColor.a);     \\\r\n    }                                                           \\\r\n    float lum;                                                  \\\r\n    if (u_subtype == 0) {                                       \\\r\n      lum = maskColor.a;                                        \\\r\n    } else {                                                    \\\r\n      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \\\r\n            maskColor.b * 0.11;                                 \\\r\n    }                                                           \\\r\n    imageColor.a *= lum;                                        \\\r\n    imageColor.rgb *= imageColor.a;                             \\\r\n    gl_FragColor = imageColor;                                  \\\r\n  }                                                             \";\r\n  let smaskCache = null;\r\n\r\n  function initSmaskGL() {\r\n    generateGL();\r\n    const canvas = currentCanvas;\r\n    currentCanvas = null;\r\n    const gl = currentGL;\r\n    currentGL = null;\r\n    const vertexShader = createVertexShader(gl, smaskVertexShaderCode);\r\n    const fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);\r\n    const program = createProgram(gl, [vertexShader, fragmentShader]);\r\n    gl.useProgram(program);\r\n    const cache = {};\r\n    cache.gl = gl;\r\n    cache.canvas = canvas;\r\n    cache.resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\r\n    cache.positionLocation = gl.getAttribLocation(program, \"a_position\");\r\n    cache.backdropLocation = gl.getUniformLocation(program, \"u_backdrop\");\r\n    cache.subtypeLocation = gl.getUniformLocation(program, \"u_subtype\");\r\n    const texCoordLocation = gl.getAttribLocation(program, \"a_texCoord\");\r\n    const texLayerLocation = gl.getUniformLocation(program, \"u_image\");\r\n    const texMaskLocation = gl.getUniformLocation(program, \"u_mask\");\r\n    const texCoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);\r\n    gl.enableVertexAttribArray(texCoordLocation);\r\n    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n    gl.uniform1i(texLayerLocation, 0);\r\n    gl.uniform1i(texMaskLocation, 1);\r\n    smaskCache = cache;\r\n  }\r\n\r\n  function composeSMask(layer, mask, properties) {\r\n    const width = layer.width,\r\n          height = layer.height;\r\n\r\n    if (!smaskCache) {\r\n      initSmaskGL();\r\n    }\r\n\r\n    const cache = smaskCache,\r\n          canvas = cache.canvas,\r\n          gl = cache.gl;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n    gl.uniform2f(cache.resolutionLocation, width, height);\r\n\r\n    if (properties.backdrop) {\r\n      gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);\r\n    } else {\r\n      gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);\r\n    }\r\n\r\n    gl.uniform1i(cache.subtypeLocation, properties.subtype === \"Luminosity\" ? 1 : 0);\r\n    const texture = createTexture(gl, layer, gl.TEXTURE0);\r\n    const maskTexture = createTexture(gl, mask, gl.TEXTURE1);\r\n    const buffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);\r\n    gl.enableVertexAttribArray(cache.positionLocation);\r\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    gl.flush();\r\n    gl.deleteTexture(texture);\r\n    gl.deleteTexture(maskTexture);\r\n    gl.deleteBuffer(buffer);\r\n    return canvas;\r\n  }\r\n\r\n  const figuresVertexShaderCode = \"\\\r\n  attribute vec2 a_position;                                    \\\r\n  attribute vec3 a_color;                                       \\\r\n                                                                \\\r\n  uniform vec2 u_resolution;                                    \\\r\n  uniform vec2 u_scale;                                         \\\r\n  uniform vec2 u_offset;                                        \\\r\n                                                                \\\r\n  varying vec4 v_color;                                         \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    vec2 position = (a_position + u_offset) * u_scale;          \\\r\n    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \\\r\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\r\n                                                                \\\r\n    v_color = vec4(a_color / 255.0, 1.0);                       \\\r\n  }                                                             \";\r\n  const figuresFragmentShaderCode = \"\\\r\n  precision mediump float;                                      \\\r\n                                                                \\\r\n  varying vec4 v_color;                                         \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    gl_FragColor = v_color;                                     \\\r\n  }                                                             \";\r\n  let figuresCache = null;\r\n\r\n  function initFiguresGL() {\r\n    generateGL();\r\n    const canvas = currentCanvas;\r\n    currentCanvas = null;\r\n    const gl = currentGL;\r\n    currentGL = null;\r\n    const vertexShader = createVertexShader(gl, figuresVertexShaderCode);\r\n    const fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);\r\n    const program = createProgram(gl, [vertexShader, fragmentShader]);\r\n    gl.useProgram(program);\r\n    const cache = {};\r\n    cache.gl = gl;\r\n    cache.canvas = canvas;\r\n    cache.resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\r\n    cache.scaleLocation = gl.getUniformLocation(program, \"u_scale\");\r\n    cache.offsetLocation = gl.getUniformLocation(program, \"u_offset\");\r\n    cache.positionLocation = gl.getAttribLocation(program, \"a_position\");\r\n    cache.colorLocation = gl.getAttribLocation(program, \"a_color\");\r\n    figuresCache = cache;\r\n  }\r\n\r\n  function drawFigures(width, height, backgroundColor, figures, context) {\r\n    if (!figuresCache) {\r\n      initFiguresGL();\r\n    }\r\n\r\n    const cache = figuresCache,\r\n          canvas = cache.canvas,\r\n          gl = cache.gl;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n    gl.uniform2f(cache.resolutionLocation, width, height);\r\n    let count = 0;\r\n\r\n    for (let i = 0, ii = figures.length; i < ii; i++) {\r\n      switch (figures[i].type) {\r\n        case \"lattice\":\r\n          const rows = figures[i].coords.length / figures[i].verticesPerRow | 0;\r\n          count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;\r\n          break;\r\n\r\n        case \"triangles\":\r\n          count += figures[i].coords.length;\r\n          break;\r\n      }\r\n    }\r\n\r\n    const coords = new Float32Array(count * 2);\r\n    const colors = new Uint8Array(count * 3);\r\n    const coordsMap = context.coords,\r\n          colorsMap = context.colors;\r\n    let pIndex = 0,\r\n        cIndex = 0;\r\n\r\n    for (let i = 0, ii = figures.length; i < ii; i++) {\r\n      const figure = figures[i],\r\n            ps = figure.coords,\r\n            cs = figure.colors;\r\n\r\n      switch (figure.type) {\r\n        case \"lattice\":\r\n          const cols = figure.verticesPerRow;\r\n          const rows = ps.length / cols | 0;\r\n\r\n          for (let row = 1; row < rows; row++) {\r\n            let offset = row * cols + 1;\r\n\r\n            for (let col = 1; col < cols; col++, offset++) {\r\n              coords[pIndex] = coordsMap[ps[offset - cols - 1]];\r\n              coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];\r\n              coords[pIndex + 2] = coordsMap[ps[offset - cols]];\r\n              coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];\r\n              coords[pIndex + 4] = coordsMap[ps[offset - 1]];\r\n              coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];\r\n              colors[cIndex] = colorsMap[cs[offset - cols - 1]];\r\n              colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];\r\n              colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];\r\n              colors[cIndex + 3] = colorsMap[cs[offset - cols]];\r\n              colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];\r\n              colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];\r\n              colors[cIndex + 6] = colorsMap[cs[offset - 1]];\r\n              colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];\r\n              colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];\r\n              coords[pIndex + 6] = coords[pIndex + 2];\r\n              coords[pIndex + 7] = coords[pIndex + 3];\r\n              coords[pIndex + 8] = coords[pIndex + 4];\r\n              coords[pIndex + 9] = coords[pIndex + 5];\r\n              coords[pIndex + 10] = coordsMap[ps[offset]];\r\n              coords[pIndex + 11] = coordsMap[ps[offset] + 1];\r\n              colors[cIndex + 9] = colors[cIndex + 3];\r\n              colors[cIndex + 10] = colors[cIndex + 4];\r\n              colors[cIndex + 11] = colors[cIndex + 5];\r\n              colors[cIndex + 12] = colors[cIndex + 6];\r\n              colors[cIndex + 13] = colors[cIndex + 7];\r\n              colors[cIndex + 14] = colors[cIndex + 8];\r\n              colors[cIndex + 15] = colorsMap[cs[offset]];\r\n              colors[cIndex + 16] = colorsMap[cs[offset] + 1];\r\n              colors[cIndex + 17] = colorsMap[cs[offset] + 2];\r\n              pIndex += 12;\r\n              cIndex += 18;\r\n            }\r\n          }\r\n\r\n          break;\r\n\r\n        case \"triangles\":\r\n          for (let j = 0, jj = ps.length; j < jj; j++) {\r\n            coords[pIndex] = coordsMap[ps[j]];\r\n            coords[pIndex + 1] = coordsMap[ps[j] + 1];\r\n            colors[cIndex] = colorsMap[cs[j]];\r\n            colors[cIndex + 1] = colorsMap[cs[j] + 1];\r\n            colors[cIndex + 2] = colorsMap[cs[j] + 2];\r\n            pIndex += 2;\r\n            cIndex += 3;\r\n          }\r\n\r\n          break;\r\n      }\r\n    }\r\n\r\n    if (backgroundColor) {\r\n      gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);\r\n    } else {\r\n      gl.clearColor(0, 0, 0, 0);\r\n    }\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    const coordsBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);\r\n    gl.enableVertexAttribArray(cache.positionLocation);\r\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\r\n    const colorsBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\r\n    gl.enableVertexAttribArray(cache.colorLocation);\r\n    gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);\r\n    gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);\r\n    gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);\r\n    gl.drawArrays(gl.TRIANGLES, 0, count);\r\n    gl.flush();\r\n    gl.deleteBuffer(coordsBuffer);\r\n    gl.deleteBuffer(colorsBuffer);\r\n    return canvas;\r\n  }\r\n\r\n  return {\r\n    tryInitGL() {\r\n      try {\r\n        generateGL();\r\n        return !!currentGL;\r\n      } catch (ex) {}\r\n\r\n      return false;\r\n    },\r\n\r\n    composeSMask,\r\n    drawFigures,\r\n\r\n    cleanup() {\r\n      if (smaskCache?.canvas) {\r\n        smaskCache.canvas.width = 0;\r\n        smaskCache.canvas.height = 0;\r\n      }\r\n\r\n      if (figuresCache?.canvas) {\r\n        figuresCache.canvas.width = 0;\r\n        figuresCache.canvas.height = 0;\r\n      }\r\n\r\n      smaskCache = null;\r\n      figuresCache = null;\r\n    }\r\n\r\n  };\r\n}();\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.AnnotationLayer = void 0;\r\n\r\nvar _display_utils = __w_pdfjs_require__(1);\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nvar _annotation_storage = __w_pdfjs_require__(8);\r\n\r\nvar _scripting_utils = __w_pdfjs_require__(20);\r\n\r\nclass AnnotationElementFactory {\r\n  static create(parameters) {\r\n    const subtype = parameters.data.annotationType;\r\n\r\n    switch (subtype) {\r\n      case _util.AnnotationType.LINK:\r\n        return new LinkAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.TEXT:\r\n        return new TextAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.WIDGET:\r\n        const fieldType = parameters.data.fieldType;\r\n\r\n        switch (fieldType) {\r\n          case \"Tx\":\r\n            return new TextWidgetAnnotationElement(parameters);\r\n\r\n          case \"Btn\":\r\n            if (parameters.data.radioButton) {\r\n              return new RadioButtonWidgetAnnotationElement(parameters);\r\n            } else if (parameters.data.checkBox) {\r\n              return new CheckboxWidgetAnnotationElement(parameters);\r\n            }\r\n\r\n            return new PushButtonWidgetAnnotationElement(parameters);\r\n\r\n          case \"Ch\":\r\n            return new ChoiceWidgetAnnotationElement(parameters);\r\n        }\r\n\r\n        return new WidgetAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.POPUP:\r\n        return new PopupAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.FREETEXT:\r\n        return new FreeTextAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.LINE:\r\n        return new LineAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.SQUARE:\r\n        return new SquareAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.CIRCLE:\r\n        return new CircleAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.POLYLINE:\r\n        return new PolylineAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.CARET:\r\n        return new CaretAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.INK:\r\n        return new InkAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.POLYGON:\r\n        return new PolygonAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.HIGHLIGHT:\r\n        return new HighlightAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.UNDERLINE:\r\n        return new UnderlineAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.SQUIGGLY:\r\n        return new SquigglyAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.STRIKEOUT:\r\n        return new StrikeOutAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.STAMP:\r\n        return new StampAnnotationElement(parameters);\r\n\r\n      case _util.AnnotationType.FILEATTACHMENT:\r\n        return new FileAttachmentAnnotationElement(parameters);\r\n\r\n      default:\r\n        return new AnnotationElement(parameters);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nclass AnnotationElement {\r\n  constructor(parameters, {\r\n    isRenderable = false,\r\n    ignoreBorder = false,\r\n    createQuadrilaterals = false\r\n  } = {}) {\r\n    this.isRenderable = isRenderable;\r\n    this.data = parameters.data;\r\n    this.layer = parameters.layer;\r\n    this.page = parameters.page;\r\n    this.viewport = parameters.viewport;\r\n    this.linkService = parameters.linkService;\r\n    this.downloadManager = parameters.downloadManager;\r\n    this.imageResourcesPath = parameters.imageResourcesPath;\r\n    this.renderInteractiveForms = parameters.renderInteractiveForms;\r\n    this.svgFactory = parameters.svgFactory;\r\n    this.annotationStorage = parameters.annotationStorage;\r\n    this.enableScripting = parameters.enableScripting;\r\n    this.hasJSActions = parameters.hasJSActions;\r\n    this._mouseState = parameters.mouseState;\r\n\r\n    if (isRenderable) {\r\n      this.container = this._createContainer(ignoreBorder);\r\n    }\r\n\r\n    if (createQuadrilaterals) {\r\n      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);\r\n    }\r\n  }\r\n\r\n  _createContainer(ignoreBorder = false) {\r\n    const data = this.data,\r\n          page = this.page,\r\n          viewport = this.viewport;\r\n    const container = document.createElement(\"section\");\r\n    let width = data.rect[2] - data.rect[0];\r\n    let height = data.rect[3] - data.rect[1];\r\n    container.setAttribute(\"data-annotation-id\", data.id);\r\n\r\n    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\r\n\r\n    container.style.transform = `matrix(${viewport.transform.join(\",\")})`;\r\n    container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;\r\n\r\n    if (!ignoreBorder && data.borderStyle.width > 0) {\r\n      container.style.borderWidth = `${data.borderStyle.width}px`;\r\n\r\n      if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {\r\n        width = width - 2 * data.borderStyle.width;\r\n        height = height - 2 * data.borderStyle.width;\r\n      }\r\n\r\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\r\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\r\n\r\n      if (horizontalRadius > 0 || verticalRadius > 0) {\r\n        const radius = `${horizontalRadius}px / ${verticalRadius}px`;\r\n        container.style.borderRadius = radius;\r\n      }\r\n\r\n      switch (data.borderStyle.style) {\r\n        case _util.AnnotationBorderStyleType.SOLID:\r\n          container.style.borderStyle = \"solid\";\r\n          break;\r\n\r\n        case _util.AnnotationBorderStyleType.DASHED:\r\n          container.style.borderStyle = \"dashed\";\r\n          break;\r\n\r\n        case _util.AnnotationBorderStyleType.BEVELED:\r\n          (0, _util.warn)(\"Unimplemented border style: beveled\");\r\n          break;\r\n\r\n        case _util.AnnotationBorderStyleType.INSET:\r\n          (0, _util.warn)(\"Unimplemented border style: inset\");\r\n          break;\r\n\r\n        case _util.AnnotationBorderStyleType.UNDERLINE:\r\n          container.style.borderBottomStyle = \"solid\";\r\n          break;\r\n\r\n        default:\r\n          break;\r\n      }\r\n\r\n      if (data.color) {\r\n        container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);\r\n      } else {\r\n        container.style.borderWidth = 0;\r\n      }\r\n    }\r\n\r\n    container.style.left = `${rect[0]}px`;\r\n    container.style.top = `${rect[1]}px`;\r\n    container.style.width = `${width}px`;\r\n    container.style.height = `${height}px`;\r\n    return container;\r\n  }\r\n\r\n  _createQuadrilaterals(ignoreBorder = false) {\r\n    if (!this.data.quadPoints) {\r\n      return null;\r\n    }\r\n\r\n    const quadrilaterals = [];\r\n    const savedRect = this.data.rect;\r\n\r\n    for (const quadPoint of this.data.quadPoints) {\r\n      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];\r\n      quadrilaterals.push(this._createContainer(ignoreBorder));\r\n    }\r\n\r\n    this.data.rect = savedRect;\r\n    return quadrilaterals;\r\n  }\r\n\r\n  _createPopup(trigger, data) {\r\n    let container = this.container;\r\n\r\n    if (this.quadrilaterals) {\r\n      trigger = trigger || this.quadrilaterals;\r\n      container = this.quadrilaterals[0];\r\n    }\r\n\r\n    if (!trigger) {\r\n      trigger = document.createElement(\"div\");\r\n      trigger.style.height = container.style.height;\r\n      trigger.style.width = container.style.width;\r\n      container.appendChild(trigger);\r\n    }\r\n\r\n    const popupElement = new PopupElement({\r\n      container,\r\n      trigger,\r\n      color: data.color,\r\n      title: data.title,\r\n      modificationDate: data.modificationDate,\r\n      contents: data.contents,\r\n      hideWrapper: true\r\n    });\r\n    const popup = popupElement.render();\r\n    popup.style.left = container.style.width;\r\n    container.appendChild(popup);\r\n  }\r\n\r\n  _renderQuadrilaterals(className) {\r\n    this.quadrilaterals.forEach(quadrilateral => {\r\n      quadrilateral.className = className;\r\n    });\r\n    return this.quadrilaterals;\r\n  }\r\n\r\n  render() {\r\n    (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\r\n  }\r\n\r\n}\r\n\r\nclass LinkAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions[\"Mouse Up\"] || parameters.data.actions[\"Mouse Down\"]));\r\n    super(parameters, {\r\n      isRenderable,\r\n      createQuadrilaterals: true\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      data,\r\n      linkService\r\n    } = this;\r\n    const link = document.createElement(\"a\");\r\n\r\n    if (data.url) {\r\n      (0, _display_utils.addLinkAttributes)(link, {\r\n        url: data.url,\r\n        target: data.newWindow ? _display_utils.LinkTarget.BLANK : linkService.externalLinkTarget,\r\n        rel: linkService.externalLinkRel,\r\n        enabled: linkService.externalLinkEnabled\r\n      });\r\n    } else if (data.action) {\r\n      this._bindNamedAction(link, data.action);\r\n    } else if (data.dest) {\r\n      this._bindLink(link, data.dest);\r\n    } else if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\r\n      this._bindJSAction(link, data);\r\n    } else {\r\n      this._bindLink(link, \"\");\r\n    }\r\n\r\n    if (this.quadrilaterals) {\r\n      return this._renderQuadrilaterals(\"linkAnnotation\").map((quadrilateral, index) => {\r\n        const linkElement = index === 0 ? link : link.cloneNode();\r\n        quadrilateral.appendChild(linkElement);\r\n        return quadrilateral;\r\n      });\r\n    }\r\n\r\n    this.container.className = \"linkAnnotation\";\r\n    this.container.appendChild(link);\r\n    return this.container;\r\n  }\r\n\r\n  _bindLink(link, destination) {\r\n    link.href = this.linkService.getDestinationHash(destination);\r\n\r\n    link.onclick = () => {\r\n      if (destination) {\r\n        this.linkService.goToDestination(destination);\r\n      }\r\n\r\n      return false;\r\n    };\r\n\r\n    if (destination || destination === \"\") {\r\n      link.className = \"internalLink\";\r\n    }\r\n  }\r\n\r\n  _bindNamedAction(link, action) {\r\n    link.href = this.linkService.getAnchorUrl(\"\");\r\n\r\n    link.onclick = () => {\r\n      this.linkService.executeNamedAction(action);\r\n      return false;\r\n    };\r\n\r\n    link.className = \"internalLink\";\r\n  }\r\n\r\n  _bindJSAction(link, data) {\r\n    link.href = this.linkService.getAnchorUrl(\"\");\r\n    const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\r\n\r\n    for (const name of Object.keys(data.actions)) {\r\n      const jsName = map.get(name);\r\n\r\n      if (!jsName) {\r\n        continue;\r\n      }\r\n\r\n      link[jsName] = () => {\r\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\r\n          source: this,\r\n          detail: {\r\n            id: data.id,\r\n            name\r\n          }\r\n        });\r\n        return false;\r\n      };\r\n    }\r\n\r\n    link.className = \"internalLink\";\r\n  }\r\n\r\n}\r\n\r\nclass TextAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable\r\n    });\r\n  }\r\n\r\n  render() {\r\n    this.container.className = \"textAnnotation\";\r\n    const image = document.createElement(\"img\");\r\n    image.style.height = this.container.style.height;\r\n    image.style.width = this.container.style.width;\r\n    image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\r\n    image.alt = \"[{{type}} Annotation]\";\r\n    image.dataset.l10nId = \"text_annotation_type\";\r\n    image.dataset.l10nArgs = JSON.stringify({\r\n      type: this.data.name\r\n    });\r\n\r\n    if (!this.data.hasPopup) {\r\n      this._createPopup(image, this.data);\r\n    }\r\n\r\n    this.container.appendChild(image);\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass WidgetAnnotationElement extends AnnotationElement {\r\n  render() {\r\n    if (this.data.alternativeText) {\r\n      this.container.title = this.data.alternativeText;\r\n    }\r\n\r\n    return this.container;\r\n  }\r\n\r\n  _getKeyModifier(event) {\r\n    return navigator.platform.includes(\"Win\") && event.ctrlKey || navigator.platform.includes(\"Mac\") && event.metaKey;\r\n  }\r\n\r\n  _setEventListener(element, baseName, eventName, valueGetter) {\r\n    if (baseName.includes(\"mouse\")) {\r\n      element.addEventListener(baseName, event => {\r\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\r\n          source: this,\r\n          detail: {\r\n            id: this.data.id,\r\n            name: eventName,\r\n            value: valueGetter(event),\r\n            shift: event.shiftKey,\r\n            modifier: this._getKeyModifier(event)\r\n          }\r\n        });\r\n      });\r\n    } else {\r\n      element.addEventListener(baseName, event => {\r\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\r\n          source: this,\r\n          detail: {\r\n            id: this.data.id,\r\n            name: eventName,\r\n            value: event.target.checked\r\n          }\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  _setEventListeners(element, names, getter) {\r\n    for (const [baseName, eventName] of names) {\r\n      if (eventName === \"Action\" || this.data.actions?.[eventName]) {\r\n        this._setEventListener(element, baseName, eventName, getter);\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\r\n    super(parameters, {\r\n      isRenderable\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const storage = this.annotationStorage;\r\n    const id = this.data.id;\r\n    this.container.className = \"textWidgetAnnotation\";\r\n    let element = null;\r\n\r\n    if (this.renderInteractiveForms) {\r\n      const textContent = storage.getOrCreateValue(id, {\r\n        value: this.data.fieldValue\r\n      }).value;\r\n      const elementData = {\r\n        userValue: null,\r\n        formattedValue: null,\r\n        beforeInputSelectionRange: null,\r\n        beforeInputValue: null\r\n      };\r\n\r\n      if (this.data.multiLine) {\r\n        element = document.createElement(\"textarea\");\r\n        element.textContent = textContent;\r\n      } else {\r\n        element = document.createElement(\"input\");\r\n        element.type = \"text\";\r\n        element.setAttribute(\"value\", textContent);\r\n      }\r\n\r\n      elementData.userValue = textContent;\r\n      element.setAttribute(\"id\", id);\r\n      element.addEventListener(\"input\", function (event) {\r\n        storage.setValue(id, {\r\n          value: event.target.value\r\n        });\r\n      });\r\n\r\n      let blurListener = event => {\r\n        if (elementData.formattedValue) {\r\n          event.target.value = elementData.formattedValue;\r\n        }\r\n\r\n        event.target.setSelectionRange(0, 0);\r\n        elementData.beforeInputSelectionRange = null;\r\n      };\r\n\r\n      if (this.enableScripting && this.hasJSActions) {\r\n        element.addEventListener(\"focus\", event => {\r\n          if (elementData.userValue) {\r\n            event.target.value = elementData.userValue;\r\n          }\r\n        });\r\n        element.addEventListener(\"updatefromsandbox\", function (event) {\r\n          const {\r\n            detail\r\n          } = event;\r\n          const actions = {\r\n            value() {\r\n              elementData.userValue = detail.value || \"\";\r\n              storage.setValue(id, {\r\n                value: elementData.userValue.toString()\r\n              });\r\n\r\n              if (!elementData.formattedValue) {\r\n                event.target.value = elementData.userValue;\r\n              }\r\n            },\r\n\r\n            valueAsString() {\r\n              elementData.formattedValue = detail.valueAsString || \"\";\r\n\r\n              if (event.target !== document.activeElement) {\r\n                event.target.value = elementData.formattedValue;\r\n              }\r\n\r\n              storage.setValue(id, {\r\n                formattedValue: elementData.formattedValue\r\n              });\r\n            },\r\n\r\n            focus() {\r\n              setTimeout(() => event.target.focus({\r\n                preventScroll: false\r\n              }), 0);\r\n            },\r\n\r\n            userName() {\r\n              event.target.title = detail.userName;\r\n            },\r\n\r\n            hidden() {\r\n              event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\r\n              storage.setValue(id, {\r\n                hidden: detail.hidden\r\n              });\r\n            },\r\n\r\n            editable() {\r\n              event.target.disabled = !detail.editable;\r\n            },\r\n\r\n            selRange() {\r\n              const [selStart, selEnd] = detail.selRange;\r\n\r\n              if (selStart >= 0 && selEnd < event.target.value.length) {\r\n                event.target.setSelectionRange(selStart, selEnd);\r\n              }\r\n            },\r\n\r\n            strokeColor() {\r\n              const color = detail.strokeColor;\r\n              event.target.style.color = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));\r\n            }\r\n\r\n          };\r\n          Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());\r\n        });\r\n\r\n        if (this.data.actions) {\r\n          element.addEventListener(\"keydown\", event => {\r\n            elementData.beforeInputValue = event.target.value;\r\n            let commitKey = -1;\r\n\r\n            if (event.key === \"Escape\") {\r\n              commitKey = 0;\r\n            } else if (event.key === \"Enter\") {\r\n              commitKey = 2;\r\n            } else if (event.key === \"Tab\") {\r\n              commitKey = 3;\r\n            }\r\n\r\n            if (commitKey === -1) {\r\n              return;\r\n            }\r\n\r\n            elementData.userValue = event.target.value;\r\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\r\n              source: this,\r\n              detail: {\r\n                id,\r\n                name: \"Keystroke\",\r\n                value: event.target.value,\r\n                willCommit: true,\r\n                commitKey,\r\n                selStart: event.target.selectionStart,\r\n                selEnd: event.target.selectionEnd\r\n              }\r\n            });\r\n          });\r\n          const _blurListener = blurListener;\r\n          blurListener = null;\r\n          element.addEventListener(\"blur\", event => {\r\n            if (this._mouseState.isDown) {\r\n              elementData.userValue = event.target.value;\r\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\r\n                source: this,\r\n                detail: {\r\n                  id,\r\n                  name: \"Keystroke\",\r\n                  value: event.target.value,\r\n                  willCommit: true,\r\n                  commitKey: 1,\r\n                  selStart: event.target.selectionStart,\r\n                  selEnd: event.target.selectionEnd\r\n                }\r\n              });\r\n            }\r\n\r\n            _blurListener(event);\r\n          });\r\n          element.addEventListener(\"mousedown\", event => {\r\n            elementData.beforeInputValue = event.target.value;\r\n            elementData.beforeInputSelectionRange = null;\r\n          });\r\n          element.addEventListener(\"keyup\", event => {\r\n            if (event.target.selectionStart === event.target.selectionEnd) {\r\n              elementData.beforeInputSelectionRange = null;\r\n            }\r\n          });\r\n          element.addEventListener(\"select\", event => {\r\n            elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];\r\n          });\r\n\r\n          if (\"Keystroke\" in this.data.actions) {\r\n            element.addEventListener(\"input\", event => {\r\n              let selStart = -1;\r\n              let selEnd = -1;\r\n\r\n              if (elementData.beforeInputSelectionRange) {\r\n                [selStart, selEnd] = elementData.beforeInputSelectionRange;\r\n              }\r\n\r\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\r\n                source: this,\r\n                detail: {\r\n                  id,\r\n                  name: \"Keystroke\",\r\n                  value: elementData.beforeInputValue,\r\n                  change: event.data,\r\n                  willCommit: false,\r\n                  selStart,\r\n                  selEnd\r\n                }\r\n              });\r\n            });\r\n          }\r\n\r\n          this._setEventListeners(element, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\r\n        }\r\n      }\r\n\r\n      if (blurListener) {\r\n        element.addEventListener(\"blur\", blurListener);\r\n      }\r\n\r\n      element.disabled = this.data.readOnly;\r\n      element.name = this.data.fieldName;\r\n\r\n      if (this.data.maxLen !== null) {\r\n        element.maxLength = this.data.maxLen;\r\n      }\r\n\r\n      if (this.data.comb) {\r\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\r\n        const combWidth = fieldWidth / this.data.maxLen;\r\n        element.classList.add(\"comb\");\r\n        element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;\r\n      }\r\n    } else {\r\n      element = document.createElement(\"div\");\r\n      element.textContent = this.data.fieldValue;\r\n      element.style.verticalAlign = \"middle\";\r\n      element.style.display = \"table-cell\";\r\n    }\r\n\r\n    this._setTextStyle(element);\r\n\r\n    this.container.appendChild(element);\r\n    return this.container;\r\n  }\r\n\r\n  _setTextStyle(element) {\r\n    const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\r\n    const {\r\n      fontSize,\r\n      fontColor\r\n    } = this.data.defaultAppearanceData;\r\n    const style = element.style;\r\n\r\n    if (fontSize) {\r\n      style.fontSize = `${fontSize}px`;\r\n    }\r\n\r\n    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\r\n\r\n    if (this.data.textAlignment !== null) {\r\n      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\r\n    }\r\n  }\r\n\r\n}\r\n\r\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\r\n  constructor(parameters) {\r\n    super(parameters, {\r\n      isRenderable: parameters.renderInteractiveForms\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const storage = this.annotationStorage;\r\n    const data = this.data;\r\n    const id = data.id;\r\n    const value = storage.getOrCreateValue(id, {\r\n      value: data.fieldValue && data.fieldValue !== \"Off\"\r\n    }).value;\r\n    this.container.className = \"buttonWidgetAnnotation checkBox\";\r\n    const element = document.createElement(\"input\");\r\n    element.disabled = data.readOnly;\r\n    element.type = \"checkbox\";\r\n    element.name = this.data.fieldName;\r\n\r\n    if (value) {\r\n      element.setAttribute(\"checked\", true);\r\n    }\r\n\r\n    element.setAttribute(\"id\", id);\r\n    element.addEventListener(\"change\", function (event) {\r\n      const name = event.target.name;\r\n\r\n      for (const checkbox of document.getElementsByName(name)) {\r\n        if (checkbox !== event.target) {\r\n          checkbox.checked = false;\r\n          storage.setValue(checkbox.parentNode.getAttribute(\"data-annotation-id\"), {\r\n            value: false\r\n          });\r\n        }\r\n      }\r\n\r\n      storage.setValue(id, {\r\n        value: event.target.checked\r\n      });\r\n    });\r\n\r\n    if (this.enableScripting && this.hasJSActions) {\r\n      element.addEventListener(\"updatefromsandbox\", event => {\r\n        const {\r\n          detail\r\n        } = event;\r\n        const actions = {\r\n          value() {\r\n            event.target.checked = detail.value !== \"Off\";\r\n            storage.setValue(id, {\r\n              value: event.target.checked\r\n            });\r\n          },\r\n\r\n          focus() {\r\n            setTimeout(() => event.target.focus({\r\n              preventScroll: false\r\n            }), 0);\r\n          },\r\n\r\n          hidden() {\r\n            event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\r\n            storage.setValue(id, {\r\n              hidden: detail.hidden\r\n            });\r\n          },\r\n\r\n          editable() {\r\n            event.target.disabled = !detail.editable;\r\n          }\r\n\r\n        };\r\n        Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());\r\n      });\r\n\r\n      this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\r\n    }\r\n\r\n    this.container.appendChild(element);\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\r\n  constructor(parameters) {\r\n    super(parameters, {\r\n      isRenderable: parameters.renderInteractiveForms\r\n    });\r\n  }\r\n\r\n  render() {\r\n    this.container.className = \"buttonWidgetAnnotation radioButton\";\r\n    const storage = this.annotationStorage;\r\n    const data = this.data;\r\n    const id = data.id;\r\n    const value = storage.getOrCreateValue(id, {\r\n      value: data.fieldValue === data.buttonValue\r\n    }).value;\r\n    const element = document.createElement(\"input\");\r\n    element.disabled = data.readOnly;\r\n    element.type = \"radio\";\r\n    element.name = data.fieldName;\r\n\r\n    if (value) {\r\n      element.setAttribute(\"checked\", true);\r\n    }\r\n\r\n    element.setAttribute(\"pdfButtonValue\", data.buttonValue);\r\n    element.setAttribute(\"id\", id);\r\n    element.addEventListener(\"change\", function (event) {\r\n      const {\r\n        target\r\n      } = event;\r\n\r\n      for (const radio of document.getElementsByName(target.name)) {\r\n        if (radio !== target) {\r\n          storage.setValue(radio.getAttribute(\"id\"), {\r\n            value: false\r\n          });\r\n        }\r\n      }\r\n\r\n      storage.setValue(id, {\r\n        value: target.checked\r\n      });\r\n    });\r\n\r\n    if (this.enableScripting && this.hasJSActions) {\r\n      element.addEventListener(\"updatefromsandbox\", event => {\r\n        const {\r\n          detail\r\n        } = event;\r\n        const actions = {\r\n          value() {\r\n            const fieldValue = detail.value;\r\n\r\n            for (const radio of document.getElementsByName(event.target.name)) {\r\n              const radioId = radio.getAttribute(\"id\");\r\n\r\n              if (fieldValue === radio.getAttribute(\"pdfButtonValue\")) {\r\n                radio.setAttribute(\"checked\", true);\r\n                storage.setValue(radioId, {\r\n                  value: true\r\n                });\r\n              } else {\r\n                storage.setValue(radioId, {\r\n                  value: false\r\n                });\r\n              }\r\n            }\r\n          },\r\n\r\n          focus() {\r\n            setTimeout(() => event.target.focus({\r\n              preventScroll: false\r\n            }), 0);\r\n          },\r\n\r\n          hidden() {\r\n            event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\r\n            storage.setValue(id, {\r\n              hidden: detail.hidden\r\n            });\r\n          },\r\n\r\n          editable() {\r\n            event.target.disabled = !detail.editable;\r\n          }\r\n\r\n        };\r\n        Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());\r\n      });\r\n\r\n      this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\r\n    }\r\n\r\n    this.container.appendChild(element);\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\r\n  render() {\r\n    const container = super.render();\r\n    container.className = \"buttonWidgetAnnotation pushButton\";\r\n\r\n    if (this.data.alternativeText) {\r\n      container.title = this.data.alternativeText;\r\n    }\r\n\r\n    return container;\r\n  }\r\n\r\n}\r\n\r\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\r\n  constructor(parameters) {\r\n    super(parameters, {\r\n      isRenderable: parameters.renderInteractiveForms\r\n    });\r\n  }\r\n\r\n  render() {\r\n    this.container.className = \"choiceWidgetAnnotation\";\r\n    const storage = this.annotationStorage;\r\n    const id = this.data.id;\r\n    storage.getOrCreateValue(id, {\r\n      value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined\r\n    });\r\n    const selectElement = document.createElement(\"select\");\r\n    selectElement.disabled = this.data.readOnly;\r\n    selectElement.name = this.data.fieldName;\r\n    selectElement.setAttribute(\"id\", id);\r\n\r\n    if (!this.data.combo) {\r\n      selectElement.size = this.data.options.length;\r\n\r\n      if (this.data.multiSelect) {\r\n        selectElement.multiple = true;\r\n      }\r\n    }\r\n\r\n    for (const option of this.data.options) {\r\n      const optionElement = document.createElement(\"option\");\r\n      optionElement.textContent = option.displayValue;\r\n      optionElement.value = option.exportValue;\r\n\r\n      if (this.data.fieldValue.includes(option.exportValue)) {\r\n        optionElement.setAttribute(\"selected\", true);\r\n      }\r\n\r\n      selectElement.appendChild(optionElement);\r\n    }\r\n\r\n    function getValue(event) {\r\n      const options = event.target.options;\r\n      return options[options.selectedIndex].value;\r\n    }\r\n\r\n    if (this.enableScripting && this.hasJSActions) {\r\n      selectElement.addEventListener(\"updatefromsandbox\", event => {\r\n        const {\r\n          detail\r\n        } = event;\r\n        const actions = {\r\n          value() {\r\n            const options = event.target.options;\r\n            const value = detail.value;\r\n            const i = options.indexOf(value);\r\n\r\n            if (i !== -1) {\r\n              options.selectedIndex = i;\r\n              storage.setValue(id, {\r\n                value\r\n              });\r\n            }\r\n          },\r\n\r\n          focus() {\r\n            setTimeout(() => event.target.focus({\r\n              preventScroll: false\r\n            }), 0);\r\n          },\r\n\r\n          hidden() {\r\n            event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\r\n            storage.setValue(id, {\r\n              hidden: detail.hidden\r\n            });\r\n          },\r\n\r\n          editable() {\r\n            event.target.disabled = !detail.editable;\r\n          }\r\n\r\n        };\r\n        Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());\r\n      });\r\n      selectElement.addEventListener(\"input\", event => {\r\n        const value = getValue(event);\r\n        storage.setValue(id, {\r\n          value\r\n        });\r\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\r\n          source: this,\r\n          detail: {\r\n            id,\r\n            name: \"Keystroke\",\r\n            changeEx: value,\r\n            willCommit: true,\r\n            commitKey: 1,\r\n            keyDown: false\r\n          }\r\n        });\r\n      });\r\n\r\n      this._setEventListeners(selectElement, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\r\n    } else {\r\n      selectElement.addEventListener(\"input\", function (event) {\r\n        storage.setValue(id, {\r\n          value: getValue(event)\r\n        });\r\n      });\r\n    }\r\n\r\n    this.container.appendChild(selectElement);\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass PopupAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const IGNORE_TYPES = [\"Line\", \"Square\", \"Circle\", \"PolyLine\", \"Polygon\", \"Ink\"];\r\n    this.container.className = \"popupAnnotation\";\r\n\r\n    if (IGNORE_TYPES.includes(this.data.parentType)) {\r\n      return this.container;\r\n    }\r\n\r\n    const selector = `[data-annotation-id=\"${this.data.parentId}\"]`;\r\n    const parentElements = this.layer.querySelectorAll(selector);\r\n\r\n    if (parentElements.length === 0) {\r\n      return this.container;\r\n    }\r\n\r\n    const popup = new PopupElement({\r\n      container: this.container,\r\n      trigger: Array.from(parentElements),\r\n      color: this.data.color,\r\n      title: this.data.title,\r\n      modificationDate: this.data.modificationDate,\r\n      contents: this.data.contents\r\n    });\r\n    const page = this.page;\r\n\r\n    const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);\r\n\r\n    const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];\r\n    const popupTop = rect[1];\r\n    this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;\r\n    this.container.style.left = `${popupLeft}px`;\r\n    this.container.style.top = `${popupTop}px`;\r\n    this.container.appendChild(popup.render());\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass PopupElement {\r\n  constructor(parameters) {\r\n    this.container = parameters.container;\r\n    this.trigger = parameters.trigger;\r\n    this.color = parameters.color;\r\n    this.title = parameters.title;\r\n    this.modificationDate = parameters.modificationDate;\r\n    this.contents = parameters.contents;\r\n    this.hideWrapper = parameters.hideWrapper || false;\r\n    this.pinned = false;\r\n  }\r\n\r\n  render() {\r\n    const BACKGROUND_ENLIGHT = 0.7;\r\n    const wrapper = document.createElement(\"div\");\r\n    wrapper.className = \"popupWrapper\";\r\n    this.hideElement = this.hideWrapper ? wrapper : this.container;\r\n    this.hideElement.setAttribute(\"hidden\", true);\r\n    const popup = document.createElement(\"div\");\r\n    popup.className = \"popup\";\r\n    const color = this.color;\r\n\r\n    if (color) {\r\n      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\r\n      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\r\n      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\r\n      popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);\r\n    }\r\n\r\n    const title = document.createElement(\"h1\");\r\n    title.textContent = this.title;\r\n    popup.appendChild(title);\r\n\r\n    const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);\r\n\r\n    if (dateObject) {\r\n      const modificationDate = document.createElement(\"span\");\r\n      modificationDate.textContent = \"{{date}}, {{time}}\";\r\n      modificationDate.dataset.l10nId = \"annotation_date_string\";\r\n      modificationDate.dataset.l10nArgs = JSON.stringify({\r\n        date: dateObject.toLocaleDateString(),\r\n        time: dateObject.toLocaleTimeString()\r\n      });\r\n      popup.appendChild(modificationDate);\r\n    }\r\n\r\n    const contents = this._formatContents(this.contents);\r\n\r\n    popup.appendChild(contents);\r\n\r\n    if (!Array.isArray(this.trigger)) {\r\n      this.trigger = [this.trigger];\r\n    }\r\n\r\n    this.trigger.forEach(element => {\r\n      element.addEventListener(\"click\", this._toggle.bind(this));\r\n      element.addEventListener(\"mouseover\", this._show.bind(this, false));\r\n      element.addEventListener(\"mouseout\", this._hide.bind(this, false));\r\n    });\r\n    popup.addEventListener(\"click\", this._hide.bind(this, true));\r\n    wrapper.appendChild(popup);\r\n    return wrapper;\r\n  }\r\n\r\n  _formatContents(contents) {\r\n    const p = document.createElement(\"p\");\r\n    const lines = contents.split(/(?:\\r\\n?|\\n)/);\r\n\r\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\r\n      const line = lines[i];\r\n      p.appendChild(document.createTextNode(line));\r\n\r\n      if (i < ii - 1) {\r\n        p.appendChild(document.createElement(\"br\"));\r\n      }\r\n    }\r\n\r\n    return p;\r\n  }\r\n\r\n  _toggle() {\r\n    if (this.pinned) {\r\n      this._hide(true);\r\n    } else {\r\n      this._show(true);\r\n    }\r\n  }\r\n\r\n  _show(pin = false) {\r\n    if (pin) {\r\n      this.pinned = true;\r\n    }\r\n\r\n    if (this.hideElement.hasAttribute(\"hidden\")) {\r\n      this.hideElement.removeAttribute(\"hidden\");\r\n      this.container.style.zIndex += 1;\r\n    }\r\n  }\r\n\r\n  _hide(unpin = true) {\r\n    if (unpin) {\r\n      this.pinned = false;\r\n    }\r\n\r\n    if (!this.hideElement.hasAttribute(\"hidden\") && !this.pinned) {\r\n      this.hideElement.setAttribute(\"hidden\", true);\r\n      this.container.style.zIndex -= 1;\r\n    }\r\n  }\r\n\r\n}\r\n\r\nclass FreeTextAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true\r\n    });\r\n  }\r\n\r\n  render() {\r\n    this.container.className = \"freeTextAnnotation\";\r\n\r\n    if (!this.data.hasPopup) {\r\n      this._createPopup(null, this.data);\r\n    }\r\n\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass LineAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true\r\n    });\r\n  }\r\n\r\n  render() {\r\n    this.container.className = \"lineAnnotation\";\r\n    const data = this.data;\r\n    const width = data.rect[2] - data.rect[0];\r\n    const height = data.rect[3] - data.rect[1];\r\n    const svg = this.svgFactory.create(width, height);\r\n    const line = this.svgFactory.createElement(\"svg:line\");\r\n    line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\r\n    line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\r\n    line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\r\n    line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\r\n    line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\r\n    line.setAttribute(\"stroke\", \"transparent\");\r\n    svg.appendChild(line);\r\n    this.container.append(svg);\r\n\r\n    this._createPopup(line, data);\r\n\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass SquareAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true\r\n    });\r\n  }\r\n\r\n  render() {\r\n    this.container.className = \"squareAnnotation\";\r\n    const data = this.data;\r\n    const width = data.rect[2] - data.rect[0];\r\n    const height = data.rect[3] - data.rect[1];\r\n    const svg = this.svgFactory.create(width, height);\r\n    const borderWidth = data.borderStyle.width;\r\n    const square = this.svgFactory.createElement(\"svg:rect\");\r\n    square.setAttribute(\"x\", borderWidth / 2);\r\n    square.setAttribute(\"y\", borderWidth / 2);\r\n    square.setAttribute(\"width\", width - borderWidth);\r\n    square.setAttribute(\"height\", height - borderWidth);\r\n    square.setAttribute(\"stroke-width\", borderWidth || 1);\r\n    square.setAttribute(\"stroke\", \"transparent\");\r\n    square.setAttribute(\"fill\", \"none\");\r\n    svg.appendChild(square);\r\n    this.container.append(svg);\r\n\r\n    this._createPopup(square, data);\r\n\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass CircleAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true\r\n    });\r\n  }\r\n\r\n  render() {\r\n    this.container.className = \"circleAnnotation\";\r\n    const data = this.data;\r\n    const width = data.rect[2] - data.rect[0];\r\n    const height = data.rect[3] - data.rect[1];\r\n    const svg = this.svgFactory.create(width, height);\r\n    const borderWidth = data.borderStyle.width;\r\n    const circle = this.svgFactory.createElement(\"svg:ellipse\");\r\n    circle.setAttribute(\"cx\", width / 2);\r\n    circle.setAttribute(\"cy\", height / 2);\r\n    circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\r\n    circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\r\n    circle.setAttribute(\"stroke-width\", borderWidth || 1);\r\n    circle.setAttribute(\"stroke\", \"transparent\");\r\n    circle.setAttribute(\"fill\", \"none\");\r\n    svg.appendChild(circle);\r\n    this.container.append(svg);\r\n\r\n    this._createPopup(circle, data);\r\n\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass PolylineAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true\r\n    });\r\n    this.containerClassName = \"polylineAnnotation\";\r\n    this.svgElementName = \"svg:polyline\";\r\n  }\r\n\r\n  render() {\r\n    this.container.className = this.containerClassName;\r\n    const data = this.data;\r\n    const width = data.rect[2] - data.rect[0];\r\n    const height = data.rect[3] - data.rect[1];\r\n    const svg = this.svgFactory.create(width, height);\r\n    let points = [];\r\n\r\n    for (const coordinate of data.vertices) {\r\n      const x = coordinate.x - data.rect[0];\r\n      const y = data.rect[3] - coordinate.y;\r\n      points.push(x + \",\" + y);\r\n    }\r\n\r\n    points = points.join(\" \");\r\n    const polyline = this.svgFactory.createElement(this.svgElementName);\r\n    polyline.setAttribute(\"points\", points);\r\n    polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\r\n    polyline.setAttribute(\"stroke\", \"transparent\");\r\n    polyline.setAttribute(\"fill\", \"none\");\r\n    svg.appendChild(polyline);\r\n    this.container.append(svg);\r\n\r\n    this._createPopup(polyline, data);\r\n\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\r\n  constructor(parameters) {\r\n    super(parameters);\r\n    this.containerClassName = \"polygonAnnotation\";\r\n    this.svgElementName = \"svg:polygon\";\r\n  }\r\n\r\n}\r\n\r\nclass CaretAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true\r\n    });\r\n  }\r\n\r\n  render() {\r\n    this.container.className = \"caretAnnotation\";\r\n\r\n    if (!this.data.hasPopup) {\r\n      this._createPopup(null, this.data);\r\n    }\r\n\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass InkAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true\r\n    });\r\n    this.containerClassName = \"inkAnnotation\";\r\n    this.svgElementName = \"svg:polyline\";\r\n  }\r\n\r\n  render() {\r\n    this.container.className = this.containerClassName;\r\n    const data = this.data;\r\n    const width = data.rect[2] - data.rect[0];\r\n    const height = data.rect[3] - data.rect[1];\r\n    const svg = this.svgFactory.create(width, height);\r\n\r\n    for (const inkList of data.inkLists) {\r\n      let points = [];\r\n\r\n      for (const coordinate of inkList) {\r\n        const x = coordinate.x - data.rect[0];\r\n        const y = data.rect[3] - coordinate.y;\r\n        points.push(`${x},${y}`);\r\n      }\r\n\r\n      points = points.join(\" \");\r\n      const polyline = this.svgFactory.createElement(this.svgElementName);\r\n      polyline.setAttribute(\"points\", points);\r\n      polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\r\n      polyline.setAttribute(\"stroke\", \"transparent\");\r\n      polyline.setAttribute(\"fill\", \"none\");\r\n\r\n      this._createPopup(polyline, data);\r\n\r\n      svg.appendChild(polyline);\r\n    }\r\n\r\n    this.container.append(svg);\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass HighlightAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true,\r\n      createQuadrilaterals: true\r\n    });\r\n  }\r\n\r\n  render() {\r\n    if (!this.data.hasPopup) {\r\n      this._createPopup(null, this.data);\r\n    }\r\n\r\n    if (this.quadrilaterals) {\r\n      return this._renderQuadrilaterals(\"highlightAnnotation\");\r\n    }\r\n\r\n    this.container.className = \"highlightAnnotation\";\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass UnderlineAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true,\r\n      createQuadrilaterals: true\r\n    });\r\n  }\r\n\r\n  render() {\r\n    if (!this.data.hasPopup) {\r\n      this._createPopup(null, this.data);\r\n    }\r\n\r\n    if (this.quadrilaterals) {\r\n      return this._renderQuadrilaterals(\"underlineAnnotation\");\r\n    }\r\n\r\n    this.container.className = \"underlineAnnotation\";\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass SquigglyAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true,\r\n      createQuadrilaterals: true\r\n    });\r\n  }\r\n\r\n  render() {\r\n    if (!this.data.hasPopup) {\r\n      this._createPopup(null, this.data);\r\n    }\r\n\r\n    if (this.quadrilaterals) {\r\n      return this._renderQuadrilaterals(\"squigglyAnnotation\");\r\n    }\r\n\r\n    this.container.className = \"squigglyAnnotation\";\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass StrikeOutAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true,\r\n      createQuadrilaterals: true\r\n    });\r\n  }\r\n\r\n  render() {\r\n    if (!this.data.hasPopup) {\r\n      this._createPopup(null, this.data);\r\n    }\r\n\r\n    if (this.quadrilaterals) {\r\n      return this._renderQuadrilaterals(\"strikeoutAnnotation\");\r\n    }\r\n\r\n    this.container.className = \"strikeoutAnnotation\";\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass StampAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    super(parameters, {\r\n      isRenderable,\r\n      ignoreBorder: true\r\n    });\r\n  }\r\n\r\n  render() {\r\n    this.container.className = \"stampAnnotation\";\r\n\r\n    if (!this.data.hasPopup) {\r\n      this._createPopup(null, this.data);\r\n    }\r\n\r\n    return this.container;\r\n  }\r\n\r\n}\r\n\r\nclass FileAttachmentAnnotationElement extends AnnotationElement {\r\n  constructor(parameters) {\r\n    super(parameters, {\r\n      isRenderable: true\r\n    });\r\n    const {\r\n      filename,\r\n      content\r\n    } = this.data.file;\r\n    this.filename = (0, _display_utils.getFilenameFromUrl)(filename);\r\n    this.content = content;\r\n    this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\r\n      source: this,\r\n      id: (0, _util.stringToPDFString)(filename),\r\n      filename,\r\n      content\r\n    });\r\n  }\r\n\r\n  render() {\r\n    this.container.className = \"fileAttachmentAnnotation\";\r\n    const trigger = document.createElement(\"div\");\r\n    trigger.style.height = this.container.style.height;\r\n    trigger.style.width = this.container.style.width;\r\n    trigger.addEventListener(\"dblclick\", this._download.bind(this));\r\n\r\n    if (!this.data.hasPopup && (this.data.title || this.data.contents)) {\r\n      this._createPopup(trigger, this.data);\r\n    }\r\n\r\n    this.container.appendChild(trigger);\r\n    return this.container;\r\n  }\r\n\r\n  _download() {\r\n    if (!this.downloadManager) {\r\n      (0, _util.warn)(\"Download cannot be started due to unavailable download manager\");\r\n      return;\r\n    }\r\n\r\n    this.downloadManager.downloadData(this.content, this.filename, \"\");\r\n  }\r\n\r\n}\r\n\r\nclass AnnotationLayer {\r\n  static render(parameters) {\r\n    const sortedAnnotations = [],\r\n          popupAnnotations = [];\r\n\r\n    for (const data of parameters.annotations) {\r\n      if (!data) {\r\n        continue;\r\n      }\r\n\r\n      if (data.annotationType === _util.AnnotationType.POPUP) {\r\n        popupAnnotations.push(data);\r\n        continue;\r\n      }\r\n\r\n      sortedAnnotations.push(data);\r\n    }\r\n\r\n    if (popupAnnotations.length) {\r\n      sortedAnnotations.push(...popupAnnotations);\r\n    }\r\n\r\n    for (const data of sortedAnnotations) {\r\n      const element = AnnotationElementFactory.create({\r\n        data,\r\n        layer: parameters.div,\r\n        page: parameters.page,\r\n        viewport: parameters.viewport,\r\n        linkService: parameters.linkService,\r\n        downloadManager: parameters.downloadManager,\r\n        imageResourcesPath: parameters.imageResourcesPath || \"\",\r\n        renderInteractiveForms: typeof parameters.renderInteractiveForms === \"boolean\" ? parameters.renderInteractiveForms : true,\r\n        svgFactory: new _display_utils.DOMSVGFactory(),\r\n        annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),\r\n        enableScripting: parameters.enableScripting,\r\n        hasJSActions: parameters.hasJSActions,\r\n        mouseState: parameters.mouseState || {\r\n          isDown: false\r\n        }\r\n      });\r\n\r\n      if (element.isRenderable) {\r\n        const rendered = element.render();\r\n\r\n        if (data.hidden) {\r\n          rendered.style.visibility = \"hidden\";\r\n        }\r\n\r\n        if (Array.isArray(rendered)) {\r\n          for (const renderedElement of rendered) {\r\n            parameters.div.appendChild(renderedElement);\r\n          }\r\n        } else {\r\n          if (element instanceof PopupAnnotationElement) {\r\n            parameters.div.prepend(rendered);\r\n          } else {\r\n            parameters.div.appendChild(rendered);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  static update(parameters) {\r\n    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\r\n\r\n    for (const data of parameters.annotations) {\r\n      const elements = parameters.div.querySelectorAll(`[data-annotation-id=\"${data.id}\"]`);\r\n\r\n      if (elements) {\r\n        elements.forEach(element => {\r\n          element.style.transform = transform;\r\n        });\r\n      }\r\n    }\r\n\r\n    parameters.div.removeAttribute(\"hidden\");\r\n  }\r\n\r\n}\r\n\r\nexports.AnnotationLayer = AnnotationLayer;\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ ((__unused_webpack_module, exports) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.ColorConverters = void 0;\r\n\r\nfunction makeColorComp(n) {\r\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\r\n}\r\n\r\nclass ColorConverters {\r\n  static CMYK_G([c, y, m, k]) {\r\n    return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\r\n  }\r\n\r\n  static G_CMYK([g]) {\r\n    return [\"CMYK\", 0, 0, 0, 1 - g];\r\n  }\r\n\r\n  static G_RGB([g]) {\r\n    return [\"RGB\", g, g, g];\r\n  }\r\n\r\n  static G_HTML([g]) {\r\n    const G = makeColorComp(g);\r\n    return `#${G}${G}${G}`;\r\n  }\r\n\r\n  static RGB_G([r, g, b]) {\r\n    return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\r\n  }\r\n\r\n  static RGB_HTML([r, g, b]) {\r\n    const R = makeColorComp(r);\r\n    const G = makeColorComp(g);\r\n    const B = makeColorComp(b);\r\n    return `#${R}${G}${B}`;\r\n  }\r\n\r\n  static T_HTML() {\r\n    return \"#00000000\";\r\n  }\r\n\r\n  static CMYK_RGB([c, y, m, k]) {\r\n    return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\r\n  }\r\n\r\n  static CMYK_HTML(components) {\r\n    return this.RGB_HTML(this.CMYK_RGB(components));\r\n  }\r\n\r\n  static RGB_CMYK([r, g, b]) {\r\n    const c = 1 - r;\r\n    const m = 1 - g;\r\n    const y = 1 - b;\r\n    const k = Math.min(c, m, y);\r\n    return [\"CMYK\", c, m, y, k];\r\n  }\r\n\r\n}\r\n\r\nexports.ColorConverters = ColorConverters;\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.renderTextLayer = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nconst renderTextLayer = function renderTextLayerClosure() {\r\n  const MAX_TEXT_DIVS_TO_RENDER = 100000;\r\n  const NonWhitespaceRegexp = /\\S/;\r\n\r\n  function isAllWhitespace(str) {\r\n    return !NonWhitespaceRegexp.test(str);\r\n  }\r\n\r\n  function appendText(task, geom, styles) {\r\n    const textDiv = document.createElement(\"span\");\r\n    const textDivProperties = {\r\n      angle: 0,\r\n      canvasWidth: 0,\r\n      isWhitespace: false,\r\n      originalTransform: null,\r\n      paddingBottom: 0,\r\n      paddingLeft: 0,\r\n      paddingRight: 0,\r\n      paddingTop: 0,\r\n      scale: 1\r\n    };\r\n\r\n    task._textDivs.push(textDiv);\r\n\r\n    if (isAllWhitespace(geom.str)) {\r\n      textDivProperties.isWhitespace = true;\r\n\r\n      task._textDivProperties.set(textDiv, textDivProperties);\r\n\r\n      return;\r\n    }\r\n\r\n    const tx = _util.Util.transform(task._viewport.transform, geom.transform);\r\n\r\n    let angle = Math.atan2(tx[1], tx[0]);\r\n    const style = styles[geom.fontName];\r\n\r\n    if (style.vertical) {\r\n      angle += Math.PI / 2;\r\n    }\r\n\r\n    const fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);\r\n    let fontAscent = fontHeight;\r\n\r\n    if (style.ascent) {\r\n      fontAscent = style.ascent * fontAscent;\r\n    } else if (style.descent) {\r\n      fontAscent = (1 + style.descent) * fontAscent;\r\n    }\r\n\r\n    let left, top;\r\n\r\n    if (angle === 0) {\r\n      left = tx[4];\r\n      top = tx[5] - fontAscent;\r\n    } else {\r\n      left = tx[4] + fontAscent * Math.sin(angle);\r\n      top = tx[5] - fontAscent * Math.cos(angle);\r\n    }\r\n\r\n    textDiv.style.left = `${left}px`;\r\n    textDiv.style.top = `${top}px`;\r\n    textDiv.style.fontSize = `${fontHeight}px`;\r\n    textDiv.style.fontFamily = style.fontFamily;\r\n    textDiv.textContent = geom.str;\r\n\r\n    if (task._fontInspectorEnabled) {\r\n      textDiv.dataset.fontName = geom.fontName;\r\n    }\r\n\r\n    if (angle !== 0) {\r\n      textDivProperties.angle = angle * (180 / Math.PI);\r\n    }\r\n\r\n    let shouldScaleText = false;\r\n\r\n    if (geom.str.length > 1) {\r\n      shouldScaleText = true;\r\n    } else if (geom.transform[0] !== geom.transform[3]) {\r\n      const absScaleX = Math.abs(geom.transform[0]),\r\n            absScaleY = Math.abs(geom.transform[3]);\r\n\r\n      if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\r\n        shouldScaleText = true;\r\n      }\r\n    }\r\n\r\n    if (shouldScaleText) {\r\n      if (style.vertical) {\r\n        textDivProperties.canvasWidth = geom.height * task._viewport.scale;\r\n      } else {\r\n        textDivProperties.canvasWidth = geom.width * task._viewport.scale;\r\n      }\r\n    }\r\n\r\n    task._textDivProperties.set(textDiv, textDivProperties);\r\n\r\n    if (task._textContentStream) {\r\n      task._layoutText(textDiv);\r\n    }\r\n\r\n    if (task._enhanceTextSelection) {\r\n      let angleCos = 1,\r\n          angleSin = 0;\r\n\r\n      if (angle !== 0) {\r\n        angleCos = Math.cos(angle);\r\n        angleSin = Math.sin(angle);\r\n      }\r\n\r\n      const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;\r\n      const divHeight = fontHeight;\r\n      let m, b;\r\n\r\n      if (angle !== 0) {\r\n        m = [angleCos, angleSin, -angleSin, angleCos, left, top];\r\n        b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\r\n      } else {\r\n        b = [left, top, left + divWidth, top + divHeight];\r\n      }\r\n\r\n      task._bounds.push({\r\n        left: b[0],\r\n        top: b[1],\r\n        right: b[2],\r\n        bottom: b[3],\r\n        div: textDiv,\r\n        size: [divWidth, divHeight],\r\n        m\r\n      });\r\n    }\r\n  }\r\n\r\n  function render(task) {\r\n    if (task._canceled) {\r\n      return;\r\n    }\r\n\r\n    const textDivs = task._textDivs;\r\n    const capability = task._capability;\r\n    const textDivsLength = textDivs.length;\r\n\r\n    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\r\n      task._renderingDone = true;\r\n      capability.resolve();\r\n      return;\r\n    }\r\n\r\n    if (!task._textContentStream) {\r\n      for (let i = 0; i < textDivsLength; i++) {\r\n        task._layoutText(textDivs[i]);\r\n      }\r\n    }\r\n\r\n    task._renderingDone = true;\r\n    capability.resolve();\r\n  }\r\n\r\n  function findPositiveMin(ts, offset, count) {\r\n    let result = 0;\r\n\r\n    for (let i = 0; i < count; i++) {\r\n      const t = ts[offset++];\r\n\r\n      if (t > 0) {\r\n        result = result ? Math.min(t, result) : t;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function expand(task) {\r\n    const bounds = task._bounds;\r\n    const viewport = task._viewport;\r\n    const expanded = expandBounds(viewport.width, viewport.height, bounds);\r\n\r\n    for (let i = 0; i < expanded.length; i++) {\r\n      const div = bounds[i].div;\r\n\r\n      const divProperties = task._textDivProperties.get(div);\r\n\r\n      if (divProperties.angle === 0) {\r\n        divProperties.paddingLeft = bounds[i].left - expanded[i].left;\r\n        divProperties.paddingTop = bounds[i].top - expanded[i].top;\r\n        divProperties.paddingRight = expanded[i].right - bounds[i].right;\r\n        divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\r\n\r\n        task._textDivProperties.set(div, divProperties);\r\n\r\n        continue;\r\n      }\r\n\r\n      const e = expanded[i],\r\n            b = bounds[i];\r\n      const m = b.m,\r\n            c = m[0],\r\n            s = m[1];\r\n      const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\r\n      const ts = new Float64Array(64);\r\n      points.forEach(function (p, j) {\r\n        const t = _util.Util.applyTransform(p, m);\r\n\r\n        ts[j + 0] = c && (e.left - t[0]) / c;\r\n        ts[j + 4] = s && (e.top - t[1]) / s;\r\n        ts[j + 8] = c && (e.right - t[0]) / c;\r\n        ts[j + 12] = s && (e.bottom - t[1]) / s;\r\n        ts[j + 16] = s && (e.left - t[0]) / -s;\r\n        ts[j + 20] = c && (e.top - t[1]) / c;\r\n        ts[j + 24] = s && (e.right - t[0]) / -s;\r\n        ts[j + 28] = c && (e.bottom - t[1]) / c;\r\n        ts[j + 32] = c && (e.left - t[0]) / -c;\r\n        ts[j + 36] = s && (e.top - t[1]) / -s;\r\n        ts[j + 40] = c && (e.right - t[0]) / -c;\r\n        ts[j + 44] = s && (e.bottom - t[1]) / -s;\r\n        ts[j + 48] = s && (e.left - t[0]) / s;\r\n        ts[j + 52] = c && (e.top - t[1]) / -c;\r\n        ts[j + 56] = s && (e.right - t[0]) / s;\r\n        ts[j + 60] = c && (e.bottom - t[1]) / -c;\r\n      });\r\n      const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\r\n      divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\r\n      divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\r\n      divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\r\n      divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\r\n\r\n      task._textDivProperties.set(div, divProperties);\r\n    }\r\n  }\r\n\r\n  function expandBounds(width, height, boxes) {\r\n    const bounds = boxes.map(function (box, i) {\r\n      return {\r\n        x1: box.left,\r\n        y1: box.top,\r\n        x2: box.right,\r\n        y2: box.bottom,\r\n        index: i,\r\n        x1New: undefined,\r\n        x2New: undefined\r\n      };\r\n    });\r\n    expandBoundsLTR(width, bounds);\r\n    const expanded = new Array(boxes.length);\r\n    bounds.forEach(function (b) {\r\n      const i = b.index;\r\n      expanded[i] = {\r\n        left: b.x1New,\r\n        top: 0,\r\n        right: b.x2New,\r\n        bottom: 0\r\n      };\r\n    });\r\n    boxes.map(function (box, i) {\r\n      const e = expanded[i],\r\n            b = bounds[i];\r\n      b.x1 = box.top;\r\n      b.y1 = width - e.right;\r\n      b.x2 = box.bottom;\r\n      b.y2 = width - e.left;\r\n      b.index = i;\r\n      b.x1New = undefined;\r\n      b.x2New = undefined;\r\n    });\r\n    expandBoundsLTR(height, bounds);\r\n    bounds.forEach(function (b) {\r\n      const i = b.index;\r\n      expanded[i].top = b.x1New;\r\n      expanded[i].bottom = b.x2New;\r\n    });\r\n    return expanded;\r\n  }\r\n\r\n  function expandBoundsLTR(width, bounds) {\r\n    bounds.sort(function (a, b) {\r\n      return a.x1 - b.x1 || a.index - b.index;\r\n    });\r\n    const fakeBoundary = {\r\n      x1: -Infinity,\r\n      y1: -Infinity,\r\n      x2: 0,\r\n      y2: Infinity,\r\n      index: -1,\r\n      x1New: 0,\r\n      x2New: 0\r\n    };\r\n    const horizon = [{\r\n      start: -Infinity,\r\n      end: Infinity,\r\n      boundary: fakeBoundary\r\n    }];\r\n    bounds.forEach(function (boundary) {\r\n      let i = 0;\r\n\r\n      while (i < horizon.length && horizon[i].end <= boundary.y1) {\r\n        i++;\r\n      }\r\n\r\n      let j = horizon.length - 1;\r\n\r\n      while (j >= 0 && horizon[j].start >= boundary.y2) {\r\n        j--;\r\n      }\r\n\r\n      let horizonPart, affectedBoundary;\r\n      let q,\r\n          k,\r\n          maxXNew = -Infinity;\r\n\r\n      for (q = i; q <= j; q++) {\r\n        horizonPart = horizon[q];\r\n        affectedBoundary = horizonPart.boundary;\r\n        let xNew;\r\n\r\n        if (affectedBoundary.x2 > boundary.x1) {\r\n          xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;\r\n        } else if (affectedBoundary.x2New === undefined) {\r\n          xNew = (affectedBoundary.x2 + boundary.x1) / 2;\r\n        } else {\r\n          xNew = affectedBoundary.x2New;\r\n        }\r\n\r\n        if (xNew > maxXNew) {\r\n          maxXNew = xNew;\r\n        }\r\n      }\r\n\r\n      boundary.x1New = maxXNew;\r\n\r\n      for (q = i; q <= j; q++) {\r\n        horizonPart = horizon[q];\r\n        affectedBoundary = horizonPart.boundary;\r\n\r\n        if (affectedBoundary.x2New === undefined) {\r\n          if (affectedBoundary.x2 > boundary.x1) {\r\n            if (affectedBoundary.index > boundary.index) {\r\n              affectedBoundary.x2New = affectedBoundary.x2;\r\n            }\r\n          } else {\r\n            affectedBoundary.x2New = maxXNew;\r\n          }\r\n        } else if (affectedBoundary.x2New > maxXNew) {\r\n          affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\r\n        }\r\n      }\r\n\r\n      const changedHorizon = [];\r\n      let lastBoundary = null;\r\n\r\n      for (q = i; q <= j; q++) {\r\n        horizonPart = horizon[q];\r\n        affectedBoundary = horizonPart.boundary;\r\n        const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\r\n\r\n        if (lastBoundary === useBoundary) {\r\n          changedHorizon[changedHorizon.length - 1].end = horizonPart.end;\r\n        } else {\r\n          changedHorizon.push({\r\n            start: horizonPart.start,\r\n            end: horizonPart.end,\r\n            boundary: useBoundary\r\n          });\r\n          lastBoundary = useBoundary;\r\n        }\r\n      }\r\n\r\n      if (horizon[i].start < boundary.y1) {\r\n        changedHorizon[0].start = boundary.y1;\r\n        changedHorizon.unshift({\r\n          start: horizon[i].start,\r\n          end: boundary.y1,\r\n          boundary: horizon[i].boundary\r\n        });\r\n      }\r\n\r\n      if (boundary.y2 < horizon[j].end) {\r\n        changedHorizon[changedHorizon.length - 1].end = boundary.y2;\r\n        changedHorizon.push({\r\n          start: boundary.y2,\r\n          end: horizon[j].end,\r\n          boundary: horizon[j].boundary\r\n        });\r\n      }\r\n\r\n      for (q = i; q <= j; q++) {\r\n        horizonPart = horizon[q];\r\n        affectedBoundary = horizonPart.boundary;\r\n\r\n        if (affectedBoundary.x2New !== undefined) {\r\n          continue;\r\n        }\r\n\r\n        let used = false;\r\n\r\n        for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {\r\n          used = horizon[k].boundary === affectedBoundary;\r\n        }\r\n\r\n        for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {\r\n          used = horizon[k].boundary === affectedBoundary;\r\n        }\r\n\r\n        for (k = 0; !used && k < changedHorizon.length; k++) {\r\n          used = changedHorizon[k].boundary === affectedBoundary;\r\n        }\r\n\r\n        if (!used) {\r\n          affectedBoundary.x2New = maxXNew;\r\n        }\r\n      }\r\n\r\n      Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));\r\n    });\r\n    horizon.forEach(function (horizonPart) {\r\n      const affectedBoundary = horizonPart.boundary;\r\n\r\n      if (affectedBoundary.x2New === undefined) {\r\n        affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\r\n      }\r\n    });\r\n  }\r\n\r\n  function TextLayerRenderTask({\r\n    textContent,\r\n    textContentStream,\r\n    container,\r\n    viewport,\r\n    textDivs,\r\n    textContentItemsStr,\r\n    enhanceTextSelection\r\n  }) {\r\n    this._textContent = textContent;\r\n    this._textContentStream = textContentStream;\r\n    this._container = container;\r\n    this._document = container.ownerDocument;\r\n    this._viewport = viewport;\r\n    this._textDivs = textDivs || [];\r\n    this._textContentItemsStr = textContentItemsStr || [];\r\n    this._enhanceTextSelection = !!enhanceTextSelection;\r\n    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\r\n    this._reader = null;\r\n    this._layoutTextLastFontSize = null;\r\n    this._layoutTextLastFontFamily = null;\r\n    this._layoutTextCtx = null;\r\n    this._textDivProperties = new WeakMap();\r\n    this._renderingDone = false;\r\n    this._canceled = false;\r\n    this._capability = (0, _util.createPromiseCapability)();\r\n    this._renderTimer = null;\r\n    this._bounds = [];\r\n\r\n    this._capability.promise.finally(() => {\r\n      if (this._layoutTextCtx) {\r\n        this._layoutTextCtx.canvas.width = 0;\r\n        this._layoutTextCtx.canvas.height = 0;\r\n        this._layoutTextCtx = null;\r\n      }\r\n    }).catch(() => {});\r\n  }\r\n\r\n  TextLayerRenderTask.prototype = {\r\n    get promise() {\r\n      return this._capability.promise;\r\n    },\r\n\r\n    cancel: function TextLayer_cancel() {\r\n      this._canceled = true;\r\n\r\n      if (this._reader) {\r\n        this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\"));\r\n\r\n        this._reader = null;\r\n      }\r\n\r\n      if (this._renderTimer !== null) {\r\n        clearTimeout(this._renderTimer);\r\n        this._renderTimer = null;\r\n      }\r\n\r\n      this._capability.reject(new Error(\"TextLayer task cancelled.\"));\r\n    },\r\n\r\n    _processItems(items, styleCache) {\r\n      for (let i = 0, len = items.length; i < len; i++) {\r\n        this._textContentItemsStr.push(items[i].str);\r\n\r\n        appendText(this, items[i], styleCache);\r\n      }\r\n    },\r\n\r\n    _layoutText(textDiv) {\r\n      const textDivProperties = this._textDivProperties.get(textDiv);\r\n\r\n      if (textDivProperties.isWhitespace) {\r\n        return;\r\n      }\r\n\r\n      let transform = \"\";\r\n\r\n      if (textDivProperties.canvasWidth !== 0) {\r\n        const {\r\n          fontSize,\r\n          fontFamily\r\n        } = textDiv.style;\r\n\r\n        if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {\r\n          this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;\r\n          this._layoutTextLastFontSize = fontSize;\r\n          this._layoutTextLastFontFamily = fontFamily;\r\n        }\r\n\r\n        const {\r\n          width\r\n        } = this._layoutTextCtx.measureText(textDiv.textContent);\r\n\r\n        if (width > 0) {\r\n          textDivProperties.scale = textDivProperties.canvasWidth / width;\r\n          transform = `scaleX(${textDivProperties.scale})`;\r\n        }\r\n      }\r\n\r\n      if (textDivProperties.angle !== 0) {\r\n        transform = `rotate(${textDivProperties.angle}deg) ${transform}`;\r\n      }\r\n\r\n      if (transform.length > 0) {\r\n        if (this._enhanceTextSelection) {\r\n          textDivProperties.originalTransform = transform;\r\n        }\r\n\r\n        textDiv.style.transform = transform;\r\n      }\r\n\r\n      this._textDivProperties.set(textDiv, textDivProperties);\r\n\r\n      this._container.appendChild(textDiv);\r\n    },\r\n\r\n    _render: function TextLayer_render(timeout) {\r\n      const capability = (0, _util.createPromiseCapability)();\r\n      let styleCache = Object.create(null);\r\n\r\n      const canvas = this._document.createElement(\"canvas\");\r\n\r\n      canvas.mozOpaque = true;\r\n      this._layoutTextCtx = canvas.getContext(\"2d\", {\r\n        alpha: false\r\n      });\r\n\r\n      if (this._textContent) {\r\n        const textItems = this._textContent.items;\r\n        const textStyles = this._textContent.styles;\r\n\r\n        this._processItems(textItems, textStyles);\r\n\r\n        capability.resolve();\r\n      } else if (this._textContentStream) {\r\n        const pump = () => {\r\n          this._reader.read().then(({\r\n            value,\r\n            done\r\n          }) => {\r\n            if (done) {\r\n              capability.resolve();\r\n              return;\r\n            }\r\n\r\n            Object.assign(styleCache, value.styles);\r\n\r\n            this._processItems(value.items, styleCache);\r\n\r\n            pump();\r\n          }, capability.reject);\r\n        };\r\n\r\n        this._reader = this._textContentStream.getReader();\r\n        pump();\r\n      } else {\r\n        throw new Error('Neither \"textContent\" nor \"textContentStream\"' + \" parameters specified.\");\r\n      }\r\n\r\n      capability.promise.then(() => {\r\n        styleCache = null;\r\n\r\n        if (!timeout) {\r\n          render(this);\r\n        } else {\r\n          this._renderTimer = setTimeout(() => {\r\n            render(this);\r\n            this._renderTimer = null;\r\n          }, timeout);\r\n        }\r\n      }, this._capability.reject);\r\n    },\r\n    expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {\r\n      if (!this._enhanceTextSelection || !this._renderingDone) {\r\n        return;\r\n      }\r\n\r\n      if (this._bounds !== null) {\r\n        expand(this);\r\n        this._bounds = null;\r\n      }\r\n\r\n      const transformBuf = [],\r\n            paddingBuf = [];\r\n\r\n      for (let i = 0, ii = this._textDivs.length; i < ii; i++) {\r\n        const div = this._textDivs[i];\r\n\r\n        const divProps = this._textDivProperties.get(div);\r\n\r\n        if (divProps.isWhitespace) {\r\n          continue;\r\n        }\r\n\r\n        if (expandDivs) {\r\n          transformBuf.length = 0;\r\n          paddingBuf.length = 0;\r\n\r\n          if (divProps.originalTransform) {\r\n            transformBuf.push(divProps.originalTransform);\r\n          }\r\n\r\n          if (divProps.paddingTop > 0) {\r\n            paddingBuf.push(`${divProps.paddingTop}px`);\r\n            transformBuf.push(`translateY(${-divProps.paddingTop}px)`);\r\n          } else {\r\n            paddingBuf.push(0);\r\n          }\r\n\r\n          if (divProps.paddingRight > 0) {\r\n            paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);\r\n          } else {\r\n            paddingBuf.push(0);\r\n          }\r\n\r\n          if (divProps.paddingBottom > 0) {\r\n            paddingBuf.push(`${divProps.paddingBottom}px`);\r\n          } else {\r\n            paddingBuf.push(0);\r\n          }\r\n\r\n          if (divProps.paddingLeft > 0) {\r\n            paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);\r\n            transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);\r\n          } else {\r\n            paddingBuf.push(0);\r\n          }\r\n\r\n          div.style.padding = paddingBuf.join(\" \");\r\n\r\n          if (transformBuf.length) {\r\n            div.style.transform = transformBuf.join(\" \");\r\n          }\r\n        } else {\r\n          div.style.padding = null;\r\n          div.style.transform = divProps.originalTransform;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  function renderTextLayer(renderParameters) {\r\n    const task = new TextLayerRenderTask({\r\n      textContent: renderParameters.textContent,\r\n      textContentStream: renderParameters.textContentStream,\r\n      container: renderParameters.container,\r\n      viewport: renderParameters.viewport,\r\n      textDivs: renderParameters.textDivs,\r\n      textContentItemsStr: renderParameters.textContentItemsStr,\r\n      enhanceTextSelection: renderParameters.enhanceTextSelection\r\n    });\r\n\r\n    task._render(renderParameters.timeout);\r\n\r\n    return task;\r\n  }\r\n\r\n  return renderTextLayer;\r\n}();\r\n\r\nexports.renderTextLayer = renderTextLayer;\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.SVGGraphics = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nvar _display_utils = __w_pdfjs_require__(1);\r\n\r\nvar _is_node = __w_pdfjs_require__(4);\r\n\r\nlet SVGGraphics = function () {\r\n  throw new Error(\"Not implemented: SVGGraphics\");\r\n};\r\n\r\nexports.SVGGraphics = SVGGraphics;\r\n{\r\n  const SVG_DEFAULTS = {\r\n    fontStyle: \"normal\",\r\n    fontWeight: \"normal\",\r\n    fillColor: \"#000000\"\r\n  };\r\n  const XML_NS = \"http://www.w3.org/XML/1998/namespace\";\r\n  const XLINK_NS = \"http://www.w3.org/1999/xlink\";\r\n  const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\r\n  const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\r\n\r\n  const convertImgDataToPng = function () {\r\n    const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\r\n    const CHUNK_WRAPPER_SIZE = 12;\r\n    const crcTable = new Int32Array(256);\r\n\r\n    for (let i = 0; i < 256; i++) {\r\n      let c = i;\r\n\r\n      for (let h = 0; h < 8; h++) {\r\n        if (c & 1) {\r\n          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;\r\n        } else {\r\n          c = c >> 1 & 0x7fffffff;\r\n        }\r\n      }\r\n\r\n      crcTable[i] = c;\r\n    }\r\n\r\n    function crc32(data, start, end) {\r\n      let crc = -1;\r\n\r\n      for (let i = start; i < end; i++) {\r\n        const a = (crc ^ data[i]) & 0xff;\r\n        const b = crcTable[a];\r\n        crc = crc >>> 8 ^ b;\r\n      }\r\n\r\n      return crc ^ -1;\r\n    }\r\n\r\n    function writePngChunk(type, body, data, offset) {\r\n      let p = offset;\r\n      const len = body.length;\r\n      data[p] = len >> 24 & 0xff;\r\n      data[p + 1] = len >> 16 & 0xff;\r\n      data[p + 2] = len >> 8 & 0xff;\r\n      data[p + 3] = len & 0xff;\r\n      p += 4;\r\n      data[p] = type.charCodeAt(0) & 0xff;\r\n      data[p + 1] = type.charCodeAt(1) & 0xff;\r\n      data[p + 2] = type.charCodeAt(2) & 0xff;\r\n      data[p + 3] = type.charCodeAt(3) & 0xff;\r\n      p += 4;\r\n      data.set(body, p);\r\n      p += body.length;\r\n      const crc = crc32(data, offset + 4, p);\r\n      data[p] = crc >> 24 & 0xff;\r\n      data[p + 1] = crc >> 16 & 0xff;\r\n      data[p + 2] = crc >> 8 & 0xff;\r\n      data[p + 3] = crc & 0xff;\r\n    }\r\n\r\n    function adler32(data, start, end) {\r\n      let a = 1;\r\n      let b = 0;\r\n\r\n      for (let i = start; i < end; ++i) {\r\n        a = (a + (data[i] & 0xff)) % 65521;\r\n        b = (b + a) % 65521;\r\n      }\r\n\r\n      return b << 16 | a;\r\n    }\r\n\r\n    function deflateSync(literals) {\r\n      if (!_is_node.isNodeJS) {\r\n        return deflateSyncUncompressed(literals);\r\n      }\r\n\r\n      try {\r\n        let input;\r\n\r\n        if (parseInt(process.versions.node) >= 8) {\r\n          input = literals;\r\n        } else {\r\n          input = Buffer.from(literals);\r\n        }\r\n\r\n        const output = require(\"zlib\").deflateSync(input, {\r\n          level: 9\r\n        });\r\n\r\n        return output instanceof Uint8Array ? output : new Uint8Array(output);\r\n      } catch (e) {\r\n        (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\r\n      }\r\n\r\n      return deflateSyncUncompressed(literals);\r\n    }\r\n\r\n    function deflateSyncUncompressed(literals) {\r\n      let len = literals.length;\r\n      const maxBlockLength = 0xffff;\r\n      const deflateBlocks = Math.ceil(len / maxBlockLength);\r\n      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\r\n      let pi = 0;\r\n      idat[pi++] = 0x78;\r\n      idat[pi++] = 0x9c;\r\n      let pos = 0;\r\n\r\n      while (len > maxBlockLength) {\r\n        idat[pi++] = 0x00;\r\n        idat[pi++] = 0xff;\r\n        idat[pi++] = 0xff;\r\n        idat[pi++] = 0x00;\r\n        idat[pi++] = 0x00;\r\n        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\r\n        pi += maxBlockLength;\r\n        pos += maxBlockLength;\r\n        len -= maxBlockLength;\r\n      }\r\n\r\n      idat[pi++] = 0x01;\r\n      idat[pi++] = len & 0xff;\r\n      idat[pi++] = len >> 8 & 0xff;\r\n      idat[pi++] = ~len & 0xffff & 0xff;\r\n      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\r\n      idat.set(literals.subarray(pos), pi);\r\n      pi += literals.length - pos;\r\n      const adler = adler32(literals, 0, literals.length);\r\n      idat[pi++] = adler >> 24 & 0xff;\r\n      idat[pi++] = adler >> 16 & 0xff;\r\n      idat[pi++] = adler >> 8 & 0xff;\r\n      idat[pi++] = adler & 0xff;\r\n      return idat;\r\n    }\r\n\r\n    function encode(imgData, kind, forceDataSchema, isMask) {\r\n      const width = imgData.width;\r\n      const height = imgData.height;\r\n      let bitDepth, colorType, lineSize;\r\n      const bytes = imgData.data;\r\n\r\n      switch (kind) {\r\n        case _util.ImageKind.GRAYSCALE_1BPP:\r\n          colorType = 0;\r\n          bitDepth = 1;\r\n          lineSize = width + 7 >> 3;\r\n          break;\r\n\r\n        case _util.ImageKind.RGB_24BPP:\r\n          colorType = 2;\r\n          bitDepth = 8;\r\n          lineSize = width * 3;\r\n          break;\r\n\r\n        case _util.ImageKind.RGBA_32BPP:\r\n          colorType = 6;\r\n          bitDepth = 8;\r\n          lineSize = width * 4;\r\n          break;\r\n\r\n        default:\r\n          throw new Error(\"invalid format\");\r\n      }\r\n\r\n      const literals = new Uint8Array((1 + lineSize) * height);\r\n      let offsetLiterals = 0,\r\n          offsetBytes = 0;\r\n\r\n      for (let y = 0; y < height; ++y) {\r\n        literals[offsetLiterals++] = 0;\r\n        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\r\n        offsetBytes += lineSize;\r\n        offsetLiterals += lineSize;\r\n      }\r\n\r\n      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\r\n        offsetLiterals = 0;\r\n\r\n        for (let y = 0; y < height; y++) {\r\n          offsetLiterals++;\r\n\r\n          for (let i = 0; i < lineSize; i++) {\r\n            literals[offsetLiterals++] ^= 0xff;\r\n          }\r\n        }\r\n      }\r\n\r\n      const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\r\n      const idat = deflateSync(literals);\r\n      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\r\n      const data = new Uint8Array(pngLength);\r\n      let offset = 0;\r\n      data.set(PNG_HEADER, offset);\r\n      offset += PNG_HEADER.length;\r\n      writePngChunk(\"IHDR\", ihdr, data, offset);\r\n      offset += CHUNK_WRAPPER_SIZE + ihdr.length;\r\n      writePngChunk(\"IDATA\", idat, data, offset);\r\n      offset += CHUNK_WRAPPER_SIZE + idat.length;\r\n      writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\r\n      return (0, _util.createObjectURL)(data, \"image/png\", forceDataSchema);\r\n    }\r\n\r\n    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\r\n      const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\r\n      return encode(imgData, kind, forceDataSchema, isMask);\r\n    };\r\n  }();\r\n\r\n  class SVGExtraState {\r\n    constructor() {\r\n      this.fontSizeScale = 1;\r\n      this.fontWeight = SVG_DEFAULTS.fontWeight;\r\n      this.fontSize = 0;\r\n      this.textMatrix = _util.IDENTITY_MATRIX;\r\n      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\r\n      this.leading = 0;\r\n      this.textRenderingMode = _util.TextRenderingMode.FILL;\r\n      this.textMatrixScale = 1;\r\n      this.x = 0;\r\n      this.y = 0;\r\n      this.lineX = 0;\r\n      this.lineY = 0;\r\n      this.charSpacing = 0;\r\n      this.wordSpacing = 0;\r\n      this.textHScale = 1;\r\n      this.textRise = 0;\r\n      this.fillColor = SVG_DEFAULTS.fillColor;\r\n      this.strokeColor = \"#000000\";\r\n      this.fillAlpha = 1;\r\n      this.strokeAlpha = 1;\r\n      this.lineWidth = 1;\r\n      this.lineJoin = \"\";\r\n      this.lineCap = \"\";\r\n      this.miterLimit = 0;\r\n      this.dashArray = [];\r\n      this.dashPhase = 0;\r\n      this.dependencies = [];\r\n      this.activeClipUrl = null;\r\n      this.clipGroup = null;\r\n      this.maskId = \"\";\r\n    }\r\n\r\n    clone() {\r\n      return Object.create(this);\r\n    }\r\n\r\n    setCurrentPoint(x, y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n\r\n  }\r\n\r\n  function opListToTree(opList) {\r\n    let opTree = [];\r\n    const tmp = [];\r\n\r\n    for (const opListElement of opList) {\r\n      if (opListElement.fn === \"save\") {\r\n        opTree.push({\r\n          fnId: 92,\r\n          fn: \"group\",\r\n          items: []\r\n        });\r\n        tmp.push(opTree);\r\n        opTree = opTree[opTree.length - 1].items;\r\n        continue;\r\n      }\r\n\r\n      if (opListElement.fn === \"restore\") {\r\n        opTree = tmp.pop();\r\n      } else {\r\n        opTree.push(opListElement);\r\n      }\r\n    }\r\n\r\n    return opTree;\r\n  }\r\n\r\n  function pf(value) {\r\n    if (Number.isInteger(value)) {\r\n      return value.toString();\r\n    }\r\n\r\n    const s = value.toFixed(10);\r\n    let i = s.length - 1;\r\n\r\n    if (s[i] !== \"0\") {\r\n      return s;\r\n    }\r\n\r\n    do {\r\n      i--;\r\n    } while (s[i] === \"0\");\r\n\r\n    return s.substring(0, s[i] === \".\" ? i : i + 1);\r\n  }\r\n\r\n  function pm(m) {\r\n    if (m[4] === 0 && m[5] === 0) {\r\n      if (m[1] === 0 && m[2] === 0) {\r\n        if (m[0] === 1 && m[3] === 1) {\r\n          return \"\";\r\n        }\r\n\r\n        return `scale(${pf(m[0])} ${pf(m[3])})`;\r\n      }\r\n\r\n      if (m[0] === m[3] && m[1] === -m[2]) {\r\n        const a = Math.acos(m[0]) * 180 / Math.PI;\r\n        return `rotate(${pf(a)})`;\r\n      }\r\n    } else {\r\n      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\r\n        return `translate(${pf(m[4])} ${pf(m[5])})`;\r\n      }\r\n    }\r\n\r\n    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\r\n  }\r\n\r\n  let clipCount = 0;\r\n  let maskCount = 0;\r\n  let shadingCount = 0;\r\n  exports.SVGGraphics = SVGGraphics = class SVGGraphics {\r\n    constructor(commonObjs, objs, forceDataSchema = false) {\r\n      this.svgFactory = new _display_utils.DOMSVGFactory();\r\n      this.current = new SVGExtraState();\r\n      this.transformMatrix = _util.IDENTITY_MATRIX;\r\n      this.transformStack = [];\r\n      this.extraStack = [];\r\n      this.commonObjs = commonObjs;\r\n      this.objs = objs;\r\n      this.pendingClip = null;\r\n      this.pendingEOFill = false;\r\n      this.embedFonts = false;\r\n      this.embeddedFonts = Object.create(null);\r\n      this.cssStyle = null;\r\n      this.forceDataSchema = !!forceDataSchema;\r\n      this._operatorIdMapping = [];\r\n\r\n      for (const op in _util.OPS) {\r\n        this._operatorIdMapping[_util.OPS[op]] = op;\r\n      }\r\n    }\r\n\r\n    save() {\r\n      this.transformStack.push(this.transformMatrix);\r\n      const old = this.current;\r\n      this.extraStack.push(old);\r\n      this.current = old.clone();\r\n    }\r\n\r\n    restore() {\r\n      this.transformMatrix = this.transformStack.pop();\r\n      this.current = this.extraStack.pop();\r\n      this.pendingClip = null;\r\n      this.tgrp = null;\r\n    }\r\n\r\n    group(items) {\r\n      this.save();\r\n      this.executeOpTree(items);\r\n      this.restore();\r\n    }\r\n\r\n    loadDependencies(operatorList) {\r\n      const fnArray = operatorList.fnArray;\r\n      const argsArray = operatorList.argsArray;\r\n\r\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\r\n        if (fnArray[i] !== _util.OPS.dependency) {\r\n          continue;\r\n        }\r\n\r\n        for (const obj of argsArray[i]) {\r\n          const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\r\n          const promise = new Promise(resolve => {\r\n            objsPool.get(obj, resolve);\r\n          });\r\n          this.current.dependencies.push(promise);\r\n        }\r\n      }\r\n\r\n      return Promise.all(this.current.dependencies);\r\n    }\r\n\r\n    transform(a, b, c, d, e, f) {\r\n      const transformMatrix = [a, b, c, d, e, f];\r\n      this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\r\n      this.tgrp = null;\r\n    }\r\n\r\n    getSVG(operatorList, viewport) {\r\n      this.viewport = viewport;\r\n\r\n      const svgElement = this._initialize(viewport);\r\n\r\n      return this.loadDependencies(operatorList).then(() => {\r\n        this.transformMatrix = _util.IDENTITY_MATRIX;\r\n        this.executeOpTree(this.convertOpList(operatorList));\r\n        return svgElement;\r\n      });\r\n    }\r\n\r\n    convertOpList(operatorList) {\r\n      const operatorIdMapping = this._operatorIdMapping;\r\n      const argsArray = operatorList.argsArray;\r\n      const fnArray = operatorList.fnArray;\r\n      const opList = [];\r\n\r\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\r\n        const fnId = fnArray[i];\r\n        opList.push({\r\n          fnId,\r\n          fn: operatorIdMapping[fnId],\r\n          args: argsArray[i]\r\n        });\r\n      }\r\n\r\n      return opListToTree(opList);\r\n    }\r\n\r\n    executeOpTree(opTree) {\r\n      for (const opTreeElement of opTree) {\r\n        const fn = opTreeElement.fn;\r\n        const fnId = opTreeElement.fnId;\r\n        const args = opTreeElement.args;\r\n\r\n        switch (fnId | 0) {\r\n          case _util.OPS.beginText:\r\n            this.beginText();\r\n            break;\r\n\r\n          case _util.OPS.dependency:\r\n            break;\r\n\r\n          case _util.OPS.setLeading:\r\n            this.setLeading(args);\r\n            break;\r\n\r\n          case _util.OPS.setLeadingMoveText:\r\n            this.setLeadingMoveText(args[0], args[1]);\r\n            break;\r\n\r\n          case _util.OPS.setFont:\r\n            this.setFont(args);\r\n            break;\r\n\r\n          case _util.OPS.showText:\r\n            this.showText(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.showSpacedText:\r\n            this.showText(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.endText:\r\n            this.endText();\r\n            break;\r\n\r\n          case _util.OPS.moveText:\r\n            this.moveText(args[0], args[1]);\r\n            break;\r\n\r\n          case _util.OPS.setCharSpacing:\r\n            this.setCharSpacing(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setWordSpacing:\r\n            this.setWordSpacing(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setHScale:\r\n            this.setHScale(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setTextMatrix:\r\n            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\r\n            break;\r\n\r\n          case _util.OPS.setTextRise:\r\n            this.setTextRise(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setTextRenderingMode:\r\n            this.setTextRenderingMode(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setLineWidth:\r\n            this.setLineWidth(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setLineJoin:\r\n            this.setLineJoin(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setLineCap:\r\n            this.setLineCap(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setMiterLimit:\r\n            this.setMiterLimit(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setFillRGBColor:\r\n            this.setFillRGBColor(args[0], args[1], args[2]);\r\n            break;\r\n\r\n          case _util.OPS.setStrokeRGBColor:\r\n            this.setStrokeRGBColor(args[0], args[1], args[2]);\r\n            break;\r\n\r\n          case _util.OPS.setStrokeColorN:\r\n            this.setStrokeColorN(args);\r\n            break;\r\n\r\n          case _util.OPS.setFillColorN:\r\n            this.setFillColorN(args);\r\n            break;\r\n\r\n          case _util.OPS.shadingFill:\r\n            this.shadingFill(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setDash:\r\n            this.setDash(args[0], args[1]);\r\n            break;\r\n\r\n          case _util.OPS.setRenderingIntent:\r\n            this.setRenderingIntent(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setFlatness:\r\n            this.setFlatness(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.setGState:\r\n            this.setGState(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.fill:\r\n            this.fill();\r\n            break;\r\n\r\n          case _util.OPS.eoFill:\r\n            this.eoFill();\r\n            break;\r\n\r\n          case _util.OPS.stroke:\r\n            this.stroke();\r\n            break;\r\n\r\n          case _util.OPS.fillStroke:\r\n            this.fillStroke();\r\n            break;\r\n\r\n          case _util.OPS.eoFillStroke:\r\n            this.eoFillStroke();\r\n            break;\r\n\r\n          case _util.OPS.clip:\r\n            this.clip(\"nonzero\");\r\n            break;\r\n\r\n          case _util.OPS.eoClip:\r\n            this.clip(\"evenodd\");\r\n            break;\r\n\r\n          case _util.OPS.paintSolidColorImageMask:\r\n            this.paintSolidColorImageMask();\r\n            break;\r\n\r\n          case _util.OPS.paintImageXObject:\r\n            this.paintImageXObject(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.paintInlineImageXObject:\r\n            this.paintInlineImageXObject(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.paintImageMaskXObject:\r\n            this.paintImageMaskXObject(args[0]);\r\n            break;\r\n\r\n          case _util.OPS.paintFormXObjectBegin:\r\n            this.paintFormXObjectBegin(args[0], args[1]);\r\n            break;\r\n\r\n          case _util.OPS.paintFormXObjectEnd:\r\n            this.paintFormXObjectEnd();\r\n            break;\r\n\r\n          case _util.OPS.closePath:\r\n            this.closePath();\r\n            break;\r\n\r\n          case _util.OPS.closeStroke:\r\n            this.closeStroke();\r\n            break;\r\n\r\n          case _util.OPS.closeFillStroke:\r\n            this.closeFillStroke();\r\n            break;\r\n\r\n          case _util.OPS.closeEOFillStroke:\r\n            this.closeEOFillStroke();\r\n            break;\r\n\r\n          case _util.OPS.nextLine:\r\n            this.nextLine();\r\n            break;\r\n\r\n          case _util.OPS.transform:\r\n            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\r\n            break;\r\n\r\n          case _util.OPS.constructPath:\r\n            this.constructPath(args[0], args[1]);\r\n            break;\r\n\r\n          case _util.OPS.endPath:\r\n            this.endPath();\r\n            break;\r\n\r\n          case 92:\r\n            this.group(opTreeElement.items);\r\n            break;\r\n\r\n          default:\r\n            (0, _util.warn)(`Unimplemented operator ${fn}`);\r\n            break;\r\n        }\r\n      }\r\n    }\r\n\r\n    setWordSpacing(wordSpacing) {\r\n      this.current.wordSpacing = wordSpacing;\r\n    }\r\n\r\n    setCharSpacing(charSpacing) {\r\n      this.current.charSpacing = charSpacing;\r\n    }\r\n\r\n    nextLine() {\r\n      this.moveText(0, this.current.leading);\r\n    }\r\n\r\n    setTextMatrix(a, b, c, d, e, f) {\r\n      const current = this.current;\r\n      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\r\n      current.textMatrixScale = Math.sqrt(a * a + b * b);\r\n      current.x = current.lineX = 0;\r\n      current.y = current.lineY = 0;\r\n      current.xcoords = [];\r\n      current.ycoords = [];\r\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\r\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\r\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\r\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\r\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\r\n      current.txtElement.appendChild(current.tspan);\r\n    }\r\n\r\n    beginText() {\r\n      const current = this.current;\r\n      current.x = current.lineX = 0;\r\n      current.y = current.lineY = 0;\r\n      current.textMatrix = _util.IDENTITY_MATRIX;\r\n      current.lineMatrix = _util.IDENTITY_MATRIX;\r\n      current.textMatrixScale = 1;\r\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\r\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\r\n      current.txtgrp = this.svgFactory.createElement(\"svg:g\");\r\n      current.xcoords = [];\r\n      current.ycoords = [];\r\n    }\r\n\r\n    moveText(x, y) {\r\n      const current = this.current;\r\n      current.x = current.lineX += x;\r\n      current.y = current.lineY += y;\r\n      current.xcoords = [];\r\n      current.ycoords = [];\r\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\r\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\r\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\r\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\r\n    }\r\n\r\n    showText(glyphs) {\r\n      const current = this.current;\r\n      const font = current.font;\r\n      const fontSize = current.fontSize;\r\n\r\n      if (fontSize === 0) {\r\n        return;\r\n      }\r\n\r\n      const fontSizeScale = current.fontSizeScale;\r\n      const charSpacing = current.charSpacing;\r\n      const wordSpacing = current.wordSpacing;\r\n      const fontDirection = current.fontDirection;\r\n      const textHScale = current.textHScale * fontDirection;\r\n      const vertical = font.vertical;\r\n      const spacingDir = vertical ? 1 : -1;\r\n      const defaultVMetrics = font.defaultVMetrics;\r\n      const widthAdvanceScale = fontSize * current.fontMatrix[0];\r\n      let x = 0;\r\n\r\n      for (const glyph of glyphs) {\r\n        if (glyph === null) {\r\n          x += fontDirection * wordSpacing;\r\n          continue;\r\n        } else if ((0, _util.isNum)(glyph)) {\r\n          x += spacingDir * glyph * fontSize / 1000;\r\n          continue;\r\n        }\r\n\r\n        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\r\n        const character = glyph.fontChar;\r\n        let scaledX, scaledY;\r\n        let width = glyph.width;\r\n\r\n        if (vertical) {\r\n          let vx;\r\n          const vmetric = glyph.vmetric || defaultVMetrics;\r\n          vx = glyph.vmetric ? vmetric[1] : width * 0.5;\r\n          vx = -vx * widthAdvanceScale;\r\n          const vy = vmetric[2] * widthAdvanceScale;\r\n          width = vmetric ? -vmetric[0] : width;\r\n          scaledX = vx / fontSizeScale;\r\n          scaledY = (x + vy) / fontSizeScale;\r\n        } else {\r\n          scaledX = x / fontSizeScale;\r\n          scaledY = 0;\r\n        }\r\n\r\n        if (glyph.isInFont || font.missingFile) {\r\n          current.xcoords.push(current.x + scaledX);\r\n\r\n          if (vertical) {\r\n            current.ycoords.push(-current.y + scaledY);\r\n          }\r\n\r\n          current.tspan.textContent += character;\r\n        } else {}\r\n\r\n        let charWidth;\r\n\r\n        if (vertical) {\r\n          charWidth = width * widthAdvanceScale - spacing * fontDirection;\r\n        } else {\r\n          charWidth = width * widthAdvanceScale + spacing * fontDirection;\r\n        }\r\n\r\n        x += charWidth;\r\n      }\r\n\r\n      current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\r\n\r\n      if (vertical) {\r\n        current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\r\n      } else {\r\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\r\n      }\r\n\r\n      if (vertical) {\r\n        current.y -= x;\r\n      } else {\r\n        current.x += x * textHScale;\r\n      }\r\n\r\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\r\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\r\n\r\n      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\r\n        current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\r\n      }\r\n\r\n      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\r\n        current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\r\n      }\r\n\r\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\r\n\r\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n        if (current.fillColor !== SVG_DEFAULTS.fillColor) {\r\n          current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\r\n        }\r\n\r\n        if (current.fillAlpha < 1) {\r\n          current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\r\n        }\r\n      } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\r\n        current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\r\n      } else {\r\n        current.tspan.setAttributeNS(null, \"fill\", \"none\");\r\n      }\r\n\r\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n        const lineWidthScale = 1 / (current.textMatrixScale || 1);\r\n\r\n        this._setStrokeAttributes(current.tspan, lineWidthScale);\r\n      }\r\n\r\n      let textMatrix = current.textMatrix;\r\n\r\n      if (current.textRise !== 0) {\r\n        textMatrix = textMatrix.slice();\r\n        textMatrix[5] += current.textRise;\r\n      }\r\n\r\n      current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\r\n      current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\r\n      current.txtElement.appendChild(current.tspan);\r\n      current.txtgrp.appendChild(current.txtElement);\r\n\r\n      this._ensureTransformGroup().appendChild(current.txtElement);\r\n    }\r\n\r\n    setLeadingMoveText(x, y) {\r\n      this.setLeading(-y);\r\n      this.moveText(x, y);\r\n    }\r\n\r\n    addFontStyle(fontObj) {\r\n      if (!fontObj.data) {\r\n        throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\r\n      }\r\n\r\n      if (!this.cssStyle) {\r\n        this.cssStyle = this.svgFactory.createElement(\"svg:style\");\r\n        this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\r\n        this.defs.appendChild(this.cssStyle);\r\n      }\r\n\r\n      const url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);\r\n      this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`;\r\n    }\r\n\r\n    setFont(details) {\r\n      const current = this.current;\r\n      const fontObj = this.commonObjs.get(details[0]);\r\n      let size = details[1];\r\n      current.font = fontObj;\r\n\r\n      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\r\n        this.addFontStyle(fontObj);\r\n        this.embeddedFonts[fontObj.loadedName] = fontObj;\r\n      }\r\n\r\n      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\r\n      let bold = \"normal\";\r\n\r\n      if (fontObj.black) {\r\n        bold = \"900\";\r\n      } else if (fontObj.bold) {\r\n        bold = \"bold\";\r\n      }\r\n\r\n      const italic = fontObj.italic ? \"italic\" : \"normal\";\r\n\r\n      if (size < 0) {\r\n        size = -size;\r\n        current.fontDirection = -1;\r\n      } else {\r\n        current.fontDirection = 1;\r\n      }\r\n\r\n      current.fontSize = size;\r\n      current.fontFamily = fontObj.loadedName;\r\n      current.fontWeight = bold;\r\n      current.fontStyle = italic;\r\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\r\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\r\n      current.xcoords = [];\r\n      current.ycoords = [];\r\n    }\r\n\r\n    endText() {\r\n      const current = this.current;\r\n\r\n      if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {\r\n        current.element = current.txtElement;\r\n        this.clip(\"nonzero\");\r\n        this.endPath();\r\n      }\r\n    }\r\n\r\n    setLineWidth(width) {\r\n      if (width > 0) {\r\n        this.current.lineWidth = width;\r\n      }\r\n    }\r\n\r\n    setLineCap(style) {\r\n      this.current.lineCap = LINE_CAP_STYLES[style];\r\n    }\r\n\r\n    setLineJoin(style) {\r\n      this.current.lineJoin = LINE_JOIN_STYLES[style];\r\n    }\r\n\r\n    setMiterLimit(limit) {\r\n      this.current.miterLimit = limit;\r\n    }\r\n\r\n    setStrokeAlpha(strokeAlpha) {\r\n      this.current.strokeAlpha = strokeAlpha;\r\n    }\r\n\r\n    setStrokeRGBColor(r, g, b) {\r\n      this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\r\n    }\r\n\r\n    setFillAlpha(fillAlpha) {\r\n      this.current.fillAlpha = fillAlpha;\r\n    }\r\n\r\n    setFillRGBColor(r, g, b) {\r\n      this.current.fillColor = _util.Util.makeHexColor(r, g, b);\r\n      this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\r\n      this.current.xcoords = [];\r\n      this.current.ycoords = [];\r\n    }\r\n\r\n    setStrokeColorN(args) {\r\n      this.current.strokeColor = this._makeColorN_Pattern(args);\r\n    }\r\n\r\n    setFillColorN(args) {\r\n      this.current.fillColor = this._makeColorN_Pattern(args);\r\n    }\r\n\r\n    shadingFill(args) {\r\n      const width = this.viewport.width;\r\n      const height = this.viewport.height;\r\n\r\n      const inv = _util.Util.inverseTransform(this.transformMatrix);\r\n\r\n      const bl = _util.Util.applyTransform([0, 0], inv);\r\n\r\n      const br = _util.Util.applyTransform([0, height], inv);\r\n\r\n      const ul = _util.Util.applyTransform([width, 0], inv);\r\n\r\n      const ur = _util.Util.applyTransform([width, height], inv);\r\n\r\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\r\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\r\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\r\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\r\n      const rect = this.svgFactory.createElement(\"svg:rect\");\r\n      rect.setAttributeNS(null, \"x\", x0);\r\n      rect.setAttributeNS(null, \"y\", y0);\r\n      rect.setAttributeNS(null, \"width\", x1 - x0);\r\n      rect.setAttributeNS(null, \"height\", y1 - y0);\r\n      rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\r\n\r\n      if (this.current.fillAlpha < 1) {\r\n        rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\r\n      }\r\n\r\n      this._ensureTransformGroup().appendChild(rect);\r\n    }\r\n\r\n    _makeColorN_Pattern(args) {\r\n      if (args[0] === \"TilingPattern\") {\r\n        return this._makeTilingPattern(args);\r\n      }\r\n\r\n      return this._makeShadingPattern(args);\r\n    }\r\n\r\n    _makeTilingPattern(args) {\r\n      const color = args[1];\r\n      const operatorList = args[2];\r\n      const matrix = args[3] || _util.IDENTITY_MATRIX;\r\n      const [x0, y0, x1, y1] = args[4];\r\n      const xstep = args[5];\r\n      const ystep = args[6];\r\n      const paintType = args[7];\r\n      const tilingId = `shading${shadingCount++}`;\r\n\r\n      const [tx0, ty0] = _util.Util.applyTransform([x0, y0], matrix);\r\n\r\n      const [tx1, ty1] = _util.Util.applyTransform([x1, y1], matrix);\r\n\r\n      const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\r\n\r\n      const txstep = xstep * xscale;\r\n      const tystep = ystep * yscale;\r\n      const tiling = this.svgFactory.createElement(\"svg:pattern\");\r\n      tiling.setAttributeNS(null, \"id\", tilingId);\r\n      tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\r\n      tiling.setAttributeNS(null, \"width\", txstep);\r\n      tiling.setAttributeNS(null, \"height\", tystep);\r\n      tiling.setAttributeNS(null, \"x\", `${tx0}`);\r\n      tiling.setAttributeNS(null, \"y\", `${ty0}`);\r\n      const svg = this.svg;\r\n      const transformMatrix = this.transformMatrix;\r\n      const fillColor = this.current.fillColor;\r\n      const strokeColor = this.current.strokeColor;\r\n      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\r\n      this.svg = bbox;\r\n      this.transformMatrix = matrix;\r\n\r\n      if (paintType === 2) {\r\n        const cssColor = _util.Util.makeHexColor(...color);\r\n\r\n        this.current.fillColor = cssColor;\r\n        this.current.strokeColor = cssColor;\r\n      }\r\n\r\n      this.executeOpTree(this.convertOpList(operatorList));\r\n      this.svg = svg;\r\n      this.transformMatrix = transformMatrix;\r\n      this.current.fillColor = fillColor;\r\n      this.current.strokeColor = strokeColor;\r\n      tiling.appendChild(bbox.childNodes[0]);\r\n      this.defs.appendChild(tiling);\r\n      return `url(#${tilingId})`;\r\n    }\r\n\r\n    _makeShadingPattern(args) {\r\n      switch (args[0]) {\r\n        case \"RadialAxial\":\r\n          const shadingId = `shading${shadingCount++}`;\r\n          const colorStops = args[3];\r\n          let gradient;\r\n\r\n          switch (args[1]) {\r\n            case \"axial\":\r\n              const point0 = args[4];\r\n              const point1 = args[5];\r\n              gradient = this.svgFactory.createElement(\"svg:linearGradient\");\r\n              gradient.setAttributeNS(null, \"id\", shadingId);\r\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\r\n              gradient.setAttributeNS(null, \"x1\", point0[0]);\r\n              gradient.setAttributeNS(null, \"y1\", point0[1]);\r\n              gradient.setAttributeNS(null, \"x2\", point1[0]);\r\n              gradient.setAttributeNS(null, \"y2\", point1[1]);\r\n              break;\r\n\r\n            case \"radial\":\r\n              const focalPoint = args[4];\r\n              const circlePoint = args[5];\r\n              const focalRadius = args[6];\r\n              const circleRadius = args[7];\r\n              gradient = this.svgFactory.createElement(\"svg:radialGradient\");\r\n              gradient.setAttributeNS(null, \"id\", shadingId);\r\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\r\n              gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\r\n              gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\r\n              gradient.setAttributeNS(null, \"r\", circleRadius);\r\n              gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\r\n              gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\r\n              gradient.setAttributeNS(null, \"fr\", focalRadius);\r\n              break;\r\n\r\n            default:\r\n              throw new Error(`Unknown RadialAxial type: ${args[1]}`);\r\n          }\r\n\r\n          for (const colorStop of colorStops) {\r\n            const stop = this.svgFactory.createElement(\"svg:stop\");\r\n            stop.setAttributeNS(null, \"offset\", colorStop[0]);\r\n            stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\r\n            gradient.appendChild(stop);\r\n          }\r\n\r\n          this.defs.appendChild(gradient);\r\n          return `url(#${shadingId})`;\r\n\r\n        case \"Mesh\":\r\n          (0, _util.warn)(\"Unimplemented pattern Mesh\");\r\n          return null;\r\n\r\n        case \"Dummy\":\r\n          return \"hotpink\";\r\n\r\n        default:\r\n          throw new Error(`Unknown IR type: ${args[0]}`);\r\n      }\r\n    }\r\n\r\n    setDash(dashArray, dashPhase) {\r\n      this.current.dashArray = dashArray;\r\n      this.current.dashPhase = dashPhase;\r\n    }\r\n\r\n    constructPath(ops, args) {\r\n      const current = this.current;\r\n      let x = current.x,\r\n          y = current.y;\r\n      let d = [];\r\n      let j = 0;\r\n\r\n      for (const op of ops) {\r\n        switch (op | 0) {\r\n          case _util.OPS.rectangle:\r\n            x = args[j++];\r\n            y = args[j++];\r\n            const width = args[j++];\r\n            const height = args[j++];\r\n            const xw = x + width;\r\n            const yh = y + height;\r\n            d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\r\n            break;\r\n\r\n          case _util.OPS.moveTo:\r\n            x = args[j++];\r\n            y = args[j++];\r\n            d.push(\"M\", pf(x), pf(y));\r\n            break;\r\n\r\n          case _util.OPS.lineTo:\r\n            x = args[j++];\r\n            y = args[j++];\r\n            d.push(\"L\", pf(x), pf(y));\r\n            break;\r\n\r\n          case _util.OPS.curveTo:\r\n            x = args[j + 4];\r\n            y = args[j + 5];\r\n            d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\r\n            j += 6;\r\n            break;\r\n\r\n          case _util.OPS.curveTo2:\r\n            d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\r\n            x = args[j + 2];\r\n            y = args[j + 3];\r\n            j += 4;\r\n            break;\r\n\r\n          case _util.OPS.curveTo3:\r\n            x = args[j + 2];\r\n            y = args[j + 3];\r\n            d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\r\n            j += 4;\r\n            break;\r\n\r\n          case _util.OPS.closePath:\r\n            d.push(\"Z\");\r\n            break;\r\n        }\r\n      }\r\n\r\n      d = d.join(\" \");\r\n\r\n      if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\r\n        d = current.path.getAttributeNS(null, \"d\") + d;\r\n      } else {\r\n        current.path = this.svgFactory.createElement(\"svg:path\");\r\n\r\n        this._ensureTransformGroup().appendChild(current.path);\r\n      }\r\n\r\n      current.path.setAttributeNS(null, \"d\", d);\r\n      current.path.setAttributeNS(null, \"fill\", \"none\");\r\n      current.element = current.path;\r\n      current.setCurrentPoint(x, y);\r\n    }\r\n\r\n    endPath() {\r\n      const current = this.current;\r\n      current.path = null;\r\n\r\n      if (!this.pendingClip) {\r\n        return;\r\n      }\r\n\r\n      if (!current.element) {\r\n        this.pendingClip = null;\r\n        return;\r\n      }\r\n\r\n      const clipId = `clippath${clipCount++}`;\r\n      const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\r\n      clipPath.setAttributeNS(null, \"id\", clipId);\r\n      clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\r\n      const clipElement = current.element.cloneNode(true);\r\n\r\n      if (this.pendingClip === \"evenodd\") {\r\n        clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\r\n      } else {\r\n        clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\r\n      }\r\n\r\n      this.pendingClip = null;\r\n      clipPath.appendChild(clipElement);\r\n      this.defs.appendChild(clipPath);\r\n\r\n      if (current.activeClipUrl) {\r\n        current.clipGroup = null;\r\n        this.extraStack.forEach(function (prev) {\r\n          prev.clipGroup = null;\r\n        });\r\n        clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\r\n      }\r\n\r\n      current.activeClipUrl = `url(#${clipId})`;\r\n      this.tgrp = null;\r\n    }\r\n\r\n    clip(type) {\r\n      this.pendingClip = type;\r\n    }\r\n\r\n    closePath() {\r\n      const current = this.current;\r\n\r\n      if (current.path) {\r\n        const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\r\n        current.path.setAttributeNS(null, \"d\", d);\r\n      }\r\n    }\r\n\r\n    setLeading(leading) {\r\n      this.current.leading = -leading;\r\n    }\r\n\r\n    setTextRise(textRise) {\r\n      this.current.textRise = textRise;\r\n    }\r\n\r\n    setTextRenderingMode(textRenderingMode) {\r\n      this.current.textRenderingMode = textRenderingMode;\r\n    }\r\n\r\n    setHScale(scale) {\r\n      this.current.textHScale = scale / 100;\r\n    }\r\n\r\n    setRenderingIntent(intent) {}\r\n\r\n    setFlatness(flatness) {}\r\n\r\n    setGState(states) {\r\n      for (const [key, value] of states) {\r\n        switch (key) {\r\n          case \"LW\":\r\n            this.setLineWidth(value);\r\n            break;\r\n\r\n          case \"LC\":\r\n            this.setLineCap(value);\r\n            break;\r\n\r\n          case \"LJ\":\r\n            this.setLineJoin(value);\r\n            break;\r\n\r\n          case \"ML\":\r\n            this.setMiterLimit(value);\r\n            break;\r\n\r\n          case \"D\":\r\n            this.setDash(value[0], value[1]);\r\n            break;\r\n\r\n          case \"RI\":\r\n            this.setRenderingIntent(value);\r\n            break;\r\n\r\n          case \"FL\":\r\n            this.setFlatness(value);\r\n            break;\r\n\r\n          case \"Font\":\r\n            this.setFont(value);\r\n            break;\r\n\r\n          case \"CA\":\r\n            this.setStrokeAlpha(value);\r\n            break;\r\n\r\n          case \"ca\":\r\n            this.setFillAlpha(value);\r\n            break;\r\n\r\n          default:\r\n            (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\r\n            break;\r\n        }\r\n      }\r\n    }\r\n\r\n    fill() {\r\n      const current = this.current;\r\n\r\n      if (current.element) {\r\n        current.element.setAttributeNS(null, \"fill\", current.fillColor);\r\n        current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\r\n        this.endPath();\r\n      }\r\n    }\r\n\r\n    stroke() {\r\n      const current = this.current;\r\n\r\n      if (current.element) {\r\n        this._setStrokeAttributes(current.element);\r\n\r\n        current.element.setAttributeNS(null, \"fill\", \"none\");\r\n        this.endPath();\r\n      }\r\n    }\r\n\r\n    _setStrokeAttributes(element, lineWidthScale = 1) {\r\n      const current = this.current;\r\n      let dashArray = current.dashArray;\r\n\r\n      if (lineWidthScale !== 1 && dashArray.length > 0) {\r\n        dashArray = dashArray.map(function (value) {\r\n          return lineWidthScale * value;\r\n        });\r\n      }\r\n\r\n      element.setAttributeNS(null, \"stroke\", current.strokeColor);\r\n      element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\r\n      element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\r\n      element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\r\n      element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\r\n      element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\r\n      element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\r\n      element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\r\n    }\r\n\r\n    eoFill() {\r\n      if (this.current.element) {\r\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\r\n      }\r\n\r\n      this.fill();\r\n    }\r\n\r\n    fillStroke() {\r\n      this.stroke();\r\n      this.fill();\r\n    }\r\n\r\n    eoFillStroke() {\r\n      if (this.current.element) {\r\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\r\n      }\r\n\r\n      this.fillStroke();\r\n    }\r\n\r\n    closeStroke() {\r\n      this.closePath();\r\n      this.stroke();\r\n    }\r\n\r\n    closeFillStroke() {\r\n      this.closePath();\r\n      this.fillStroke();\r\n    }\r\n\r\n    closeEOFillStroke() {\r\n      this.closePath();\r\n      this.eoFillStroke();\r\n    }\r\n\r\n    paintSolidColorImageMask() {\r\n      const rect = this.svgFactory.createElement(\"svg:rect\");\r\n      rect.setAttributeNS(null, \"x\", \"0\");\r\n      rect.setAttributeNS(null, \"y\", \"0\");\r\n      rect.setAttributeNS(null, \"width\", \"1px\");\r\n      rect.setAttributeNS(null, \"height\", \"1px\");\r\n      rect.setAttributeNS(null, \"fill\", this.current.fillColor);\r\n\r\n      this._ensureTransformGroup().appendChild(rect);\r\n    }\r\n\r\n    paintImageXObject(objId) {\r\n      const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\r\n\r\n      if (!imgData) {\r\n        (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\r\n        return;\r\n      }\r\n\r\n      this.paintInlineImageXObject(imgData);\r\n    }\r\n\r\n    paintInlineImageXObject(imgData, mask) {\r\n      const width = imgData.width;\r\n      const height = imgData.height;\r\n      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\r\n      const cliprect = this.svgFactory.createElement(\"svg:rect\");\r\n      cliprect.setAttributeNS(null, \"x\", \"0\");\r\n      cliprect.setAttributeNS(null, \"y\", \"0\");\r\n      cliprect.setAttributeNS(null, \"width\", pf(width));\r\n      cliprect.setAttributeNS(null, \"height\", pf(height));\r\n      this.current.element = cliprect;\r\n      this.clip(\"nonzero\");\r\n      const imgEl = this.svgFactory.createElement(\"svg:image\");\r\n      imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\r\n      imgEl.setAttributeNS(null, \"x\", \"0\");\r\n      imgEl.setAttributeNS(null, \"y\", pf(-height));\r\n      imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\r\n      imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\r\n      imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\r\n\r\n      if (mask) {\r\n        mask.appendChild(imgEl);\r\n      } else {\r\n        this._ensureTransformGroup().appendChild(imgEl);\r\n      }\r\n    }\r\n\r\n    paintImageMaskXObject(imgData) {\r\n      const current = this.current;\r\n      const width = imgData.width;\r\n      const height = imgData.height;\r\n      const fillColor = current.fillColor;\r\n      current.maskId = `mask${maskCount++}`;\r\n      const mask = this.svgFactory.createElement(\"svg:mask\");\r\n      mask.setAttributeNS(null, \"id\", current.maskId);\r\n      const rect = this.svgFactory.createElement(\"svg:rect\");\r\n      rect.setAttributeNS(null, \"x\", \"0\");\r\n      rect.setAttributeNS(null, \"y\", \"0\");\r\n      rect.setAttributeNS(null, \"width\", pf(width));\r\n      rect.setAttributeNS(null, \"height\", pf(height));\r\n      rect.setAttributeNS(null, \"fill\", fillColor);\r\n      rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\r\n      this.defs.appendChild(mask);\r\n\r\n      this._ensureTransformGroup().appendChild(rect);\r\n\r\n      this.paintInlineImageXObject(imgData, mask);\r\n    }\r\n\r\n    paintFormXObjectBegin(matrix, bbox) {\r\n      if (Array.isArray(matrix) && matrix.length === 6) {\r\n        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\r\n      }\r\n\r\n      if (bbox) {\r\n        const width = bbox[2] - bbox[0];\r\n        const height = bbox[3] - bbox[1];\r\n        const cliprect = this.svgFactory.createElement(\"svg:rect\");\r\n        cliprect.setAttributeNS(null, \"x\", bbox[0]);\r\n        cliprect.setAttributeNS(null, \"y\", bbox[1]);\r\n        cliprect.setAttributeNS(null, \"width\", pf(width));\r\n        cliprect.setAttributeNS(null, \"height\", pf(height));\r\n        this.current.element = cliprect;\r\n        this.clip(\"nonzero\");\r\n        this.endPath();\r\n      }\r\n    }\r\n\r\n    paintFormXObjectEnd() {}\r\n\r\n    _initialize(viewport) {\r\n      const svg = this.svgFactory.create(viewport.width, viewport.height);\r\n      const definitions = this.svgFactory.createElement(\"svg:defs\");\r\n      svg.appendChild(definitions);\r\n      this.defs = definitions;\r\n      const rootGroup = this.svgFactory.createElement(\"svg:g\");\r\n      rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\r\n      svg.appendChild(rootGroup);\r\n      this.svg = rootGroup;\r\n      return svg;\r\n    }\r\n\r\n    _ensureClipGroup() {\r\n      if (!this.current.clipGroup) {\r\n        const clipGroup = this.svgFactory.createElement(\"svg:g\");\r\n        clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\r\n        this.svg.appendChild(clipGroup);\r\n        this.current.clipGroup = clipGroup;\r\n      }\r\n\r\n      return this.current.clipGroup;\r\n    }\r\n\r\n    _ensureTransformGroup() {\r\n      if (!this.tgrp) {\r\n        this.tgrp = this.svgFactory.createElement(\"svg:g\");\r\n        this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\r\n\r\n        if (this.current.activeClipUrl) {\r\n          this._ensureClipGroup().appendChild(this.tgrp);\r\n        } else {\r\n          this.svg.appendChild(this.tgrp);\r\n        }\r\n      }\r\n\r\n      return this.tgrp;\r\n    }\r\n\r\n  };\r\n}\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.PDFNodeStream = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nvar _network_utils = __w_pdfjs_require__(24);\r\n\r\n;\r\n\r\nconst fs = require(\"fs\");\r\n\r\nconst http = require(\"http\");\r\n\r\nconst https = require(\"https\");\r\n\r\nconst url = require(\"url\");\r\n\r\nconst fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\r\n\r\nfunction parseUrl(sourceUrl) {\r\n  const parsedUrl = url.parse(sourceUrl);\r\n\r\n  if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\r\n    return parsedUrl;\r\n  }\r\n\r\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\r\n    return url.parse(`file:///${sourceUrl}`);\r\n  }\r\n\r\n  if (!parsedUrl.host) {\r\n    parsedUrl.protocol = \"file:\";\r\n  }\r\n\r\n  return parsedUrl;\r\n}\r\n\r\nclass PDFNodeStream {\r\n  constructor(source) {\r\n    this.source = source;\r\n    this.url = parseUrl(source.url);\r\n    this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\r\n    this.isFsUrl = this.url.protocol === \"file:\";\r\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\r\n    this._fullRequestReader = null;\r\n    this._rangeRequestReaders = [];\r\n  }\r\n\r\n  get _progressiveDataLength() {\r\n    return this._fullRequestReader?._loaded ?? 0;\r\n  }\r\n\r\n  getFullReader() {\r\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\r\n    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\r\n    return this._fullRequestReader;\r\n  }\r\n\r\n  getRangeReader(start, end) {\r\n    if (end <= this._progressiveDataLength) {\r\n      return null;\r\n    }\r\n\r\n    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\r\n\r\n    this._rangeRequestReaders.push(rangeReader);\r\n\r\n    return rangeReader;\r\n  }\r\n\r\n  cancelAllRequests(reason) {\r\n    if (this._fullRequestReader) {\r\n      this._fullRequestReader.cancel(reason);\r\n    }\r\n\r\n    const readers = this._rangeRequestReaders.slice(0);\r\n\r\n    readers.forEach(function (reader) {\r\n      reader.cancel(reason);\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexports.PDFNodeStream = PDFNodeStream;\r\n\r\nclass BaseFullReader {\r\n  constructor(stream) {\r\n    this._url = stream.url;\r\n    this._done = false;\r\n    this._storedError = null;\r\n    this.onProgress = null;\r\n    const source = stream.source;\r\n    this._contentLength = source.length;\r\n    this._loaded = 0;\r\n    this._filename = null;\r\n    this._disableRange = source.disableRange || false;\r\n    this._rangeChunkSize = source.rangeChunkSize;\r\n\r\n    if (!this._rangeChunkSize && !this._disableRange) {\r\n      this._disableRange = true;\r\n    }\r\n\r\n    this._isStreamingSupported = !source.disableStream;\r\n    this._isRangeSupported = !source.disableRange;\r\n    this._readableStream = null;\r\n    this._readCapability = (0, _util.createPromiseCapability)();\r\n    this._headersCapability = (0, _util.createPromiseCapability)();\r\n  }\r\n\r\n  get headersReady() {\r\n    return this._headersCapability.promise;\r\n  }\r\n\r\n  get filename() {\r\n    return this._filename;\r\n  }\r\n\r\n  get contentLength() {\r\n    return this._contentLength;\r\n  }\r\n\r\n  get isRangeSupported() {\r\n    return this._isRangeSupported;\r\n  }\r\n\r\n  get isStreamingSupported() {\r\n    return this._isStreamingSupported;\r\n  }\r\n\r\n  async read() {\r\n    await this._readCapability.promise;\r\n\r\n    if (this._done) {\r\n      return {\r\n        value: undefined,\r\n        done: true\r\n      };\r\n    }\r\n\r\n    if (this._storedError) {\r\n      throw this._storedError;\r\n    }\r\n\r\n    const chunk = this._readableStream.read();\r\n\r\n    if (chunk === null) {\r\n      this._readCapability = (0, _util.createPromiseCapability)();\r\n      return this.read();\r\n    }\r\n\r\n    this._loaded += chunk.length;\r\n\r\n    if (this.onProgress) {\r\n      this.onProgress({\r\n        loaded: this._loaded,\r\n        total: this._contentLength\r\n      });\r\n    }\r\n\r\n    const buffer = new Uint8Array(chunk).buffer;\r\n    return {\r\n      value: buffer,\r\n      done: false\r\n    };\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (!this._readableStream) {\r\n      this._error(reason);\r\n\r\n      return;\r\n    }\r\n\r\n    this._readableStream.destroy(reason);\r\n  }\r\n\r\n  _error(reason) {\r\n    this._storedError = reason;\r\n\r\n    this._readCapability.resolve();\r\n  }\r\n\r\n  _setReadableStream(readableStream) {\r\n    this._readableStream = readableStream;\r\n    readableStream.on(\"readable\", () => {\r\n      this._readCapability.resolve();\r\n    });\r\n    readableStream.on(\"end\", () => {\r\n      readableStream.destroy();\r\n      this._done = true;\r\n\r\n      this._readCapability.resolve();\r\n    });\r\n    readableStream.on(\"error\", reason => {\r\n      this._error(reason);\r\n    });\r\n\r\n    if (!this._isStreamingSupported && this._isRangeSupported) {\r\n      this._error(new _util.AbortException(\"streaming is disabled\"));\r\n    }\r\n\r\n    if (this._storedError) {\r\n      this._readableStream.destroy(this._storedError);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nclass BaseRangeReader {\r\n  constructor(stream) {\r\n    this._url = stream.url;\r\n    this._done = false;\r\n    this._storedError = null;\r\n    this.onProgress = null;\r\n    this._loaded = 0;\r\n    this._readableStream = null;\r\n    this._readCapability = (0, _util.createPromiseCapability)();\r\n    const source = stream.source;\r\n    this._isStreamingSupported = !source.disableStream;\r\n  }\r\n\r\n  get isStreamingSupported() {\r\n    return this._isStreamingSupported;\r\n  }\r\n\r\n  async read() {\r\n    await this._readCapability.promise;\r\n\r\n    if (this._done) {\r\n      return {\r\n        value: undefined,\r\n        done: true\r\n      };\r\n    }\r\n\r\n    if (this._storedError) {\r\n      throw this._storedError;\r\n    }\r\n\r\n    const chunk = this._readableStream.read();\r\n\r\n    if (chunk === null) {\r\n      this._readCapability = (0, _util.createPromiseCapability)();\r\n      return this.read();\r\n    }\r\n\r\n    this._loaded += chunk.length;\r\n\r\n    if (this.onProgress) {\r\n      this.onProgress({\r\n        loaded: this._loaded\r\n      });\r\n    }\r\n\r\n    const buffer = new Uint8Array(chunk).buffer;\r\n    return {\r\n      value: buffer,\r\n      done: false\r\n    };\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (!this._readableStream) {\r\n      this._error(reason);\r\n\r\n      return;\r\n    }\r\n\r\n    this._readableStream.destroy(reason);\r\n  }\r\n\r\n  _error(reason) {\r\n    this._storedError = reason;\r\n\r\n    this._readCapability.resolve();\r\n  }\r\n\r\n  _setReadableStream(readableStream) {\r\n    this._readableStream = readableStream;\r\n    readableStream.on(\"readable\", () => {\r\n      this._readCapability.resolve();\r\n    });\r\n    readableStream.on(\"end\", () => {\r\n      readableStream.destroy();\r\n      this._done = true;\r\n\r\n      this._readCapability.resolve();\r\n    });\r\n    readableStream.on(\"error\", reason => {\r\n      this._error(reason);\r\n    });\r\n\r\n    if (this._storedError) {\r\n      this._readableStream.destroy(this._storedError);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nfunction createRequestOptions(parsedUrl, headers) {\r\n  return {\r\n    protocol: parsedUrl.protocol,\r\n    auth: parsedUrl.auth,\r\n    host: parsedUrl.hostname,\r\n    port: parsedUrl.port,\r\n    path: parsedUrl.path,\r\n    method: \"GET\",\r\n    headers\r\n  };\r\n}\r\n\r\nclass PDFNodeStreamFullReader extends BaseFullReader {\r\n  constructor(stream) {\r\n    super(stream);\r\n\r\n    const handleResponse = response => {\r\n      if (response.statusCode === 404) {\r\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\r\n        this._storedError = error;\r\n\r\n        this._headersCapability.reject(error);\r\n\r\n        return;\r\n      }\r\n\r\n      this._headersCapability.resolve();\r\n\r\n      this._setReadableStream(response);\r\n\r\n      const getResponseHeader = name => {\r\n        return this._readableStream.headers[name.toLowerCase()];\r\n      };\r\n\r\n      const {\r\n        allowRangeRequests,\r\n        suggestedLength\r\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\r\n        getResponseHeader,\r\n        isHttp: stream.isHttp,\r\n        rangeChunkSize: this._rangeChunkSize,\r\n        disableRange: this._disableRange\r\n      });\r\n      this._isRangeSupported = allowRangeRequests;\r\n      this._contentLength = suggestedLength || this._contentLength;\r\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\r\n    };\r\n\r\n    this._request = null;\r\n\r\n    if (this._url.protocol === \"http:\") {\r\n      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\r\n    } else {\r\n      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\r\n    }\r\n\r\n    this._request.on(\"error\", reason => {\r\n      this._storedError = reason;\r\n\r\n      this._headersCapability.reject(reason);\r\n    });\r\n\r\n    this._request.end();\r\n  }\r\n\r\n}\r\n\r\nclass PDFNodeStreamRangeReader extends BaseRangeReader {\r\n  constructor(stream, start, end) {\r\n    super(stream);\r\n    this._httpHeaders = {};\r\n\r\n    for (const property in stream.httpHeaders) {\r\n      const value = stream.httpHeaders[property];\r\n\r\n      if (typeof value === \"undefined\") {\r\n        continue;\r\n      }\r\n\r\n      this._httpHeaders[property] = value;\r\n    }\r\n\r\n    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\r\n\r\n    const handleResponse = response => {\r\n      if (response.statusCode === 404) {\r\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\r\n        this._storedError = error;\r\n        return;\r\n      }\r\n\r\n      this._setReadableStream(response);\r\n    };\r\n\r\n    this._request = null;\r\n\r\n    if (this._url.protocol === \"http:\") {\r\n      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\r\n    } else {\r\n      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\r\n    }\r\n\r\n    this._request.on(\"error\", reason => {\r\n      this._storedError = reason;\r\n    });\r\n\r\n    this._request.end();\r\n  }\r\n\r\n}\r\n\r\nclass PDFNodeStreamFsFullReader extends BaseFullReader {\r\n  constructor(stream) {\r\n    super(stream);\r\n    let path = decodeURIComponent(this._url.path);\r\n\r\n    if (fileUriRegex.test(this._url.href)) {\r\n      path = path.replace(/^\\//, \"\");\r\n    }\r\n\r\n    fs.lstat(path, (error, stat) => {\r\n      if (error) {\r\n        if (error.code === \"ENOENT\") {\r\n          error = new _util.MissingPDFException(`Missing PDF \"${path}\".`);\r\n        }\r\n\r\n        this._storedError = error;\r\n\r\n        this._headersCapability.reject(error);\r\n\r\n        return;\r\n      }\r\n\r\n      this._contentLength = stat.size;\r\n\r\n      this._setReadableStream(fs.createReadStream(path));\r\n\r\n      this._headersCapability.resolve();\r\n    });\r\n  }\r\n\r\n}\r\n\r\nclass PDFNodeStreamFsRangeReader extends BaseRangeReader {\r\n  constructor(stream, start, end) {\r\n    super(stream);\r\n    let path = decodeURIComponent(this._url.path);\r\n\r\n    if (fileUriRegex.test(this._url.href)) {\r\n      path = path.replace(/^\\//, \"\");\r\n    }\r\n\r\n    this._setReadableStream(fs.createReadStream(path, {\r\n      start,\r\n      end: end - 1\r\n    }));\r\n  }\r\n\r\n}\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.createResponseStatusError = createResponseStatusError;\r\nexports.extractFilenameFromHeader = extractFilenameFromHeader;\r\nexports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\r\nexports.validateResponseStatus = validateResponseStatus;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nvar _content_disposition = __w_pdfjs_require__(25);\r\n\r\nfunction validateRangeRequestCapabilities({\r\n  getResponseHeader,\r\n  isHttp,\r\n  rangeChunkSize,\r\n  disableRange\r\n}) {\r\n  (0, _util.assert)(rangeChunkSize > 0, \"Range chunk size must be larger than zero\");\r\n  const returnValues = {\r\n    allowRangeRequests: false,\r\n    suggestedLength: undefined\r\n  };\r\n  const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\r\n\r\n  if (!Number.isInteger(length)) {\r\n    return returnValues;\r\n  }\r\n\r\n  returnValues.suggestedLength = length;\r\n\r\n  if (length <= 2 * rangeChunkSize) {\r\n    return returnValues;\r\n  }\r\n\r\n  if (disableRange || !isHttp) {\r\n    return returnValues;\r\n  }\r\n\r\n  if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\r\n    return returnValues;\r\n  }\r\n\r\n  const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\r\n\r\n  if (contentEncoding !== \"identity\") {\r\n    return returnValues;\r\n  }\r\n\r\n  returnValues.allowRangeRequests = true;\r\n  return returnValues;\r\n}\r\n\r\nfunction extractFilenameFromHeader(getResponseHeader) {\r\n  const contentDisposition = getResponseHeader(\"Content-Disposition\");\r\n\r\n  if (contentDisposition) {\r\n    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\r\n\r\n    if (filename.includes(\"%\")) {\r\n      try {\r\n        filename = decodeURIComponent(filename);\r\n      } catch (ex) {}\r\n    }\r\n\r\n    if (/\\.pdf$/i.test(filename)) {\r\n      return filename;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction createResponseStatusError(status, url) {\r\n  if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\r\n    return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\r\n  }\r\n\r\n  return new _util.UnexpectedResponseException(\"Unexpected server response (\" + status + ') while retrieving PDF \"' + url + '\".', status);\r\n}\r\n\r\nfunction validateResponseStatus(status) {\r\n  return status === 200 || status === 206;\r\n}\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ ((__unused_webpack_module, exports) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\r\n\r\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\r\n  let needsEncodingFixup = true;\r\n  let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\r\n\r\n  if (tmp) {\r\n    tmp = tmp[1];\r\n    let filename = rfc2616unquote(tmp);\r\n    filename = unescape(filename);\r\n    filename = rfc5987decode(filename);\r\n    filename = rfc2047decode(filename);\r\n    return fixupEncoding(filename);\r\n  }\r\n\r\n  tmp = rfc2231getparam(contentDisposition);\r\n\r\n  if (tmp) {\r\n    const filename = rfc2047decode(tmp);\r\n    return fixupEncoding(filename);\r\n  }\r\n\r\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\r\n\r\n  if (tmp) {\r\n    tmp = tmp[1];\r\n    let filename = rfc2616unquote(tmp);\r\n    filename = rfc2047decode(filename);\r\n    return fixupEncoding(filename);\r\n  }\r\n\r\n  function toParamRegExp(attributePattern, flags) {\r\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\r\n  }\r\n\r\n  function textdecode(encoding, value) {\r\n    if (encoding) {\r\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\r\n        return value;\r\n      }\r\n\r\n      try {\r\n        const decoder = new TextDecoder(encoding, {\r\n          fatal: true\r\n        });\r\n        const bytes = Array.from(value, function (ch) {\r\n          return ch.charCodeAt(0) & 0xff;\r\n        });\r\n        value = decoder.decode(new Uint8Array(bytes));\r\n        needsEncodingFixup = false;\r\n      } catch (e) {\r\n        if (/^utf-?8$/i.test(encoding)) {\r\n          try {\r\n            value = decodeURIComponent(escape(value));\r\n            needsEncodingFixup = false;\r\n          } catch (err) {}\r\n        }\r\n      }\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  function fixupEncoding(value) {\r\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\r\n      value = textdecode(\"utf-8\", value);\r\n\r\n      if (needsEncodingFixup) {\r\n        value = textdecode(\"iso-8859-1\", value);\r\n      }\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  function rfc2231getparam(contentDispositionStr) {\r\n    const matches = [];\r\n    let match;\r\n    const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\r\n\r\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\r\n      let [, n, quot, part] = match;\r\n      n = parseInt(n, 10);\r\n\r\n      if (n in matches) {\r\n        if (n === 0) {\r\n          break;\r\n        }\r\n\r\n        continue;\r\n      }\r\n\r\n      matches[n] = [quot, part];\r\n    }\r\n\r\n    const parts = [];\r\n\r\n    for (let n = 0; n < matches.length; ++n) {\r\n      if (!(n in matches)) {\r\n        break;\r\n      }\r\n\r\n      let [quot, part] = matches[n];\r\n      part = rfc2616unquote(part);\r\n\r\n      if (quot) {\r\n        part = unescape(part);\r\n\r\n        if (n === 0) {\r\n          part = rfc5987decode(part);\r\n        }\r\n      }\r\n\r\n      parts.push(part);\r\n    }\r\n\r\n    return parts.join(\"\");\r\n  }\r\n\r\n  function rfc2616unquote(value) {\r\n    if (value.startsWith('\"')) {\r\n      const parts = value.slice(1).split('\\\\\"');\r\n\r\n      for (let i = 0; i < parts.length; ++i) {\r\n        const quotindex = parts[i].indexOf('\"');\r\n\r\n        if (quotindex !== -1) {\r\n          parts[i] = parts[i].slice(0, quotindex);\r\n          parts.length = i + 1;\r\n        }\r\n\r\n        parts[i] = parts[i].replace(/\\\\(.)/g, \"$1\");\r\n      }\r\n\r\n      value = parts.join('\"');\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  function rfc5987decode(extvalue) {\r\n    const encodingend = extvalue.indexOf(\"'\");\r\n\r\n    if (encodingend === -1) {\r\n      return extvalue;\r\n    }\r\n\r\n    const encoding = extvalue.slice(0, encodingend);\r\n    const langvalue = extvalue.slice(encodingend + 1);\r\n    const value = langvalue.replace(/^[^']*'/, \"\");\r\n    return textdecode(encoding, value);\r\n  }\r\n\r\n  function rfc2047decode(value) {\r\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\r\n      return value;\r\n    }\r\n\r\n    return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\r\n      if (encoding === \"q\" || encoding === \"Q\") {\r\n        text = text.replace(/_/g, \" \");\r\n        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {\r\n          return String.fromCharCode(parseInt(hex, 16));\r\n        });\r\n        return textdecode(charset, text);\r\n      }\r\n\r\n      try {\r\n        text = atob(text);\r\n      } catch (e) {}\r\n\r\n      return textdecode(charset, text);\r\n    });\r\n  }\r\n\r\n  return \"\";\r\n}\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.PDFNetworkStream = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nvar _network_utils = __w_pdfjs_require__(24);\r\n\r\n;\r\nconst OK_RESPONSE = 200;\r\nconst PARTIAL_CONTENT_RESPONSE = 206;\r\n\r\nfunction getArrayBuffer(xhr) {\r\n  const data = xhr.response;\r\n\r\n  if (typeof data !== \"string\") {\r\n    return data;\r\n  }\r\n\r\n  const array = (0, _util.stringToBytes)(data);\r\n  return array.buffer;\r\n}\r\n\r\nclass NetworkManager {\r\n  constructor(url, args) {\r\n    this.url = url;\r\n    args = args || {};\r\n    this.isHttp = /^https?:/i.test(url);\r\n    this.httpHeaders = this.isHttp && args.httpHeaders || {};\r\n    this.withCredentials = args.withCredentials || false;\r\n\r\n    this.getXhr = args.getXhr || function NetworkManager_getXhr() {\r\n      return new XMLHttpRequest();\r\n    };\r\n\r\n    this.currXhrId = 0;\r\n    this.pendingRequests = Object.create(null);\r\n  }\r\n\r\n  requestRange(begin, end, listeners) {\r\n    const args = {\r\n      begin,\r\n      end\r\n    };\r\n\r\n    for (const prop in listeners) {\r\n      args[prop] = listeners[prop];\r\n    }\r\n\r\n    return this.request(args);\r\n  }\r\n\r\n  requestFull(listeners) {\r\n    return this.request(listeners);\r\n  }\r\n\r\n  request(args) {\r\n    const xhr = this.getXhr();\r\n    const xhrId = this.currXhrId++;\r\n    const pendingRequest = this.pendingRequests[xhrId] = {\r\n      xhr\r\n    };\r\n    xhr.open(\"GET\", this.url);\r\n    xhr.withCredentials = this.withCredentials;\r\n\r\n    for (const property in this.httpHeaders) {\r\n      const value = this.httpHeaders[property];\r\n\r\n      if (typeof value === \"undefined\") {\r\n        continue;\r\n      }\r\n\r\n      xhr.setRequestHeader(property, value);\r\n    }\r\n\r\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\r\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\r\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\r\n    } else {\r\n      pendingRequest.expectedStatus = OK_RESPONSE;\r\n    }\r\n\r\n    xhr.responseType = \"arraybuffer\";\r\n\r\n    if (args.onError) {\r\n      xhr.onerror = function (evt) {\r\n        args.onError(xhr.status);\r\n      };\r\n    }\r\n\r\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\r\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\r\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\r\n    pendingRequest.onDone = args.onDone;\r\n    pendingRequest.onError = args.onError;\r\n    pendingRequest.onProgress = args.onProgress;\r\n    xhr.send(null);\r\n    return xhrId;\r\n  }\r\n\r\n  onProgress(xhrId, evt) {\r\n    const pendingRequest = this.pendingRequests[xhrId];\r\n\r\n    if (!pendingRequest) {\r\n      return;\r\n    }\r\n\r\n    if (pendingRequest.onProgress) {\r\n      pendingRequest.onProgress(evt);\r\n    }\r\n  }\r\n\r\n  onStateChange(xhrId, evt) {\r\n    const pendingRequest = this.pendingRequests[xhrId];\r\n\r\n    if (!pendingRequest) {\r\n      return;\r\n    }\r\n\r\n    const xhr = pendingRequest.xhr;\r\n\r\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\r\n      pendingRequest.onHeadersReceived();\r\n      delete pendingRequest.onHeadersReceived;\r\n    }\r\n\r\n    if (xhr.readyState !== 4) {\r\n      return;\r\n    }\r\n\r\n    if (!(xhrId in this.pendingRequests)) {\r\n      return;\r\n    }\r\n\r\n    delete this.pendingRequests[xhrId];\r\n\r\n    if (xhr.status === 0 && this.isHttp) {\r\n      if (pendingRequest.onError) {\r\n        pendingRequest.onError(xhr.status);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    const xhrStatus = xhr.status || OK_RESPONSE;\r\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\r\n\r\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\r\n      if (pendingRequest.onError) {\r\n        pendingRequest.onError(xhr.status);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    const chunk = getArrayBuffer(xhr);\r\n\r\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\r\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\r\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\r\n      pendingRequest.onDone({\r\n        begin: parseInt(matches[1], 10),\r\n        chunk\r\n      });\r\n    } else if (chunk) {\r\n      pendingRequest.onDone({\r\n        begin: 0,\r\n        chunk\r\n      });\r\n    } else if (pendingRequest.onError) {\r\n      pendingRequest.onError(xhr.status);\r\n    }\r\n  }\r\n\r\n  getRequestXhr(xhrId) {\r\n    return this.pendingRequests[xhrId].xhr;\r\n  }\r\n\r\n  isPendingRequest(xhrId) {\r\n    return xhrId in this.pendingRequests;\r\n  }\r\n\r\n  abortRequest(xhrId) {\r\n    const xhr = this.pendingRequests[xhrId].xhr;\r\n    delete this.pendingRequests[xhrId];\r\n    xhr.abort();\r\n  }\r\n\r\n}\r\n\r\nclass PDFNetworkStream {\r\n  constructor(source) {\r\n    this._source = source;\r\n    this._manager = new NetworkManager(source.url, {\r\n      httpHeaders: source.httpHeaders,\r\n      withCredentials: source.withCredentials\r\n    });\r\n    this._rangeChunkSize = source.rangeChunkSize;\r\n    this._fullRequestReader = null;\r\n    this._rangeRequestReaders = [];\r\n  }\r\n\r\n  _onRangeRequestReaderClosed(reader) {\r\n    const i = this._rangeRequestReaders.indexOf(reader);\r\n\r\n    if (i >= 0) {\r\n      this._rangeRequestReaders.splice(i, 1);\r\n    }\r\n  }\r\n\r\n  getFullReader() {\r\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\r\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\r\n    return this._fullRequestReader;\r\n  }\r\n\r\n  getRangeReader(begin, end) {\r\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\r\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\r\n\r\n    this._rangeRequestReaders.push(reader);\r\n\r\n    return reader;\r\n  }\r\n\r\n  cancelAllRequests(reason) {\r\n    if (this._fullRequestReader) {\r\n      this._fullRequestReader.cancel(reason);\r\n    }\r\n\r\n    const readers = this._rangeRequestReaders.slice(0);\r\n\r\n    readers.forEach(function (reader) {\r\n      reader.cancel(reason);\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexports.PDFNetworkStream = PDFNetworkStream;\r\n\r\nclass PDFNetworkStreamFullRequestReader {\r\n  constructor(manager, source) {\r\n    this._manager = manager;\r\n    const args = {\r\n      onHeadersReceived: this._onHeadersReceived.bind(this),\r\n      onDone: this._onDone.bind(this),\r\n      onError: this._onError.bind(this),\r\n      onProgress: this._onProgress.bind(this)\r\n    };\r\n    this._url = source.url;\r\n    this._fullRequestId = manager.requestFull(args);\r\n    this._headersReceivedCapability = (0, _util.createPromiseCapability)();\r\n    this._disableRange = source.disableRange || false;\r\n    this._contentLength = source.length;\r\n    this._rangeChunkSize = source.rangeChunkSize;\r\n\r\n    if (!this._rangeChunkSize && !this._disableRange) {\r\n      this._disableRange = true;\r\n    }\r\n\r\n    this._isStreamingSupported = false;\r\n    this._isRangeSupported = false;\r\n    this._cachedChunks = [];\r\n    this._requests = [];\r\n    this._done = false;\r\n    this._storedError = undefined;\r\n    this._filename = null;\r\n    this.onProgress = null;\r\n  }\r\n\r\n  _onHeadersReceived() {\r\n    const fullRequestXhrId = this._fullRequestId;\r\n\r\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\r\n\r\n    const getResponseHeader = name => {\r\n      return fullRequestXhr.getResponseHeader(name);\r\n    };\r\n\r\n    const {\r\n      allowRangeRequests,\r\n      suggestedLength\r\n    } = (0, _network_utils.validateRangeRequestCapabilities)({\r\n      getResponseHeader,\r\n      isHttp: this._manager.isHttp,\r\n      rangeChunkSize: this._rangeChunkSize,\r\n      disableRange: this._disableRange\r\n    });\r\n\r\n    if (allowRangeRequests) {\r\n      this._isRangeSupported = true;\r\n    }\r\n\r\n    this._contentLength = suggestedLength || this._contentLength;\r\n    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\r\n\r\n    if (this._isRangeSupported) {\r\n      this._manager.abortRequest(fullRequestXhrId);\r\n    }\r\n\r\n    this._headersReceivedCapability.resolve();\r\n  }\r\n\r\n  _onDone(args) {\r\n    if (args) {\r\n      if (this._requests.length > 0) {\r\n        const requestCapability = this._requests.shift();\r\n\r\n        requestCapability.resolve({\r\n          value: args.chunk,\r\n          done: false\r\n        });\r\n      } else {\r\n        this._cachedChunks.push(args.chunk);\r\n      }\r\n    }\r\n\r\n    this._done = true;\r\n\r\n    if (this._cachedChunks.length > 0) {\r\n      return;\r\n    }\r\n\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    });\r\n\r\n    this._requests = [];\r\n  }\r\n\r\n  _onError(status) {\r\n    const url = this._url;\r\n    const exception = (0, _network_utils.createResponseStatusError)(status, url);\r\n    this._storedError = exception;\r\n\r\n    this._headersReceivedCapability.reject(exception);\r\n\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.reject(exception);\r\n    });\r\n\r\n    this._requests = [];\r\n    this._cachedChunks = [];\r\n  }\r\n\r\n  _onProgress(data) {\r\n    if (this.onProgress) {\r\n      this.onProgress({\r\n        loaded: data.loaded,\r\n        total: data.lengthComputable ? data.total : this._contentLength\r\n      });\r\n    }\r\n  }\r\n\r\n  get filename() {\r\n    return this._filename;\r\n  }\r\n\r\n  get isRangeSupported() {\r\n    return this._isRangeSupported;\r\n  }\r\n\r\n  get isStreamingSupported() {\r\n    return this._isStreamingSupported;\r\n  }\r\n\r\n  get contentLength() {\r\n    return this._contentLength;\r\n  }\r\n\r\n  get headersReady() {\r\n    return this._headersReceivedCapability.promise;\r\n  }\r\n\r\n  async read() {\r\n    if (this._storedError) {\r\n      throw this._storedError;\r\n    }\r\n\r\n    if (this._cachedChunks.length > 0) {\r\n      const chunk = this._cachedChunks.shift();\r\n\r\n      return {\r\n        value: chunk,\r\n        done: false\r\n      };\r\n    }\r\n\r\n    if (this._done) {\r\n      return {\r\n        value: undefined,\r\n        done: true\r\n      };\r\n    }\r\n\r\n    const requestCapability = (0, _util.createPromiseCapability)();\r\n\r\n    this._requests.push(requestCapability);\r\n\r\n    return requestCapability.promise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    this._done = true;\r\n\r\n    this._headersReceivedCapability.reject(reason);\r\n\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    });\r\n\r\n    this._requests = [];\r\n\r\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\r\n      this._manager.abortRequest(this._fullRequestId);\r\n    }\r\n\r\n    this._fullRequestReader = null;\r\n  }\r\n\r\n}\r\n\r\nclass PDFNetworkStreamRangeRequestReader {\r\n  constructor(manager, begin, end) {\r\n    this._manager = manager;\r\n    const args = {\r\n      onDone: this._onDone.bind(this),\r\n      onProgress: this._onProgress.bind(this)\r\n    };\r\n    this._requestId = manager.requestRange(begin, end, args);\r\n    this._requests = [];\r\n    this._queuedChunk = null;\r\n    this._done = false;\r\n    this.onProgress = null;\r\n    this.onClosed = null;\r\n  }\r\n\r\n  _close() {\r\n    if (this.onClosed) {\r\n      this.onClosed(this);\r\n    }\r\n  }\r\n\r\n  _onDone(data) {\r\n    const chunk = data.chunk;\r\n\r\n    if (this._requests.length > 0) {\r\n      const requestCapability = this._requests.shift();\r\n\r\n      requestCapability.resolve({\r\n        value: chunk,\r\n        done: false\r\n      });\r\n    } else {\r\n      this._queuedChunk = chunk;\r\n    }\r\n\r\n    this._done = true;\r\n\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    });\r\n\r\n    this._requests = [];\r\n\r\n    this._close();\r\n  }\r\n\r\n  _onProgress(evt) {\r\n    if (!this.isStreamingSupported && this.onProgress) {\r\n      this.onProgress({\r\n        loaded: evt.loaded\r\n      });\r\n    }\r\n  }\r\n\r\n  get isStreamingSupported() {\r\n    return false;\r\n  }\r\n\r\n  async read() {\r\n    if (this._queuedChunk !== null) {\r\n      const chunk = this._queuedChunk;\r\n      this._queuedChunk = null;\r\n      return {\r\n        value: chunk,\r\n        done: false\r\n      };\r\n    }\r\n\r\n    if (this._done) {\r\n      return {\r\n        value: undefined,\r\n        done: true\r\n      };\r\n    }\r\n\r\n    const requestCapability = (0, _util.createPromiseCapability)();\r\n\r\n    this._requests.push(requestCapability);\r\n\r\n    return requestCapability.promise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    this._done = true;\r\n\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    });\r\n\r\n    this._requests = [];\r\n\r\n    if (this._manager.isPendingRequest(this._requestId)) {\r\n      this._manager.abortRequest(this._requestId);\r\n    }\r\n\r\n    this._close();\r\n  }\r\n\r\n}\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\r\n\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.PDFFetchStream = void 0;\r\n\r\nvar _util = __w_pdfjs_require__(2);\r\n\r\nvar _network_utils = __w_pdfjs_require__(24);\r\n\r\n;\r\n\r\nfunction createFetchOptions(headers, withCredentials, abortController) {\r\n  return {\r\n    method: \"GET\",\r\n    headers,\r\n    signal: abortController?.signal,\r\n    mode: \"cors\",\r\n    credentials: withCredentials ? \"include\" : \"same-origin\",\r\n    redirect: \"follow\"\r\n  };\r\n}\r\n\r\nfunction createHeaders(httpHeaders) {\r\n  const headers = new Headers();\r\n\r\n  for (const property in httpHeaders) {\r\n    const value = httpHeaders[property];\r\n\r\n    if (typeof value === \"undefined\") {\r\n      continue;\r\n    }\r\n\r\n    headers.append(property, value);\r\n  }\r\n\r\n  return headers;\r\n}\r\n\r\nclass PDFFetchStream {\r\n  constructor(source) {\r\n    this.source = source;\r\n    this.isHttp = /^https?:/i.test(source.url);\r\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\r\n    this._fullRequestReader = null;\r\n    this._rangeRequestReaders = [];\r\n  }\r\n\r\n  get _progressiveDataLength() {\r\n    return this._fullRequestReader?._loaded ?? 0;\r\n  }\r\n\r\n  getFullReader() {\r\n    (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\r\n    this._fullRequestReader = new PDFFetchStreamReader(this);\r\n    return this._fullRequestReader;\r\n  }\r\n\r\n  getRangeReader(begin, end) {\r\n    if (end <= this._progressiveDataLength) {\r\n      return null;\r\n    }\r\n\r\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\r\n\r\n    this._rangeRequestReaders.push(reader);\r\n\r\n    return reader;\r\n  }\r\n\r\n  cancelAllRequests(reason) {\r\n    if (this._fullRequestReader) {\r\n      this._fullRequestReader.cancel(reason);\r\n    }\r\n\r\n    const readers = this._rangeRequestReaders.slice(0);\r\n\r\n    readers.forEach(function (reader) {\r\n      reader.cancel(reason);\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexports.PDFFetchStream = PDFFetchStream;\r\n\r\nclass PDFFetchStreamReader {\r\n  constructor(stream) {\r\n    this._stream = stream;\r\n    this._reader = null;\r\n    this._loaded = 0;\r\n    this._filename = null;\r\n    const source = stream.source;\r\n    this._withCredentials = source.withCredentials || false;\r\n    this._contentLength = source.length;\r\n    this._headersCapability = (0, _util.createPromiseCapability)();\r\n    this._disableRange = source.disableRange || false;\r\n    this._rangeChunkSize = source.rangeChunkSize;\r\n\r\n    if (!this._rangeChunkSize && !this._disableRange) {\r\n      this._disableRange = true;\r\n    }\r\n\r\n    if (typeof AbortController !== \"undefined\") {\r\n      this._abortController = new AbortController();\r\n    }\r\n\r\n    this._isStreamingSupported = !source.disableStream;\r\n    this._isRangeSupported = !source.disableRange;\r\n    this._headers = createHeaders(this._stream.httpHeaders);\r\n    const url = source.url;\r\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\r\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\r\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\r\n      }\r\n\r\n      this._reader = response.body.getReader();\r\n\r\n      this._headersCapability.resolve();\r\n\r\n      const getResponseHeader = name => {\r\n        return response.headers.get(name);\r\n      };\r\n\r\n      const {\r\n        allowRangeRequests,\r\n        suggestedLength\r\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\r\n        getResponseHeader,\r\n        isHttp: this._stream.isHttp,\r\n        rangeChunkSize: this._rangeChunkSize,\r\n        disableRange: this._disableRange\r\n      });\r\n      this._isRangeSupported = allowRangeRequests;\r\n      this._contentLength = suggestedLength || this._contentLength;\r\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\r\n\r\n      if (!this._isStreamingSupported && this._isRangeSupported) {\r\n        this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\r\n      }\r\n    }).catch(this._headersCapability.reject);\r\n    this.onProgress = null;\r\n  }\r\n\r\n  get headersReady() {\r\n    return this._headersCapability.promise;\r\n  }\r\n\r\n  get filename() {\r\n    return this._filename;\r\n  }\r\n\r\n  get contentLength() {\r\n    return this._contentLength;\r\n  }\r\n\r\n  get isRangeSupported() {\r\n    return this._isRangeSupported;\r\n  }\r\n\r\n  get isStreamingSupported() {\r\n    return this._isStreamingSupported;\r\n  }\r\n\r\n  async read() {\r\n    await this._headersCapability.promise;\r\n    const {\r\n      value,\r\n      done\r\n    } = await this._reader.read();\r\n\r\n    if (done) {\r\n      return {\r\n        value,\r\n        done\r\n      };\r\n    }\r\n\r\n    this._loaded += value.byteLength;\r\n\r\n    if (this.onProgress) {\r\n      this.onProgress({\r\n        loaded: this._loaded,\r\n        total: this._contentLength\r\n      });\r\n    }\r\n\r\n    const buffer = new Uint8Array(value).buffer;\r\n    return {\r\n      value: buffer,\r\n      done: false\r\n    };\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (this._reader) {\r\n      this._reader.cancel(reason);\r\n    }\r\n\r\n    if (this._abortController) {\r\n      this._abortController.abort();\r\n    }\r\n  }\r\n\r\n}\r\n\r\nclass PDFFetchStreamRangeReader {\r\n  constructor(stream, begin, end) {\r\n    this._stream = stream;\r\n    this._reader = null;\r\n    this._loaded = 0;\r\n    const source = stream.source;\r\n    this._withCredentials = source.withCredentials || false;\r\n    this._readCapability = (0, _util.createPromiseCapability)();\r\n    this._isStreamingSupported = !source.disableStream;\r\n\r\n    if (typeof AbortController !== \"undefined\") {\r\n      this._abortController = new AbortController();\r\n    }\r\n\r\n    this._headers = createHeaders(this._stream.httpHeaders);\r\n\r\n    this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\r\n\r\n    const url = source.url;\r\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\r\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\r\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\r\n      }\r\n\r\n      this._readCapability.resolve();\r\n\r\n      this._reader = response.body.getReader();\r\n    }).catch(reason => {\r\n      if (reason?.name === \"AbortError\") {\r\n        return;\r\n      }\r\n\r\n      throw reason;\r\n    });\r\n    this.onProgress = null;\r\n  }\r\n\r\n  get isStreamingSupported() {\r\n    return this._isStreamingSupported;\r\n  }\r\n\r\n  async read() {\r\n    await this._readCapability.promise;\r\n    const {\r\n      value,\r\n      done\r\n    } = await this._reader.read();\r\n\r\n    if (done) {\r\n      return {\r\n        value,\r\n        done\r\n      };\r\n    }\r\n\r\n    this._loaded += value.byteLength;\r\n\r\n    if (this.onProgress) {\r\n      this.onProgress({\r\n        loaded: this._loaded\r\n      });\r\n    }\r\n\r\n    const buffer = new Uint8Array(value).buffer;\r\n    return {\r\n      value: buffer,\r\n      done: false\r\n    };\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (this._reader) {\r\n      this._reader.cancel(reason);\r\n    }\r\n\r\n    if (this._abortController) {\r\n      this._abortController.abort();\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/***/ })\r\n/******/ \t]);\r\n/************************************************************************/\r\n/******/ \t// The module cache\r\n/******/ \tvar __webpack_module_cache__ = {};\r\n/******/ \t\r\n/******/ \t// The require function\r\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\r\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\r\n/******/ \t\t\t// no module.id needed\r\n/******/ \t\t\t// no module.loaded needed\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/ \t\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);\r\n/******/ \t\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/ \t\r\n/************************************************************************/\r\n/******/ \t// module exports must be returned from runtime so entry inlining is disabled\r\n/******/ \t// startup\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __w_pdfjs_require__(0);\r\n/******/ })()\r\n;\r\n});\r\n//# sourceMappingURL=pdf.js.map"],"names":["this"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA,SAAA,gCAAA,CAAA,IAAA,EAAA,OAAA,EAAA;EACA,MAAA,QAAA,OAAA,yCAAA,OAAA,OAAA,QAAA,IAAA,QAAA,MAAA,yCAAA,MAAA,OAAA,QAAA,EACA,MAAA,CAAA,OAAA,GAAA,OAAA,EAAA,CADA,KAEA,IAAA,OAAA,MAAA,KAAA,UAAA,IAAA,MAAA,CAAA,GAAA,EACA,MAAA,CAAA,sBAAA,EAAA,EAAA,EAAA,OAAA,CAAA,CADA,KAEA,IAAA,QAAA,OAAA,yCAAA,OAAA,OAAA,QAAA,EACA,OAAA,CAAA,sBAAA,CAAA,GAAA,OAAA,EAAA,CADA,KAGA,IAAA,CAAA,sBAAA,CAAA,GAAA,IAAA,CAAA,QAAA,GAAA,OAAA,EAAA;EACC,CATD,EASCA,SATD,EASC,YAAA;EACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;GAVA;;;;;;"}